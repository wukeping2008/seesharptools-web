# ğŸ“ˆ StripChart æ¡å¸¦å›¾æ§ä»¶æŠ€æœ¯è®¾è®¡æ–¹æ¡ˆ

## æ¦‚è¿°
StripChartæ˜¯SeeSharpTools Webå¹³å°çš„æ ¸å¿ƒå›¾è¡¨æ§ä»¶ï¼Œä¸“é—¨è®¾è®¡ç”¨äºé«˜é€Ÿæ•°æ®æµçš„å®æ—¶æ˜¾ç¤ºã€‚æ”¯æŒ1GS/sé‡‡æ ·ç‡ã€16-32é€šé“åŒæ­¥æ˜¾ç¤ºï¼Œæ˜¯æ•´ä¸ªå¹³å°çš„æŠ€æœ¯æ ¸å¿ƒå’Œæ€§èƒ½åŸºå‡†ã€‚

## ğŸ¯ è®¾è®¡ç›®æ ‡

### æ€§èƒ½æŒ‡æ ‡
- **æ•°æ®ååé‡**: æ”¯æŒ1GS/sé‡‡æ ·ç‡æ•°æ®æ˜¾ç¤º
- **é€šé“æ•°é‡**: åŒæ—¶æ˜¾ç¤º16-32ä¸ªé€šé“
- **å»¶è¿Ÿè¦æ±‚**: æ•°æ®æ˜¾ç¤ºå»¶è¿Ÿ<10ms
- **æ¸²æŸ“æ€§èƒ½**: ç¨³å®š60fpsåˆ·æ–°ç‡
- **å†…å­˜ä½¿ç”¨**: å¤§æ•°æ®é‡åœºæ™¯ä¸‹<2GBå†…å­˜å ç”¨

### åŠŸèƒ½ç‰¹æ€§
- **å®æ—¶æ•°æ®æµ**: è¿ç»­æ•°æ®æµå®æ—¶æ˜¾ç¤º
- **å†å²æ•°æ®å›æ”¾**: æ”¯æŒå†å²æ•°æ®åŠ è½½å’Œå›æ”¾
- **å¤šé€šé“ç®¡ç†**: çµæ´»çš„é€šé“é…ç½®å’Œæ˜¾ç¤ºæ§åˆ¶
- **æ—¶é—´è½´æ§åˆ¶**: ç²¾ç¡®çš„æ—¶é—´èŒƒå›´å’Œç¼©æ”¾æ§åˆ¶
- **æ•°æ®å‹ç¼©**: æ™ºèƒ½æ•°æ®é‡‡æ ·å’Œå‹ç¼©ç®—æ³•
- **å¯¼å‡ºåŠŸèƒ½**: å¤šæ ¼å¼æ•°æ®å’Œå›¾åƒå¯¼å‡º

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    StripChart ç»„ä»¶æ¶æ„                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ ç”¨æˆ·ç•Œé¢å±‚  â”‚ â”‚ æ§åˆ¶é¢æ¿    â”‚ â”‚ å·¥å…·æ       â”‚ â”‚ çŠ¶æ€æ       â”‚ â”‚
â”‚  â”‚ UI Layer    â”‚ â”‚ Control     â”‚ â”‚ Toolbar     â”‚ â”‚ Status      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ æ•°æ®ç®¡ç†å±‚  â”‚ â”‚ æ¸²æŸ“å¼•æ“    â”‚ â”‚ æ—¶é—´è½´      â”‚ â”‚ äº¤äº’æ§åˆ¶    â”‚ â”‚
â”‚  â”‚ Data Mgmt   â”‚ â”‚ Renderer    â”‚ â”‚ TimeAxis    â”‚ â”‚ Interaction â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ æ•°æ®å¤„ç†å±‚  â”‚ â”‚ ç¼“å†²ç®¡ç†    â”‚ â”‚ å‹ç¼©ç®—æ³•    â”‚ â”‚ å†…å­˜ç®¡ç†    â”‚ â”‚
â”‚  â”‚ Processing  â”‚ â”‚ Buffer      â”‚ â”‚ Compression â”‚ â”‚ Memory      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ æ•°æ®æºå±‚    â”‚ â”‚ WebSocket   â”‚ â”‚ HTTP API    â”‚ â”‚ æœ¬åœ°å­˜å‚¨    â”‚ â”‚
â”‚  â”‚ Data Source â”‚ â”‚ Real-time   â”‚ â”‚ Historical  â”‚ â”‚ Local       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒæ¨¡å—è®¾è®¡

#### 1. æ•°æ®ç®¡ç†æ¨¡å— (DataManager)
```typescript
class StripChartDataManager {
  private channels: Map<number, ChannelData>
  private buffer: CircularBuffer
  private timeRange: TimeRange
  private dataProcessor: DataProcessor
  
  // æ•°æ®æ¥æ”¶å’Œå¤„ç†
  addData(channelId: number, data: number[], timestamp: number): void
  getData(channelId: number, timeRange: TimeRange): number[]
  getVisibleData(): VisibleData
  
  // ç¼“å†²åŒºç®¡ç†
  setBufferSize(size: number): void
  clearBuffer(): void
  getBufferStatus(): BufferStatus
}

interface ChannelData {
  id: number
  name: string
  unit: string
  color: string
  visible: boolean
  data: CircularBuffer<DataPoint>
  statistics: ChannelStatistics
}

interface DataPoint {
  value: number
  timestamp: number
  quality: DataQuality
}
```

#### 2. æ¸²æŸ“å¼•æ“ (RenderEngine)
```typescript
class StripChartRenderer {
  private canvas: HTMLCanvasElement
  private context: CanvasRenderingContext2D | WebGLRenderingContext
  private renderMode: 'canvas2d' | 'webgl'
  private viewport: Viewport
  
  // æ¸²æŸ“æ§åˆ¶
  render(data: VisibleData, options: RenderOptions): void
  setRenderMode(mode: 'canvas2d' | 'webgl'): void
  updateViewport(viewport: Viewport): void
  
  // æ€§èƒ½ä¼˜åŒ–
  enableLOD(enabled: boolean): void  // Level of Detail
  setMaxPoints(maxPoints: number): void
  enableAntiAliasing(enabled: boolean): void
}

interface Viewport {
  x: number
  y: number
  width: number
  height: number
  timeRange: [number, number]
  valueRange: [number, number]
}
```

#### 3. æ•°æ®å‹ç¼©ç®—æ³• (CompressionEngine)
```typescript
class DataCompressionEngine {
  // LTTB (Largest Triangle Three Buckets) ç®—æ³•
  lttbDownsample(data: DataPoint[], targetPoints: number): DataPoint[]
  
  // è‡ªé€‚åº”é‡‡æ ·ç®—æ³•
  adaptiveSample(data: DataPoint[], viewport: Viewport): DataPoint[]
  
  // å®æ—¶å‹ç¼©
  realtimeCompress(data: DataPoint[], compressionRatio: number): DataPoint[]
  
  // è´¨é‡æ§åˆ¶
  calculateCompressionQuality(original: DataPoint[], compressed: DataPoint[]): number
}
```

## ğŸš€ æ ¸å¿ƒæŠ€æœ¯å®ç°

### 1. é«˜æ€§èƒ½æ•°æ®ç¼“å†²

#### ç¯å½¢ç¼“å†²åŒºå®ç°
```typescript
class CircularBuffer<T> {
  private buffer: T[]
  private head: number = 0
  private tail: number = 0
  private size: number
  private capacity: number
  
  constructor(capacity: number) {
    this.capacity = capacity
    this.buffer = new Array(capacity)
    this.size = 0
  }
  
  push(item: T): void {
    this.buffer[this.tail] = item
    this.tail = (this.tail + 1) % this.capacity
    
    if (this.size < this.capacity) {
      this.size++
    } else {
      // ç¼“å†²åŒºæ»¡ï¼Œç§»åŠ¨å¤´æŒ‡é’ˆ
      this.head = (this.head + 1) % this.capacity
    }
  }
  
  getRange(start: number, count: number): T[] {
    const result: T[] = []
    for (let i = 0; i < count; i++) {
      const index = (this.head + start + i) % this.capacity
      if (index < this.size) {
        result.push(this.buffer[index])
      }
    }
    return result
  }
  
  // æ—¶é—´èŒƒå›´æŸ¥è¯¢
  getTimeRange(startTime: number, endTime: number): T[] {
    // äºŒåˆ†æŸ¥æ‰¾ä¼˜åŒ–çš„æ—¶é—´èŒƒå›´æŸ¥è¯¢
    const startIndex = this.binarySearchTime(startTime)
    const endIndex = this.binarySearchTime(endTime)
    return this.getRange(startIndex, endIndex - startIndex)
  }
}
```

#### å¤šçº§ç¼“å­˜ç­–ç•¥
```typescript
class MultiLevelCache {
  private l1Cache: Map<string, DataPoint[]>  // æœ€è¿‘æ•°æ®
  private l2Cache: Map<string, DataPoint[]>  // å‹ç¼©æ•°æ®
  private l3Cache: Map<string, DataPoint[]>  // å†å²æ•°æ®
  
  private l1Size: number = 1000000  // 100ä¸‡ç‚¹
  private l2Size: number = 10000000 // 1000ä¸‡ç‚¹
  private l3Size: number = 100000000 // 1äº¿ç‚¹
  
  getData(channelId: string, timeRange: TimeRange, resolution: number): DataPoint[] {
    // æ ¹æ®æ—¶é—´èŒƒå›´å’Œåˆ†è¾¨ç‡é€‰æ‹©åˆé€‚çš„ç¼“å­˜çº§åˆ«
    if (this.isRecentData(timeRange)) {
      return this.getFromL1Cache(channelId, timeRange)
    } else if (this.isMediumTermData(timeRange)) {
      return this.getFromL2Cache(channelId, timeRange, resolution)
    } else {
      return this.getFromL3Cache(channelId, timeRange, resolution)
    }
  }
}
```

### 2. LTTBæ•°æ®å‹ç¼©ç®—æ³•

#### æ ¸å¿ƒç®—æ³•å®ç°
```typescript
class LTTBAlgorithm {
  /**
   * Largest Triangle Three Buckets ç®—æ³•
   * ä¿æŒæ•°æ®çš„è§†è§‰ç‰¹å¾ï¼Œé€‚åˆæ—¶åºæ•°æ®å‹ç¼©
   */
  downsample(data: DataPoint[], targetPoints: number): DataPoint[] {
    if (data.length <= targetPoints) {
      return data
    }
    
    const sampled: DataPoint[] = []
    const bucketSize = (data.length - 2) / (targetPoints - 2)
    
    // ä¿ç•™ç¬¬ä¸€ä¸ªç‚¹
    sampled.push(data[0])
    
    for (let i = 0; i < targetPoints - 2; i++) {
      // è®¡ç®—å½“å‰æ¡¶çš„èŒƒå›´
      const bucketStart = Math.floor(i * bucketSize) + 1
      const bucketEnd = Math.floor((i + 1) * bucketSize) + 1
      
      // è®¡ç®—ä¸‹ä¸€ä¸ªæ¡¶çš„å¹³å‡ç‚¹
      const nextBucketStart = Math.floor((i + 1) * bucketSize) + 1
      const nextBucketEnd = Math.floor((i + 2) * bucketSize) + 1
      
      let avgX = 0, avgY = 0, avgCount = 0
      for (let j = nextBucketStart; j < nextBucketEnd && j < data.length; j++) {
        avgX += data[j].timestamp
        avgY += data[j].value
        avgCount++
      }
      
      if (avgCount > 0) {
        avgX /= avgCount
        avgY /= avgCount
      }
      
      // åœ¨å½“å‰æ¡¶ä¸­æ‰¾åˆ°å½¢æˆæœ€å¤§ä¸‰è§’å½¢é¢ç§¯çš„ç‚¹
      let maxArea = -1
      let maxAreaIndex = bucketStart
      
      const prevPoint = sampled[sampled.length - 1]
      
      for (let j = bucketStart; j < bucketEnd && j < data.length; j++) {
        const area = Math.abs(
          (prevPoint.timestamp - avgX) * (data[j].value - prevPoint.value) -
          (prevPoint.timestamp - data[j].timestamp) * (avgY - prevPoint.value)
        ) * 0.5
        
        if (area > maxArea) {
          maxArea = area
          maxAreaIndex = j
        }
      }
      
      sampled.push(data[maxAreaIndex])
    }
    
    // ä¿ç•™æœ€åä¸€ä¸ªç‚¹
    sampled.push(data[data.length - 1])
    
    return sampled
  }
}
```

### 3. WebGLé«˜æ€§èƒ½æ¸²æŸ“

#### WebGLæ¸²æŸ“å™¨å®ç°
```typescript
class WebGLStripChartRenderer {
  private gl: WebGLRenderingContext
  private shaderProgram: WebGLProgram
  private vertexBuffer: WebGLBuffer
  private colorBuffer: WebGLBuffer
  
  constructor(canvas: HTMLCanvasElement) {
    this.gl = canvas.getContext('webgl')!
    this.initShaders()
    this.initBuffers()
  }
  
  private initShaders(): void {
    const vertexShaderSource = `
      attribute vec2 a_position;
      attribute vec3 a_color;
      uniform mat3 u_transform;
      varying vec3 v_color;
      
      void main() {
        vec3 position = u_transform * vec3(a_position, 1.0);
        gl_Position = vec4(position.xy, 0.0, 1.0);
        v_color = a_color;
      }
    `
    
    const fragmentShaderSource = `
      precision mediump float;
      varying vec3 v_color;
      
      void main() {
        gl_FragColor = vec4(v_color, 1.0);
      }
    `
    
    this.shaderProgram = this.createShaderProgram(
      vertexShaderSource, 
      fragmentShaderSource
    )
  }
  
  render(channels: ChannelData[], viewport: Viewport): void {
    this.gl.clear(this.gl.COLOR_BUFFER_BIT)
    this.gl.useProgram(this.shaderProgram)
    
    // è®¾ç½®å˜æ¢çŸ©é˜µ
    const transform = this.calculateTransform(viewport)
    const transformLocation = this.gl.getUniformLocation(this.shaderProgram, 'u_transform')
    this.gl.uniformMatrix3fv(transformLocation, false, transform)
    
    // æ¸²æŸ“æ¯ä¸ªé€šé“
    channels.forEach(channel => {
      if (channel.visible) {
        this.renderChannel(channel)
      }
    })
  }
  
  private renderChannel(channel: ChannelData): void {
    // å‡†å¤‡é¡¶ç‚¹æ•°æ®
    const vertices = this.prepareVertices(channel.data)
    const colors = this.prepareColors(channel.color, vertices.length / 2)
    
    // æ›´æ–°ç¼“å†²åŒº
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer)
    this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.DYNAMIC_DRAW)
    
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.colorBuffer)
    this.gl.bufferData(this.gl.ARRAY_BUFFER, colors, this.gl.DYNAMIC_DRAW)
    
    // ç»˜åˆ¶çº¿æ¡
    this.gl.drawArrays(this.gl.LINE_STRIP, 0, vertices.length / 2)
  }
}
```

### 4. å®æ—¶æ•°æ®æµå¤„ç†

#### WebSocketæ•°æ®æ¥æ”¶
```typescript
class RealtimeDataReceiver {
  private websocket: WebSocket
  private dataQueue: Queue<DataPacket>
  private processingWorker: Worker
  
  constructor(url: string) {
    this.websocket = new WebSocket(url)
    this.dataQueue = new Queue()
    this.processingWorker = new Worker('/workers/dataProcessor.js')
    this.setupEventHandlers()
  }
  
  private setupEventHandlers(): void {
    this.websocket.onmessage = (event) => {
      const packet = JSON.parse(event.data) as DataPacket
      this.dataQueue.enqueue(packet)
    }
    
    // ä½¿ç”¨Web Workerå¤„ç†æ•°æ®
    this.processingWorker.onmessage = (event) => {
      const processedData = event.data
      this.onDataProcessed(processedData)
    }
    
    // å®šæ—¶å¤„ç†é˜Ÿåˆ—ä¸­çš„æ•°æ®
    setInterval(() => {
      this.processQueuedData()
    }, 16) // 60fps
  }
  
  private processQueuedData(): void {
    const batchSize = 1000
    const batch: DataPacket[] = []
    
    for (let i = 0; i < batchSize && !this.dataQueue.isEmpty(); i++) {
      batch.push(this.dataQueue.dequeue())
    }
    
    if (batch.length > 0) {
      // å‘é€åˆ°Web Workerå¤„ç†
      this.processingWorker.postMessage({
        type: 'processBatch',
        data: batch
      })
    }
  }
}
```

#### Web Workeræ•°æ®å¤„ç†
```javascript
// workers/dataProcessor.js
class DataProcessor {
  constructor() {
    this.compressionEngine = new LTTBAlgorithm()
  }
  
  processBatch(packets) {
    const processedChannels = new Map()
    
    packets.forEach(packet => {
      packet.channels.forEach(channelData => {
        const channelId = channelData.id
        
        if (!processedChannels.has(channelId)) {
          processedChannels.set(channelId, [])
        }
        
        // æ•°æ®éªŒè¯å’Œæ¸…ç†
        const cleanedData = this.validateAndCleanData(channelData.values)
        
        // æ·»åŠ æ—¶é—´æˆ³
        const timestampedData = cleanedData.map((value, index) => ({
          value,
          timestamp: packet.timestamp + index * packet.interval,
          quality: this.assessDataQuality(value)
        }))
        
        processedChannels.get(channelId).push(...timestampedData)
      })
    })
    
    // è¿”å›å¤„ç†ç»“æœ
    return {
      type: 'batchProcessed',
      channels: Array.from(processedChannels.entries()).map(([id, data]) => ({
        id,
        data: this.compressionEngine.adaptiveSample(data, this.getViewport())
      }))
    }
  }
}

// Web Workeræ¶ˆæ¯å¤„ç†
self.onmessage = function(event) {
  const processor = new DataProcessor()
  
  switch (event.data.type) {
    case 'processBatch':
      const result = processor.processBatch(event.data.data)
      self.postMessage(result)
      break
  }
}
```

## ğŸ¨ ç”¨æˆ·ç•Œé¢è®¾è®¡

### Vueç»„ä»¶ç»“æ„
```vue
<template>
  <div class="strip-chart" ref="chartContainer">
    <!-- å·¥å…·æ  -->
    <div class="chart-toolbar">
      <el-button-group>
        <el-button @click="startRealtime" :disabled="isRealtime">
          <el-icon><VideoPlay /></el-icon>
          å®æ—¶
        </el-button>
        <el-button @click="pauseRealtime" :disabled="!isRealtime">
          <el-icon><VideoPause /></el-icon>
          æš‚åœ
        </el-button>
        <el-button @click="resetView">
          <el-icon><Refresh /></el-icon>
          é‡ç½®
        </el-button>
      </el-button-group>
      
      <el-select v-model="timeRange" @change="onTimeRangeChange">
        <el-option label="æœ€è¿‘1åˆ†é’Ÿ" value="1m" />
        <el-option label="æœ€è¿‘5åˆ†é’Ÿ" value="5m" />
        <el-option label="æœ€è¿‘1å°æ—¶" value="1h" />
        <el-option label="è‡ªå®šä¹‰" value="custom" />
      </el-select>
      
      <el-button @click="showChannelConfig">
        <el-icon><Setting /></el-icon>
        é€šé“é…ç½®
      </el-button>
    </div>
    
    <!-- ä¸»å›¾è¡¨åŒºåŸŸ -->
    <div class="chart-main" ref="chartMain">
      <canvas 
        ref="chartCanvas"
        :width="canvasWidth"
        :height="canvasHeight"
        @mousedown="onMouseDown"
        @mousemove="onMouseMove"
        @mouseup="onMouseUp"
        @wheel="onWheel"
      />
      
      <!-- æ¸¸æ ‡å’Œæµ‹é‡ -->
      <div class="chart-cursors" v-if="cursorsVisible">
        <div 
          v-for="cursor in cursors" 
          :key="cursor.id"
          class="cursor"
          :style="{ left: cursor.x + 'px' }"
        >
          <div class="cursor-line"></div>
          <div class="cursor-label">{{ cursor.label }}</div>
        </div>
      </div>
    </div>
    
    <!-- æ—¶é—´è½´ -->
    <div class="chart-timeaxis" ref="timeAxis">
      <canvas ref="timeAxisCanvas" :width="canvasWidth" :height="30" />
    </div>
    
    <!-- é€šé“åˆ—è¡¨ -->
    <div class="chart-channels">
      <div 
        v-for="channel in channels" 
        :key="channel.id"
        class="channel-item"
        :class="{ active: channel.visible }"
      >
        <el-checkbox 
          v-model="channel.visible"
          @change="onChannelVisibilityChange(channel)"
        />
        <div 
          class="channel-color"
          :style="{ backgroundColor: channel.color }"
          @click="showColorPicker(channel)"
        />
        <span class="channel-name">{{ channel.name }}</span>
        <span class="channel-value">{{ channel.currentValue }}</span>
        <span class="channel-unit">{{ channel.unit }}</span>
      </div>
    </div>
    
    <!-- çŠ¶æ€æ  -->
    <div class="chart-statusbar">
      <span>æ•°æ®ç‡: {{ dataRate }} Hz</span>
      <span>ç¼“å†²åŒº: {{ bufferUsage }}%</span>
      <span>æ¸²æŸ“: {{ renderFps }} fps</span>
      <span>å†…å­˜: {{ memoryUsage }} MB</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, computed } from 'vue'
import { StripChartDataManager } from './dataManager'
import { StripChartRenderer } from './renderer'
import { RealtimeDataReceiver } from './dataReceiver'

// ç»„ä»¶å±æ€§
interface Props {
  deviceId?: string
  channels?: ChannelConfig[]
  realtime?: boolean
  bufferSize?: number
  maxPoints?: number
  renderMode?: 'canvas2d' | 'webgl'
}

const props = withDefaults(defineProps<Props>(), {
  realtime: true,
  bufferSize: 1000000,
  maxPoints: 10000,
  renderMode: 'webgl'
})

// å“åº”å¼æ•°æ®
const chartContainer = ref<HTMLElement>()
const chartCanvas = ref<HTMLCanvasElement>()
const timeAxisCanvas = ref<HTMLCanvasElement>()

const isRealtime = ref(props.realtime)
const timeRange = ref('1m')
const channels = ref<ChannelData[]>([])
const cursors = ref<Cursor[]>([])
const cursorsVisible = ref(false)

// æ€§èƒ½ç›‘æ§
const dataRate = ref(0)
const bufferUsage = ref(0)
const renderFps = ref(0)
const memoryUsage = ref(0)

// æ ¸å¿ƒå®ä¾‹
let dataManager: StripChartDataManager
let renderer: StripChartRenderer
let dataReceiver: RealtimeDataReceiver

// ç»„ä»¶ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  initializeChart()
  startPerformanceMonitoring()
})

onUnmounted(() => {
  cleanup()
})

// åˆå§‹åŒ–å›¾è¡¨
const initializeChart = () => {
  dataManager = new StripChartDataManager({
    bufferSize: props.bufferSize,
    maxChannels: 32
  })
  
  renderer = new StripChartRenderer(chartCanvas.value!, {
    renderMode: props.renderMode,
    maxPoints: props.maxPoints
  })
  
  if (props.deviceId && isRealtime.value) {
    dataReceiver = new RealtimeDataReceiver(`ws://api/devices/${props.deviceId}/stream`)
    dataReceiver.onData = (data) => {
      dataManager.addData(data)
      requestAnimationFrame(renderChart)
    }
  }
  
  // åˆå§‹æ¸²æŸ“
  renderChart()
}

// æ¸²æŸ“å›¾è¡¨
const renderChart = () => {
  const visibleData = dataManager.getVisibleData()
  renderer.render(visibleData, {
    viewport: getCurrentViewport(),
    channels: channels.value
  })
}

// æ€§èƒ½ç›‘æ§
const startPerformanceMonitoring = () => {
  setInterval(() => {
    dataRate.value = dataManager.getDataRate()
    bufferUsage.value = dataManager.getBufferUsage()
    renderFps.value = renderer.getFPS()
    memoryUsage.value = getMemoryUsage()
  }, 1000)
}
</script>

<style scoped>
.strip-chart {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: #fff;
  border: 1px solid #ddd;
}

.chart-toolbar {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 12px;
  border-bottom: 1px solid #eee;
  background: #fafafa;
}

.chart-main {
  flex: 1;
  position: relative;
  overflow: hidden;
}

.chart-main canvas {
  display: block;
  cursor: crosshair;
}

.chart-cursors {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
}

.cursor {
  position: absolute;
  top: 0;
  bottom: 0;
}

.cursor-line {
  width: 1px;
  height: 100%;
  background: #ff6b6b;
  opacity: 0.8;
}

.cursor-label {
  position: absolute;
  top: 4px;
  left: 4px;
  background: rgba(255, 107, 107, 0.9);
  color: white;
  padding: 2px 6px;
  border-radius: 3px;
  font-size: 12px;
}

.chart-timeaxis {
  border-top: 1px solid #eee;
}

.chart-channels {
  width: 200px;
  border-left: 1px solid #eee;
  background: #fafafa;
  overflow-y: auto;
}

.channel-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  border-bottom: 1px solid #eee;
  font-size: 12px;
}

.channel-item.active {
  background: #f0f9ff;
}

.channel-color {
  width: 12px;
  height: 12px;
  border-radius: 2px;
  cursor: pointer;
}

.channel-name {
  flex: 1;
  font-weight: 500;
}

.channel-value {
  font-family: 'Courier New', monospace;
  color: #333;
}

.channel-unit {
  color: #666;
  font-size: 11px;
}

.chart-statusbar {
  display: flex;
  gap: 16px;
  padding: 4px 12px;
  border-top: 1px solid #eee;
  background: #fafafa;
  font-size: 11px;
  color: #666;
}
</style>
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. æ¸²æŸ“ä¼˜åŒ–
- **è§†å£è£å‰ª**: åªæ¸²æŸ“å¯è§åŒºåŸŸçš„æ•°æ®ç‚¹
- **LOD (Level of Detail)**: æ ¹æ®ç¼©æ”¾çº§åˆ«è°ƒæ•´æ¸²æŸ“ç²¾åº¦
- **æ‰¹é‡æ¸²æŸ“**: åˆå¹¶å¤šä¸ªé€šé“çš„æ¸²æŸ“è°ƒç”¨
- **å¸§ç‡æ§åˆ¶**: æ™ºèƒ½å¸§ç‡æ§åˆ¶ï¼Œé¿å…è¿‡åº¦æ¸²æŸ“

### 2. å†…å­˜ä¼˜åŒ–
- **å¯¹è±¡æ± **: é‡ç”¨æ•°æ®ç‚¹å¯¹è±¡ï¼Œå‡å°‘GCå‹åŠ›
- **å»¶è¿ŸåŠ è½½**: æŒ‰éœ€åŠ è½½å†å²æ•°æ®
- **å†…å­˜ç›‘æ§**: å®æ—¶ç›‘æ§å†…å­˜ä½¿ç”¨ï¼ŒåŠæ—¶æ¸…ç†
- **æ•°æ®åˆ†ç‰‡**: å¤§æ•°æ®é›†åˆ†ç‰‡å¤„ç†

### 3. ç½‘ç»œä¼˜åŒ–
- **æ•°æ®å‹ç¼©**: WebSocketæ•°æ®å‹ç¼©ä¼ è¾“
- **å¢é‡æ›´æ–°**: åªä¼ è¾“å˜åŒ–çš„æ•°æ®
- **è¿æ¥å¤ç”¨**: å¤šé€šé“å…±äº«WebSocketè¿æ¥
- **æ–­çº¿é‡è¿**: æ™ºèƒ½é‡è¿æœºåˆ¶

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•
```typescript
describe('StripChart DataManager', () => {
  let dataManager: StripChartDataManager
  
  beforeEach(() => {
    dataManager = new StripChartDataManager({ bufferSize: 1000 })
  })
  
  test('should handle high-frequency data', () => {
    const testData = generateTestData(10000, 1000) // 1kHz, 10s
    
    testData.forEach(point => {
      dataManager.addData(0, [point.value], point.timestamp)
    })
    
    expect(dataManager.getDataCount(0)).toBe(1000) // ç¼“å†²åŒºé™åˆ¶
    expect(dataManager.getDataRate()).toBeCloseTo(1000, 1)
  })
  
  test('should compress data correctly', () => {
    const originalData = generateTestData(10000, 1000)
    const compressed = dataManager.getCompressedData(0, 1000)
    
    expect(compressed.length).toBeLessThanOrEqual(1000)
    expect(calculateCompressionQuality(originalData, compressed)).toBeGreaterThan(0.95)
  })
})
```

### æ€§èƒ½æµ‹è¯•
```typescript
describe('StripChart Performance', () => {
  test('should handle 1GS/s data rate', async () => {
    const chart = new StripChart({
      bufferSize: 10000000,
      maxPoints: 100000,
      renderMode: 'webgl'
