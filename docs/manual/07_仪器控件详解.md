# 🔬 SeeSharpTools Web 仪器控件详解

## 📋 控件概述

SeeSharpTools Web的仪器控件是专为虚拟仪器应用设计的高级控件集合，完全模拟真实硬件仪器的操作界面和功能特性。这些控件不仅提供了专业的用户界面，还集成了完整的信号处理算法和测量功能，是构建专业测控系统的核心组件。

### 🎯 核心特性
- **真实仪器模拟**：完全模拟硬件仪器的操作体验
- **专业测量算法**：集成业界标准的测量和分析算法
- **高性能数据处理**：支持高速数据采集和实时处理
- **灵活的硬件接口**：支持多种硬件设备的无缝集成

## 🏗️ 仪器控件体系

### 控件分类架构
```
仪器控件系统
├── 信号分析类
│   ├── Oscilloscope (数字示波器)
│   ├── SpectrumAnalyzer (频谱分析仪)
│   └── WaveformAnalyzer (波形分析仪)
├── 信号生成类
│   ├── SignalGenerator (信号发生器)
│   ├── FunctionGenerator (函数发生器)
│   └── ArbitraryWaveformGenerator (任意波形发生器)
├── 测量仪表类
│   ├── DigitalMultimeter (数字万用表)
│   ├── PowerMeter (功率计)
│   └── FrequencyCounter (频率计)
├── 数据采集类
│   ├── DataAcquisitionCard (数据采集卡)
│   ├── TemperatureAcquisitionCard (温度采集卡)
│   └── DIOCard (数字I/O卡)
└── 电源控制类
    ├── PowerSupply (可编程电源)
    ├── ElectronicLoad (电子负载)
    └── BatterySimulator (电池模拟器)
```

### 核心接口定义
```typescript
// 仪器基础接口
interface InstrumentBase {
  id: string                    // 仪器唯一标识
  name: string                  // 仪器名称
  model: string                 // 型号
  connected: boolean            // 连接状态
  enabled: boolean              // 启用状态
  lastError?: string           // 最后错误信息
}

// 测量配置接口
interface MeasurementConfig {
  id: string                    // 测量ID
  name: string                  // 测量名称
  type: string                  // 测量类型
  channel?: number             // 通道号
  enabled: boolean             // 是否启用
  unit: string                 // 单位
  precision: number            // 精度
  range?: [number, number]     // 测量范围
}

// 数据采集接口
interface AcquisitionConfig {
  sampleRate: number           // 采样率
  bufferSize: number           // 缓冲区大小
  triggerMode: string          // 触发模式
  triggerLevel?: number        // 触发电平
  channels: ChannelConfig[]    // 通道配置
}

// 通道配置接口
interface ChannelConfig {
  index: number                // 通道索引
  enabled: boolean             // 是否启用
  name: string                 // 通道名称
  range: number                // 量程
  coupling: string             // 耦合方式
  offset: number               // 偏移
  unit: string                 // 单位
}
```

## 🔬 Oscilloscope 数字示波器详解

### 控件架构

#### 功能模块组成
```
数字示波器
├── 显示系统
│   ├── 波形显示区域
│   ├── 测量结果显示
│   ├── 状态信息显示
│   └── 游标测量显示
├── 时基系统
│   ├── 时间/格设置
│   ├── 水平位置控制
│   ├── 采样率配置
│   └── 显示模式选择
├── 垂直系统
│   ├── 电压/格设置
│   ├── 垂直位置控制
│   ├── 耦合方式选择
│   └── 带宽限制设置
├── 触发系统
│   ├── 触发源选择
│   ├── 触发类型设置
│   ├── 触发电平控制
│   └── 触发模式配置
├── 测量系统
│   ├── 自动测量功能
│   ├── 游标测量工具
│   ├── 统计分析功能
│   └── 数学运算功能
└── 采集系统
    ├── 采集模式选择
    ├── 内存深度设置
    ├── 数据缓冲管理
    └── 性能监控
```

#### 核心属性配置
```typescript
interface OscilloscopeProps {
  width?: number                // 控件宽度
  height?: number               // 控件高度
  channels?: number             // 通道数量
  maxSampleRate?: number        // 最大采样率
  memoryDepth?: number          // 内存深度
  bandwidthLimit?: number       // 带宽限制
  triggerTypes?: string[]       // 支持的触发类型
  measurementTypes?: string[]   // 支持的测量类型
}
```

### 时基系统详解

#### 时基控制实现
```typescript
class TimebaseController {
  private scale: number = 0.001  // 时间/格 (秒)
  private position: number = 0   // 水平位置 (%)
  private mode: 'normal' | 'roll' | 'xy' = 'normal'
  
  // 时基刻度配置
  private readonly scales = [
    { label: '1ns/div', value: 1e-9 },
    { label: '2ns/div', value: 2e-9 },
    { label: '5ns/div', value: 5e-9 },
    { label: '10ns/div', value: 1e-8 },
    { label: '20ns/div', value: 2e-8 },
    { label: '50ns/div', value: 5e-8 },
    { label: '100ns/div', value: 1e-7 },
    { label: '200ns/div', value: 2e-7 },
    { label: '500ns/div', value: 5e-7 },
    { label: '1μs/div', value: 1e-6 },
    { label: '2μs/div', value: 2e-6 },
    { label: '5μs/div', value: 5e-6 },
    { label: '10μs/div', value: 1e-5 },
    { label: '20μs/div', value: 2e-5 },
    { label: '50μs/div', value: 5e-5 },
    { label: '100μs/div', value: 1e-4 },
    { label: '200μs/div', value: 2e-4 },
    { label: '500μs/div', value: 5e-4 },
    { label: '1ms/div', value: 1e-3 },
    { label: '2ms/div', value: 2e-3 },
    { label: '5ms/div', value: 5e-3 },
    { label: '10ms/div', value: 1e-2 },
    { label: '20ms/div', value: 2e-2 },
    { label: '50ms/div', value: 5e-2 },
    { label: '100ms/div', value: 1e-1 },
    { label: '200ms/div', value: 2e-1 },
    { label: '500ms/div', value: 5e-1 },
    { label: '1s/div', value: 1 },
    { label: '2s/div', value: 2 },
    { label: '5s/div', value: 5 },
    { label: '10s/div', value: 10 }
  ]
  
  // 设置时基
  setScale(scale: number): void {
    this.scale = scale
    this.updateSampleRate()
    this.updateDisplayWindow()
  }
  
  // 设置水平位置
  setPosition(position: number): void {
    this.position = Math.max(-50, Math.min(50, position))
    this.updateDisplayWindow()
  }
  
  // 设置显示模式
  setMode(mode: 'normal' | 'roll' | 'xy'): void {
    this.mode = mode
    this.configureDisplayMode()
  }
  
  // 计算采样率
  private updateSampleRate(): void {
    const pointsPerDiv = 100
    const totalDivs = 10
    const totalTime = this.scale * totalDivs
    const requiredSampleRate = (pointsPerDiv * totalDivs) / totalTime
    
    // 选择合适的采样率
    const availableRates = [1e6, 10e6, 100e6, 1e9, 10e9]
    const selectedRate = availableRates.find(rate => rate >= requiredSampleRate * 2) || availableRates[0]
    
    this.emit('sampleRateChange', selectedRate)
  }
  
  // 更新显示窗口
  private updateDisplayWindow(): void {
    const totalTime = this.scale * 10
    const startTime = -totalTime * (this.position / 100)
    
    this.emit('displayWindowChange', {
      startTime,
      duration: totalTime,
      scale: this.scale
    })
  }
  
  // 配置显示模式
  private configureDisplayMode(): void {
    switch (this.mode) {
      case 'normal':
        this.configureNormalMode()
        break
      case 'roll':
        this.configureRollMode()
        break
      case 'xy':
        this.configureXYMode()
        break
    }
  }
  
  private configureNormalMode(): void {
    // 正常模式：触发后显示完整波形
    this.emit('displayModeChange', {
      mode: 'normal',
      triggerRequired: true,
      continuousUpdate: false
    })
  }
  
  private configureRollMode(): void {
    // 滚动模式：连续滚动显示，适用于低频信号
    this.emit('displayModeChange', {
      mode: 'roll',
      triggerRequired: false,
      continuousUpdate: true,
      scrollSpeed: this.scale
    })
  }
  
  private configureXYMode(): void {
    // XY模式：CH1作为X轴，CH2作为Y轴
    this.emit('displayModeChange', {
      mode: 'xy',
      triggerRequired: false,
      continuousUpdate: true,
      xChannel: 0,
      yChannel: 1
    })
  }
}
```

### 垂直系统详解

#### 通道控制实现
```typescript
class ChannelController {
  private channels: ChannelConfig[] = []
  
  // 电压刻度配置
  private readonly voltageScales = [
    { label: '1mV/div', value: 0.001 },
    { label: '2mV/div', value: 0.002 },
    { label: '5mV/div', value: 0.005 },
    { label: '10mV/div', value: 0.01 },
    { label: '20mV/div', value: 0.02 },
    { label: '50mV/div', value: 0.05 },
    { label: '100mV/div', value: 0.1 },
    { label: '200mV/div', value: 0.2 },
    { label: '500mV/div', value: 0.5 },
    { label: '1V/div', value: 1 },
    { label: '2V/div', value: 2 },
    { label: '5V/div', value: 5 },
    { label: '10V/div', value: 10 }
  ]
  
  constructor(channelCount: number = 4) {
    this.initializeChannels(channelCount)
  }
  
  // 初始化通道
  private initializeChannels(count: number): void {
    const colors = ['#FFD700', '#00CED1', '#FF69B4', '#32CD32']
    
    for (let i = 0; i < count; i++) {
      this.channels.push({
        index: i,
        enabled: i < 2, // 默认启用前两个通道
        name: `CH${i + 1}`,
        range: 1, // 1V/div
        coupling: 'DC',
        offset: 0,
        unit: 'V',
        color: colors[i % colors.length],
        bandwidth: 0, // 全带宽
        probe: 1, // 1x探头
        invert: false
      })
    }
  }
  
  // 设置通道参数
  setChannelConfig(index: number, config: Partial<ChannelConfig>): void {
    if (index >= 0 && index < this.channels.length) {
      Object.assign(this.channels[index], config)
      this.updateChannelSettings(index)
    }
  }
  
  // 启用/禁用通道
  enableChannel(index: number, enabled: boolean): void {
    if (index >= 0 && index < this.channels.length) {
      this.channels[index].enabled = enabled
      this.emit('channelStateChange', { index, enabled })
    }
  }
  
  // 设置电压刻度
  setVoltageScale(index: number, scale: number): void {
    if (index >= 0 && index < this.channels.length) {
      this.channels[index].range = scale
      this.updateChannelRange(index)
    }
  }
  
  // 设置垂直位置
  setVerticalPosition(index: number, position: number): void {
    if (index >= 0 && index < this.channels.length) {
      // 位置以格为单位，范围通常是-4到+4格
      this.channels[index].offset = Math.max(-4, Math.min(4, position)) * this.channels[index].range
      this.updateChannelOffset(index)
    }
  }
  
  // 设置耦合方式
  setCoupling(index: number, coupling: 'DC' | 'AC' | 'GND'): void {
    if (index >= 0 && index < this.channels.length) {
      this.channels[index].coupling = coupling
      this.updateChannelCoupling(index)
    }
  }
  
  // 设置带宽限制
  setBandwidthLimit(index: number, bandwidth: number): void {
    if (index >= 0 && index < this.channels.length) {
      this.channels[index].bandwidth = bandwidth
      this.updateChannelBandwidth(index)
    }
  }
  
  // 更新通道设置
  private updateChannelSettings(index: number): void {
    const channel = this.channels[index]
    
    this.emit('channelConfigChange', {
      index,
      config: channel
    })
  }
  
  // 更新通道量程
  private updateChannelRange(index: number): void {
    const channel = this.channels[index]
    
    // 计算ADC量程
    const adcRange = channel.range * 8 * channel.probe // 8格 × 探头倍数
    
    this.emit('channelRangeChange', {
      index,
      range: adcRange,
      scale: channel.range
    })
  }
  
  // 更新通道偏移
  private updateChannelOffset(index: number): void {
    const channel = this.channels[index]
    
    this.emit('channelOffsetChange', {
      index,
      offset: channel.offset
    })
  }
  
  // 更新通道耦合
  private updateChannelCoupling(index: number): void {
    const channel = this.channels[index]
    
    this.emit('channelCouplingChange', {
      index,
      coupling: channel.coupling
    })
  }
  
  // 更新通道带宽
  private updateChannelBandwidth(index: number): void {
    const channel = this.channels[index]
    
    this.emit('channelBandwidthChange', {
      index,
      bandwidth: channel.bandwidth
    })
  }
  
  // 获取启用的通道
  getEnabledChannels(): ChannelConfig[] {
    return this.channels.filter(ch => ch.enabled)
  }
  
  // 获取通道配置
  getChannelConfig(index: number): ChannelConfig | null {
    return index >= 0 && index < this.channels.length ? this.channels[index] : null
  }
}
```

### 触发系统详解

#### 触发控制实现
```typescript
class TriggerController {
  private config: TriggerConfig = {
    source: 0,
    type: 'edge',
    slope: 'rising',
    level: 0,
    mode: 'auto',
    holdoff: 0
  }
  
  private triggerState: 'waiting' | 'triggered' | 'stopped' = 'stopped'
  private lastTriggerTime: number = 0
  
  // 设置触发源
  setTriggerSource(source: number | 'external'): void {
    this.config.source = source
    this.updateTriggerConfig()
  }
  
  // 设置触发类型
  setTriggerType(type: 'edge' | 'pulse' | 'video' | 'pattern'): void {
    this.config.type = type
    this.updateTriggerConfig()
  }
  
  // 设置触发斜率
  setTriggerSlope(slope: 'rising' | 'falling' | 'both'): void {
    this.config.slope = slope
    this.updateTriggerConfig()
  }
  
  // 设置触发电平
  setTriggerLevel(level: number): void {
    this.config.level = level
    this.updateTriggerConfig()
  }
  
  // 设置触发模式
  setTriggerMode(mode: 'auto' | 'normal' | 'single'): void {
    this.config.mode = mode
    this.updateTriggerState()
  }
  
  // 检测触发条件
  checkTrigger(data: number[], timestamp: number): boolean {
    if (this.triggerState !== 'waiting') {
      return false
    }
    
    // 检查触发释抑时间
    if (timestamp - this.lastTriggerTime < this.config.holdoff * 1000) {
      return false
    }
    
    let triggered = false
    
    switch (this.config.type) {
      case 'edge':
        triggered = this.checkEdgeTrigger(data)
        break
      case 'pulse':
        triggered = this.checkPulseTrigger(data)
        break
      case 'video':
        triggered = this.checkVideoTrigger(data)
        break
      case 'pattern':
        triggered = this.checkPatternTrigger(data)
        break
    }
    
    if (triggered) {
      this.onTriggerDetected(timestamp)
    }
    
    return triggered
  }
  
  // 边沿触发检测
  private checkEdgeTrigger(data: number[]): boolean {
    if (data.length < 2) return false
    
    const level = this.config.level
    
    for (let i = 1; i < data.length; i++) {
      const prev = data[i - 1]
      const curr = data[i]
      
      switch (this.config.slope) {
        case 'rising':
          if (prev < level && curr >= level) return true
          break
        case 'falling':
          if (prev > level && curr <= level) return true
          break
        case 'both':
          if ((prev < level && curr >= level) || (prev > level && curr <= level)) return true
          break
      }
    }
    
    return false
  }
  
  // 脉宽触发检测
  private checkPulseTrigger(data: number[]): boolean {
    // 实现脉宽触发逻辑
    const level = this.config.level
    let pulseStart = -1
    let pulseWidth = 0
    
    for (let i = 0; i < data.length; i++) {
      if (data[i] > level && pulseStart === -1) {
        pulseStart = i
      } else if (data[i] <= level && pulseStart !== -1) {
        pulseWidth = i - pulseStart
        // 检查脉宽是否满足条件
        if (this.isPulseWidthValid(pulseWidth)) {
          return true
        }
        pulseStart = -1
      }
    }
    
    return false
  }
  
  // 视频触发检测
  private checkVideoTrigger(data: number[]): boolean {
    // 实现视频信号触发逻辑
    // 检测视频同步信号
    return this.detectVideoSync(data)
  }
  
  // 模式触发检测
  private checkPatternTrigger(data: number[]): boolean {
    // 实现数字模式触发逻辑
    // 检测特定的数字模式
    return this.detectDigitalPattern(data)
  }
  
  // 触发检测回调
  private onTriggerDetected(timestamp: number): void {
    this.triggerState = 'triggered'
    this.lastTriggerTime = timestamp
    
    this.emit('triggerDetected', {
      timestamp,
      config: this.config
    })
    
    // 根据触发模式决定下一步动作
    if (this.config.mode === 'single') {
      this.triggerState = 'stopped'
    } else {
      // 自动或正常模式，准备下次触发
      setTimeout(() => {
        if (this.config.mode === 'auto' || this.config.mode === 'normal') {
          this.triggerState = 'waiting'
        }
      }, 100)
    }
  }
  
  // 强制触发
  forceTrigger(): void {
    this.onTriggerDetected(Date.now())
  }
  
  // 启动触发
  startTrigger(): void {
    this.triggerState = 'waiting'
    this.emit('triggerStateChange', this.triggerState)
  }
  
  // 停止触发
  stopTrigger(): void {
    this.triggerState = 'stopped'
    this.emit('triggerStateChange', this.triggerState)
  }
  
  // 更新触发配置
  private updateTriggerConfig(): void {
    this.emit('triggerConfigChange', this.config)
  }
  
  // 更新触发状态
  private updateTriggerState(): void {
    if (this.config.mode === 'auto') {
      this.triggerState = 'waiting'
    }
    this.emit('triggerStateChange', this.triggerState)
  }
  
  // 辅助方法
  private isPulseWidthValid(width: number): boolean {
    // 检查脉宽是否在设定范围内
    return width > 0 // 简化实现
  }
  
  private detectVideoSync(data: number[]): boolean {
    // 视频同步检测实现
    return false // 简化实现
  }
  
  private detectDigitalPattern(data: number[]): boolean {
    // 数字模式检测实现
    return false // 简化实现
  }
}
```

### 测量系统详解

#### 自动测量实现
```typescript
class MeasurementEngine {
  private measurements: Map<string, MeasurementConfig> = new Map()
  private results: Map<string, number> = new Map()
  
  // 支持的测量类型
  private readonly measurementTypes = [
    { type: 'frequency', name: '频率', unit: 'Hz' },
    { type: 'period', name: '周期', unit: 's' },
    { type: 'amplitude', name: '幅度', unit: 'V' },
    { type: 'peak-peak', name: '峰峰值', unit: 'V' },
    { type: 'rms', name: 'RMS', unit: 'V' },
    { type: 'mean', name: '平均值', unit: 'V' },
    { type: 'max', name: '最大值', unit: 'V' },
    { type: 'min', name: '最小值', unit: 'V' },
    { type: 'rise-time', name: '上升时间', unit: 's' },
    { type: 'fall-time', name: '下降时间', unit: 's' },
    { type: 'duty-cycle', name: '占空比', unit: '%' },
    { type: 'overshoot', name: '过冲', unit: '%' },
    { type: 'undershoot', name: '下冲', unit: '%' },
    { type: 'preshoot', name: '预冲', unit: '%' }
  ]
  
  // 添加测量
  addMeasurement(type: string, channel: number): string {
    const id = `${type}_ch${channel}_${Date.now()}`
    const measurementType = this.measurementTypes.find(m => m.type === type)
    
    if (!measurementType) {
      throw new Error(`不支持的测量类型: ${type}`)
    }
    
    const measurement: MeasurementConfig = {
      id,
      name: measurementType.name,
      type,
      channel,
      enabled: true,
      unit: measurementType.unit,
      precision: this.getDefaultPrecision(type)
    }
    
    this.measurements.set(id, measurement)
    return id
  }
  
  // 移除测量
  removeMeasurement(id: string): void {
    this.measurements.delete(id)
    this.results.delete(id)
  }
  
  // 清除所有测量
  clearMeasurements(): void {
    this.measurements.clear()
    this.results.clear()
  }
  
  // 执行测量
  performMeasurements(channelData: Map<number, number[]>): void {
    for (const [id, measurement] of this.measurements) {
      if (!measurement.enabled) continue
      
      const data = channelData.get(measurement.channel)
      if (!data || data.length === 0) continue
      
      try {
        const result = this.calculateMeasurement(measurement.type, data)
        this.results.set(id, result)
      } catch (error) {
        console.error(`测量计算错误 [${id}]:`, error)
        this.results.set(id, NaN)
      }
    }
    
    this.emit('measurementsUpdated', this.getMeasurementResults())
  }
  
  // 计算具体测量值
  private calculateMeasurement(type: string, data: number[]): number {
    switch (type) {
      case 'frequency':
        return this.calculateFrequency(data)
      case 'period':
        return 1 / this.calculateFrequency(data)
      case 'amplitude':
        return this.calculateAmplitude(data)
      case 'peak-peak':
        return Math.max(...data) - Math.min(...data)
      case 'rms':
        return this.calculateRMS(data)
      case 'mean':
        return data.reduce((sum, val) => sum + val, 0) / data.length
      case 'max':
        return Math.max(...data)
      case 'min':
        return Math.min(...data)
      case 'rise-time':
        return this.calculateRiseTime(data)
      case 'fall-time':
        return this.calculateFallTime(data)
      case 'duty-cycle':
        return this.calculateDutyCycle(data)
      case 'overshoot':
        return this.calculateOvershoot(data)
      case 'undershoot':
        return this.calculateUndershoot(data)
      case 'preshoot':
        return this.calculatePreshoot(data)
      default:
        throw new Error(`未实现的测量类型: ${type}`)
    }
  }
  
  // 频率计算
  private calculateFrequency(data: number[]): number {
    const crossings = this.findZeroCrossings(data)
    if (crossings.length < 2) return 0
    
    // 计算平均周期
    const periods: number[] = []
    for (let i = 2; i < crossings.length; i += 2) {
      periods.push(crossings[i] - crossings[i - 2])
    }
    
    if (periods.length === 0) return 0
    
    const avgPeriod = periods.reduce((sum, p) => sum + p, 0) / periods.length
    const sampleRate = this.getSampleRate()
    
    return sampleRate / (avgPeriod * 2) // 每个周期有2个零点交叉
  }
  
  // 幅度计算
  private calculateAmplitude(data: number[]): number {
    const max = Math.max(...data)
    const min = Math.min(...data)
    return (max - min) / 2
  }
  
  // RMS计算
  private calculateRMS(data: number[]): number {
    const sumSquares = data.reduce((sum, val) => sum + val * val, 0)
    return Math.sqrt(sumSquares / data.length)
  }
  
  // 上升时间计算 (10%-90%)
  private calculateRiseTime(data: number[]): number {
    const max = Math.max(...data)
    const min = Math.min(...data)
    const level10 = min + (max - min) * 0.1
    const level90 = min + (max - min) * 0.9
    
    let start = -1, end = -1
    for (let i = 0; i < data.length; i++) {
      if (start === -1 && data[i] >= level10) start = i
      if (start !== -1 && data[i] >= level90) {
        end = i
        break
      }
    }
    
    if (start === -1 || end === -1) return 0
    const sampleRate = this.getSampleRate()
    return (end - start) / sampleRate
  }
  
  // 下降时间计算 (90%-10%)
  private calculateFallTime(data: number[]): number {
    const max = Math.max(...data)
    const min = Math.min(...data)
    const level90 = min + (max - min) * 0.9
    const level10 = min + (max - min) * 0.1
    
    let start = -1, end = -1
    for (let i = 0; i < data.length; i++) {
      if (start === -1 && data[i] <= level90) start = i
      if (start !== -1 && data[i] <= level10) {
        end = i
        break
      }
    }
    
    if (start === -1 || end === -1) return 0
    const sampleRate = this.getSampleRate()
    return (end - start) / sampleRate
  }
  
  // 占空比计算
  private calculateDutyCycle(data: number[]): number {
    const threshold = (Math.max(...data) + Math.min(...data)) / 2
    let highCount = 0
    for (const value of data) {
      if (value > threshold) highCount++
    }
    return (highCount / data.length) * 100
  }
  
  // 过冲计算
  private calculateOvershoot(data: number[]): number {
    const max = Math.max(...data)
    const steadyState = this.calculateSteadyStateValue(data)
    return ((max - steadyState) / steadyState) * 100
  }
  
  // 下冲计算
  private calculateUndershoot(data: number[]): number {
    const min = Math.min(...data)
    const steadyState = this.calculateSteadyStateValue(data)
    return ((steadyState - min) / steadyState) * 100
  }
  
  // 预冲计算
  private calculatePreshoot(data: number[]): number {
    // 简化实现，实际需要更复杂的算法
    return 0
  }
  
  // 辅助方法
  private findZeroCrossings(data: number[]): number[] {
    const crossings: number[] = []
    for (let i = 1; i < data.length; i++) {
      if ((data[i] >= 0 && data[i - 1] < 0) || (data[i] < 0 && data[i - 1] >= 0)) {
        crossings.push(i)
      }
    }
    return crossings
  }
  
  private calculateSteadyStateValue(data: number[]): number {
    // 取最后10%的数据计算稳态值
    const startIndex = Math.floor(data.length * 0.9)
    const steadyData = data.slice(startIndex)
    return steadyData.reduce((sum, val) => sum + val, 0) / steadyData.length
  }
  
  private getSampleRate(): number {
    // 从全局配置获取采样率
    return 100000000 // 100MS/s 默认值
  }
  
  private getDefaultPrecision(type: string): number {
    const precisionMap: Record<string, number> = {
      'frequency': 3,
      'period': 6,
      'amplitude': 3,
      'peak-peak': 3,
      'rms': 3,
      'mean': 3,
      'max': 3,
      'min': 3,
      'rise-time': 6,
      'fall-time': 6,
      'duty-cycle': 1,
      'overshoot': 1,
      'undershoot': 1,
      'preshoot': 1
    }
    return precisionMap[type] || 3
  }
  
  // 获取测量结果
  getMeasurementResults(): Array<{ id: string; config: MeasurementConfig; value: number }> {
    const results: Array<{ id: string; config: MeasurementConfig; value: number }> = []
    
    for (const [id, measurement] of this.measurements) {
      const value = this.results.get(id) || 0
      results.push({ id, config: measurement, value })
    }
    
    return results
  }
}
```

## 📡 SignalGenerator 信号发生器详解

### 控件架构

#### 功能模块组成
```
信号发生器
├── 波形生成系统
│   ├── 基础波形生成
│   ├── 任意波形生成
│   ├── 调制波形生成
│   └── 噪声信号生成
├── 参数控制系统
│   ├── 频率控制
│   ├── 幅度控制
│   ├── 相位控制
│   └── 偏置控制
├── 调制系统
│   ├── 幅度调制 (AM)
│   ├── 频率调制 (FM)
│   ├── 相位调制 (PM)
│   └── 脉宽调制 (PWM)
├── 扫频系统
│   ├── 线性扫频
│   ├── 对数扫频
│   ├── 步进扫频
│   └── 列表扫频
├── 输出控制系统
│   ├── 输出开关控制
│   ├── 负载匹配
│   ├── 同步输出
│   └── 保护功能
└── 预设管理系统
    ├── 内置预设
    ├── 用户预设
    ├── 预设导入导出
    └── 快速加载
```

#### 核心属性配置
```typescript
interface SignalGeneratorProps {
  width?: number                // 控件宽度
  height?: number               // 控件高度
  maxFrequency?: number         // 最大频率
  maxAmplitude?: number         // 最大幅度
  waveformTypes?: string[]      // 支持的波形类型
  modulationTypes?: string[]    // 支持的调制类型
  outputChannels?: number       // 输出通道数
}
```

### 波形生成引擎详解

#### 基础波形生成器
```typescript
class WaveformGenerator {
  private sampleRate: number = 1000000 // 1MS/s
  private bufferSize: number = 1024
  
  // 生成正弦波
  generateSineWave(config: WaveformConfig): number[] {
    const { frequency, amplitude, phase, offset, samples } = config
    const data: number[] = []
    const omega = 2 * Math.PI * frequency / this.sampleRate
    const phaseRad = (phase * Math.PI) / 180
    
    for (let i = 0; i < samples; i++) {
      const value = amplitude * Math.sin(omega * i + phaseRad) + offset
      data.push(value)
    }
    
    return data
  }
  
  // 生成方波
  generateSquareWave(config: WaveformConfig & { dutyCycle: number }): number[] {
    const { frequency, amplitude, phase, offset, samples, dutyCycle } = config
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    
    for (let i = 0; i < samples; i++) {
      const adjustedIndex = (i + phaseOffset) % period
      const isHigh = adjustedIndex < (period * dutyCycle / 100)
      const value = (isHigh ? amplitude : -amplitude) + offset
      data.push(value)
    }
    
    return data
  }
  
  // 生成三角波
  generateTriangleWave(config: WaveformConfig): number[] {
    const { frequency, amplitude, phase, offset, samples } = config
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    
    for (let i = 0; i < samples; i++) {
      const adjustedIndex = (i + phaseOffset) % period
      const progress = adjustedIndex / period
      
      let value: number
      if (progress < 0.5) {
        value = 4 * progress - 1 // 上升沿
      } else {
        value = 3 - 4 * progress // 下降沿
      }
      
      data.push(amplitude * value + offset)
    }
    
    return data
  }
  
  // 生成锯齿波
  generateSawtoothWave(config: WaveformConfig): number[] {
    const { frequency, amplitude, phase, offset, samples } = config
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    
    for (let i = 0; i < samples; i++) {
      const adjustedIndex = (i + phaseOffset) % period
      const progress = adjustedIndex / period
      const value = 2 * progress - 1
      data.push(amplitude * value + offset)
    }
    
    return data
  }
  
  // 生成脉冲波
  generatePulseWave(config: WaveformConfig & { pulseWidth: number }): number[] {
    const { frequency, amplitude, phase, offset, samples, pulseWidth } = config
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    const pulseSamples = (pulseWidth / 1000000) * this.sampleRate // 脉宽转换为采样点数
    
    for (let i = 0; i < samples; i++) {
      const adjustedIndex = (i + phaseOffset) % period
      const value = adjustedIndex < pulseSamples ? amplitude : 0
      data.push(value + offset)
    }
    
    return data
  }
  
  // 生成白噪声
  generateWhiteNoise(config: WaveformConfig & { noiseLevel: number }): number[] {
    const { amplitude, offset, samples, noiseLevel } = config
    const data: number[] = []
    
    for (let i = 0; i < samples; i++) {
      const noise = (Math.random() - 0.5) * 2 * noiseLevel
      const value = amplitude * noise + offset
      data.push(value)
    }
    
    return data
  }
  
  // 生成任意波形
  generateArbitraryWaveform(points: number[], config: WaveformConfig): number[] {
    const { frequency, amplitude, phase, offset, samples } = config
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    
    for (let i = 0; i < samples; i++) {
      const adjustedIndex = (i + phaseOffset) % period
      const progress = adjustedIndex / period
      const pointIndex = progress * (points.length - 1)
      
      // 线性插值
      const lowerIndex = Math.floor(pointIndex)
      const upperIndex = Math.ceil(pointIndex)
      const fraction = pointIndex - lowerIndex
      
      const lowerValue = points[lowerIndex] || 0
      const upperValue = points[upperIndex] || 0
      const interpolatedValue = lowerValue + (upperValue - lowerValue) * fraction
      
      data.push(amplitude * interpolatedValue + offset)
    }
    
    return data
  }
}
```

### 调制系统详解

#### 调制引擎实现
```typescript
class ModulationEngine {
  // 幅度调制 (AM)
  applyAmplitudeModulation(
    carrier: number[], 
    modConfig: { frequency: number; depth: number; phase: number }
  ): number[] {
    const { frequency, depth, phase } = modConfig
    const modulated: number[] = []
    const omega = 2 * Math.PI * frequency / this.sampleRate
    const phaseRad = (phase * Math.PI) / 180
    const modDepth = depth / 100
    
    for (let i = 0; i < carrier.length; i++) {
      const modSignal = Math.sin(omega * i + phaseRad)
      const modulationFactor = 1 + modDepth * modSignal
      modulated.push(carrier[i] * modulationFactor)
    }
    
    return modulated
  }
  
  // 频率调制 (FM)
  applyFrequencyModulation(
    baseConfig: WaveformConfig,
    modConfig: { frequency: number; deviation: number; phase: number }
  ): number[] {
    const { frequency: carrierFreq, amplitude, phase: carrierPhase, offset, samples } = baseConfig
    const { frequency: modFreq, deviation, phase: modPhase } = modConfig
    
    const data: number[] = []
    const modOmega = 2 * Math.PI * modFreq / this.sampleRate
    const modPhaseRad = (modPhase * Math.PI) / 180
    const carrierPhaseRad = (carrierPhase * Math.PI) / 180
    
    let phaseAccumulator = carrierPhaseRad
    
    for (let i = 0; i < samples; i++) {
      // 计算调制信号
      const modSignal = Math.sin(modOmega * i + modPhaseRad)
      
      // 计算瞬时频率
      const instantFreq = carrierFreq + deviation * modSignal
      const instantOmega = 2 * Math.PI * instantFreq / this.sampleRate
      
      // 累积相位
      phaseAccumulator += instantOmega
      
      // 生成调制后的信号
      const value = amplitude * Math.sin(phaseAccumulator) + offset
      data.push(value)
    }
    
    return data
  }
  
  // 相位调制 (PM)
  applyPhaseModulation(
    baseConfig: WaveformConfig,
    modConfig: { frequency: number; deviation: number; phase: number }
  ): number[] {
    const { frequency, amplitude, phase: carrierPhase, offset, samples } = baseConfig
    const { frequency: modFreq, deviation, phase: modPhase } = modConfig
    
    const data: number[] = []
    const omega = 2 * Math.PI * frequency / this.sampleRate
    const modOmega = 2 * Math.PI * modFreq / this.sampleRate
    const carrierPhaseRad = (carrierPhase * Math.PI) / 180
    const modPhaseRad = (modPhase * Math.PI) / 180
    const deviationRad = (deviation * Math.PI) / 180
    
    for (let i = 0; i < samples; i++) {
      // 计算调制信号
      const modSignal = Math.sin(modOmega * i + modPhaseRad)
      
      // 计算瞬时相位
      const instantPhase = omega * i + carrierPhaseRad + deviationRad * modSignal
      
      // 生成调制后的信号
      const value = amplitude * Math.sin(instantPhase) + offset
      data.push(value)
    }
    
    return data
  }
  
  // 脉宽调制 (PWM)
  applyPulseWidthModulation(
    baseConfig: WaveformConfig & { baseDutyCycle: number },
    modConfig: { frequency: number; depth: number; phase: number }
  ): number[] {
    const { frequency, amplitude, phase, offset, samples, baseDutyCycle } = baseConfig
    const { frequency: modFreq, depth, phase: modPhase } = modConfig
    
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    const modOmega = 2 * Math.PI * modFreq / this.sampleRate
    const modPhaseRad = (modPhase * Math.PI) / 180
    const modDepth = depth / 100
    
    for (let i = 0; i < samples; i++) {
      // 计算调制信号
      const modSignal = Math.sin(modOmega * i + modPhaseRad)
      
      // 计算瞬时占空比
      const instantDutyCycle = baseDutyCycle + modDepth * modSignal * 50
      const clampedDutyCycle = Math.max(1, Math.min(99, instantDutyCycle))
      
      // 生成PWM信号
      const adjustedIndex = (i + phaseOffset) % period
      const isHigh = adjustedIndex < (period * clampedDutyCycle / 100)
      const value = (isHigh ? amplitude : -amplitude) + offset
      data.push(value)
    }
    
    return data
  }
}
```

### 扫频系统详解

#### 扫频控制器实现
```typescript
class SweepController {
  private sweepConfig: SweepConfig = {
    enabled: false,
    startFreq: 100,
    stopFreq: 10000,
    duration: 5,
    type: 'linear'
  }
  
  private sweepState: {
    active: boolean
    startTime: number
    currentFreq: number
    direction: 'up' | 'down'
  } = {
    active: false,
    startTime: 0,
    currentFreq: 0,
    direction: 'up'
  }
  
  // 启动扫频
  startSweep(): void {
    this.sweepState.active = true
    this.sweepState.startTime = Date.now()
    this.sweepState.currentFreq = this.sweepConfig.startFreq
    this.sweepState.direction = 'up'
    
    this.emit('sweepStarted', this.sweepConfig)
    this.scheduleSweepUpdate()
  }
  
  // 停止扫频
  stopSweep(): void {
    this.sweepState.active = false
    this.emit('sweepStopped')
  }
  
  // 更新扫频频率
  private scheduleSweepUpdate(): void {
    if (!this.sweepState.active) return
    
    const elapsed = Date.now() - this.sweepState.startTime
    const progress = Math.min(elapsed / (this.sweepConfig.duration * 1000), 1)
    
    let newFreq: number
    
    switch (this.sweepConfig.type) {
      case 'linear':
        newFreq = this.calculateLinearSweep(progress)
        break
      case 'logarithmic':
        newFreq = this.calculateLogarithmicSweep(progress)
        break
      default:
        newFreq = this.sweepConfig.startFreq
    }
    
    this.sweepState.currentFreq = newFreq
    this.emit('frequencyChange', newFreq)
    
    if (progress >= 1) {
      // 扫频完成，重新开始或停止
      if (this.sweepConfig.continuous) {
        this.sweepState.startTime = Date.now()
        setTimeout(() => this.scheduleSweepUpdate(), 50)
      } else {
        this.stopSweep()
      }
    } else {
      setTimeout(() => this.scheduleSweepUpdate(), 50)
    }
  }
  
  // 线性扫频计算
  private calculateLinearSweep(progress: number): number {
    const { startFreq, stopFreq } = this.sweepConfig
    return startFreq + (stopFreq - startFreq) * progress
  }
  
  // 对数扫频计算
  private calculateLogarithmicSweep(progress: number): number {
    const { startFreq, stopFreq } = this.sweepConfig
    const logStart = Math.log10(startFreq)
    const logStop = Math.log10(stopFreq)
    const logCurrent = logStart + (logStop - logStart) * progress
    return Math.pow(10, logCurrent)
  }
  
  // 步进扫频
  performStepSweep(steps: number[]): void {
    let stepIndex = 0
    
    const nextStep = () => {
      if (stepIndex < steps.length && this.sweepState.active) {
        this.sweepState.currentFreq = steps[stepIndex]
        this.emit('frequencyChange', steps[stepIndex])
        stepIndex++
        
        setTimeout(nextStep, this.sweepConfig.stepDwell || 1000)
      } else {
        this.stopSweep()
      }
    }
    
    this.sweepState.active = true
    nextStep()
  }
  
  // 列表扫频
  performListSweep(frequencyList: Array<{ freq: number; dwell: number }>): void {
    let listIndex = 0
    
    const nextFrequency = () => {
      if (listIndex < frequencyList.length && this.sweepState.active) {
        const item = frequencyList[listIndex]
        this.sweepState.currentFreq = item.freq
        this.emit('frequencyChange', item.freq)
        listIndex++
        
        setTimeout(nextFrequency, item.dwell)
      } else {
        this.stopSweep()
      }
    }
    
    this.sweepState.active = true
    nextFrequency()
  }
  
  // 获取当前频率
  getCurrentFrequency(): number {
    return this.sweepState.currentFreq
  }
  
  // 设置扫频配置
  setSweepConfig(config: Partial<SweepConfig>): void {
    Object.assign(this.sweepConfig, config)
    this.emit('sweepConfigChange', this.sweepConfig)
  }
}
```

## 🔌 DataAcquisitionCard 数据采集卡详解

### 控件架构

#### 功能模块组成
```
数据采集卡
├── 通道管理系统
│   ├── 模拟输入通道
│   ├── 数字输入通道
│   ├── 计数器通道
│   └── 通道配置管理
├── 采集控制系统
│   ├── 采样率控制
│   ├── 触发控制
│   ├── 时钟配置
│   └── 同步控制
├── 数据处理系统
│   ├── 实时数据流
│   ├── 数据缓冲管理
│   ├── 数据压缩
│   └── 数据质量检查
├── 校准系统
│   ├── 自动校准
│   ├── 手动校准
│   ├── 校准数据管理
│   └── 温度补偿
└── 诊断系统
    ├── 自检功能
    ├── 性能监控
    ├── 错误诊断
    └── 状态报告
```

#### 核心属性配置
```typescript
interface DataAcquisitionProps {
  channels: number              // 通道数量
  maxSampleRate: number         // 最大采样率
  resolution: number            // 分辨率 (位)
  inputRange: [number, number]  // 输入范围
  couplingTypes: string[]       // 耦合类型
  triggerTypes: string[]        // 触发类型
  bufferSize: number           // 缓冲区大小
}
```

### 通道管理系统详解

#### 通道控制器实现
```typescript
class ChannelManager {
  private channels: Map<number, ChannelConfig> = new Map()
  private channelGroups: Map<string, number[]> = new Map()
  
  constructor(channelCount: number) {
    this.initializeChannels(channelCount)
  }
  
  // 初始化通道
  private initializeChannels(count: number): void {
    for (let i = 0; i < count; i++) {
      const channel: ChannelConfig = {
        index: i,
        enabled: false,
        name: `AI${i}`,
        range: 10, // ±10V
        coupling: 'DC',
        offset: 0,
        unit: 'V',
        calibration: {
          gain: 1.0,
          offset: 0.0,
          lastCalibration: new Date()
        },
        filter: {
          enabled: false,
          type: 'lowpass',
          cutoff: 1000
        }
      }
      
      this.channels.set(i, channel)
    }
  }
  
  // 配置通道
  configureChannel(index: number, config: Partial<ChannelConfig>): void {
    const channel = this.channels.get(index)
    if (!channel) {
      throw new Error(`通道 ${index} 不存在`)
    }
    
    Object.assign(channel, config)
    this.validateChannelConfig(channel)
    this.applyChannelConfig(index, channel)
  }
  
  // 启用通道组
  enableChannelGroup(groupName: string, channels: number[]): void {
    this.channelGroups.set(groupName, channels)
    
    channels.forEach(index => {
      const channel = this.channels.get(index)
      if (channel) {
        channel.enabled = true
        this.applyChannelConfig(index, channel)
      }
    })
  }
  
  // 禁用通道组
  disableChannelGroup(groupName: string): void {
    const channels = this.channelGroups.get(groupName)
    if (channels) {
      channels.forEach(index => {
        const channel = this.channels.get(index)
        if (channel) {
          channel.enabled = false
          this.applyChannelConfig(index, channel)
        }
      })
    }
  }
  
  // 设置通道量程
  setChannelRange(index: number, range: number): void {
    const channel = this.channels.get(index)
    if (channel) {
      channel.range = range
      this.updateChannelGain(index, range)
    }
  }
  
  // 设置通道耦合
  setChannelCoupling(index: number, coupling: 'DC' | 'AC' | 'GND'): void {
    const channel = this.channels.get(index)
    if (channel) {
      channel.coupling = coupling
      this.updateChannelCoupling(index, coupling)
    }
  }
  
  // 校准通道
  calibrateChannel(index: number, referenceValues: number[]): void {
    const channel = this.channels.get(index)
    if (!channel) return
    
    // 执行校准算法
    const calibration = this.performCalibration(referenceValues)
    channel.calibration = {
      ...calibration,
      lastCalibration: new Date()
    }
    
    this.emit('channelCalibrated', { index, calibration })
  }
  
  // 自动校准所有通道
  async autoCalibrate(): Promise<void> {
    const enabledChannels = Array.from(this.channels.entries())
      .filter(([_, channel]) => channel.enabled)
      .map(([index, _]) => index)
    
    for (const index of enabledChannels) {
      try {
        await this.performAutoCalibration(index)
      } catch (error) {
        console.error(`通道 ${index} 自动校准失败:`, error)
      }
    }
  }
  
  // 验证通道配置
  private validateChannelConfig(channel: ChannelConfig): void {
    if (channel.range <= 0) {
      throw new Error('通道量程必须大于0')
    }
    
    if (!['DC', 'AC', 'GND'].includes(channel.coupling)) {
      throw new Error('无效的耦合类型')
    }
  }
  
  // 应用通道配置
  private applyChannelConfig(index: number, channel: ChannelConfig): void {
    this.emit('channelConfigChanged', { index, config: channel })
  }
  
  // 更新通道增益
  private updateChannelGain(index: number, range: number): void {
    // 根据量程计算增益
    const maxADCValue = Math.pow(2, 16) - 1 // 16位ADC
    const gain = maxADCValue / (2 * range) // 双极性
    
    this.emit('channelGainChanged', { index, gain })
  }
  
  // 更新通道耦合
  private updateChannelCoupling(index: number, coupling: string): void {
    this.emit('channelCouplingChanged', { index, coupling })
  }
  
  // 执行校准
  private performCalibration(referenceValues: number[]): CalibrationData {
    // 简化的线性校准算法
    // 实际应用中需要更复杂的校准算法
    
    if (referenceValues.length < 2) {
      throw new Error('校准需要至少2个参考点')
    }
    
    // 假设已有对应的测量值
    const measuredValues = referenceValues.map(ref => ref + (Math.random() - 0.5) * 0.01)
    
    // 线性回归计算增益和偏移
    const n = referenceValues.length
    const sumX = referenceValues.reduce((sum, val) => sum + val, 0)
    const sumY = measuredValues.reduce((sum, val) => sum + val, 0)
    const sumXY = referenceValues.reduce((sum, val, i) => sum + val * measuredValues[i], 0)
    const sumXX = referenceValues.reduce((sum, val) => sum + val * val, 0)
    
    const gain = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX)
    const offset = (sumY - gain * sumX) / n
    
    return { gain, offset }
  }
  
  // 执行自动校准
  private async performAutoCalibration(index: number): Promise<void> {
    // 自动校准流程
    const referencePoints = [-10, -5, 0, 5, 10] // 标准参考点
    const measuredValues: number[] = []
    
    for (const refValue of referencePoints) {
      // 应用参考电压并测量
      await this.applyReferenceVoltage(refValue)
      await this.delay(100) // 等待稳定
      const measured = await this.measureChannel(index)
      measuredValues.push(measured)
    }
    
    // 计算校准参数
    const calibration = this.performCalibration(referencePoints)
    const channel = this.channels.get(index)
    if (channel) {
      channel.calibration = {
        ...calibration,
        lastCalibration: new Date()
      }
    }
  }
  
  // 辅助方法
  private async applyReferenceVoltage(voltage: number): Promise<void> {
    // 应用参考电压的实现
    return new Promise(resolve => setTimeout(resolve, 50))
  }
  
  private async measureChannel(index: number): Promise<number> {
    // 测量通道值的实现
    return Math.random() * 20 - 10 // 模拟测量值
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}
```

## 🔧 常见问题和解决方案

### 示波器使用问题

**问题1：波形显示不稳定**
- **原因**：触发设置不当或信号噪声过大
- **解决方案**：
  ```typescript
  // 优化触发设置
  const optimizeTrigger = (signalLevel: number) => {
    const triggerLevel = signalLevel * 0.5 // 设置为信号幅度的50%
    const holdoffTime = 1 / frequency * 0.1 // 设置适当的触发释抑时间
    
    triggerController.setTriggerLevel(triggerLevel)
    triggerController.setHoldoffTime(holdoffTime)
    triggerController.setTriggerMode('normal') // 使用正常触发模式
  }
  ```

**问题2：测量结果不准确**
- **原因**：采样率不足或探头补偿不当
- **解决方案**：
  ```typescript
  // 确保采样率满足奈奎斯特定理
  const validateSampleRate = (signalFreq: number, sampleRate: number) => {
    const nyquistRate = signalFreq * 2
    if (sampleRate < nyquistRate * 10) {
      console.warn(`建议采样率至少为 ${nyquistRate * 10} Hz`)
      return false
    }
    return true
  }
  
  // 探头补偿
  const compensateProbe = (channelIndex: number, probeRatio: number) => {
    channelController.setChannelConfig(channelIndex, {
      probe: probeRatio,
      // 根据探头类型调整带宽限制
      bandwidth: probeRatio === 10 ? 100e6 : 0
    })
  }
  ```

### 信号发生器使用问题

**问题3：输出信号失真**
- **原因**：输出负载不匹配或频率过高
- **解决方案**：
  ```typescript
  // 负载匹配检查
  const checkLoadMatching = (outputImpedance: number, loadImpedance: number) => {
    const mismatchRatio = Math.abs(outputImpedance - loadImpedance) / outputImpedance
    if (mismatchRatio > 0.1) {
      console.warn('负载阻抗不匹配，可能导致信号反射')
      return false
    }
    return true
  }
  
  // 频率限制检查
  const validateFrequency = (frequency: number, maxFreq: number) => {
    if (frequency > maxFreq * 0.8) {
      console.warn('频率接近上限，可能影响信号质量')
      return false
    }
    return true
  }
  ```

**问题4：调制效果不明显**
- **原因**：调制深度设置过小或调制频率不当
- **解决方案**：
  ```typescript
  // 优化调制参数
  const optimizeModulation = (carrierFreq: number, modType: string) => {
    let optimalModFreq: number
    let optimalDepth: number
    
    switch (modType) {
      case 'AM':
        optimalModFreq = carrierFreq / 10 // 载波频率的1/10
        optimalDepth = 50 // 50%调制深度
        break
      case 'FM':
        optimalModFreq = carrierFreq / 20
        optimalDepth = carrierFreq * 0.1 // 频偏为载波频率的10%
        break
      default:
        optimalModFreq = 1000
        optimalDepth = 30
    }
    
    return { frequency: optimalModFreq, depth: optimalDepth }
  }
  ```

### 数据采集问题

**问题5：数据丢失或采集中断**
- **原因**：缓冲区溢出或系统资源不足
- **解决方案**：
  ```typescript
  // 动态缓冲区管理
  class AdaptiveBufferManager {
    private bufferSize: number = 10000
    private maxBufferSize: number = 100000
    private overflowCount: number = 0
    
    checkBufferHealth(currentUsage: number): void {
      const usageRatio = currentUsage / this.bufferSize
      
      if (usageRatio > 0.9) {
        this.overflowCount++
        if (this.overflowCount > 3 && this.bufferSize < this.maxBufferSize) {
          this.bufferSize *= 2
          console.log(`缓冲区扩展到 ${this.bufferSize}`)
        }
      } else if (usageRatio < 0.3 && this.overflowCount === 0) {
        this.bufferSize = Math.max(this.bufferSize / 2, 1000)
        console.log(`缓冲区缩减到 ${this.bufferSize}`)
      }
    }
  }
  ```

**问题6：采集精度不足**
- **原因**：量程设置不当或校准过期
- **解决方案**：
  ```typescript
  // 自动量程选择
  const autoRangeSelection = (signalLevel: number): number => {
    const ranges = [0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100]
    
    // 选择能覆盖信号且利用率最高的量程
    for (const range of ranges) {
      if (signalLevel <= range * 0.8) {
        return range
      }
    }
    
    return ranges[ranges.length - 1]
  }
  
  // 校准状态检查
  const checkCalibrationStatus = (lastCalibration: Date): boolean => {
    const now = new Date()
    const daysSinceCalibration = (now.getTime() - lastCalibration.getTime()) / (1000 * 60 * 60 * 24)
    
    if (daysSinceCalibration > 30) {
      console.warn('校准已过期，建议重新校准')
      return false
    }
    
    return true
  }
  ```

## 📚 最佳实践

### 设计原则

1. **模块化设计**：每个仪器控件都采用模块化架构，便于维护和扩展
2. **标准化接口**：统一的接口设计，确保控件间的兼容性
3. **性能优化**：针对实时数据处理进行专门优化
4. **用户体验**：提供直观的操作界面和丰富的反馈信息

### 开发建议

1. **合理选择控件**：根据应用需求选择最适合的仪器控件
2. **优化数据流**：合理设计数据采集和处理流程
3. **错误处理**：完善的错误检测和恢复机制
4. **性能监控**：实时监控系统性能，及时发现问题

### 集成指南

1. **硬件接口**：确保硬件驱动的正确安装和配置
2. **软件配置**：根据硬件特性调整软件参数
3. **系统测试**：全面测试各项功能的正确性
4. **文档维护**：保持技术文档的及时更新

## 🔮 未来发展

### 技术趋势

1. **AI集成**：集成机器学习算法，提供智能分析功能
2. **云端处理**：支持云端数据处理和存储
3. **移动端适配**：优化移动设备上的使用体验
4. **协议扩展**：支持更多的通信协议和硬件接口

### 功能扩展

1. **高级分析**：增加更多专业分析算法
2. **自动化测试**：支持自动化测试序列
3. **远程控制**：支持远程仪器控制和监控
4. **数据挖掘**：提供大数据分析和挖掘功能

---

*仪器控件是虚拟仪器系统的核心，掌握其原理和使用方法对于构建专业的测控系统至关重要。通过合理的设计和优化，可以实现与硬件仪器相媲美的性能和功能。*
