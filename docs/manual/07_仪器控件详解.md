# ğŸ”¬ SeeSharpTools Web ä»ªå™¨æ§ä»¶è¯¦è§£

## ğŸ“‹ æ§ä»¶æ¦‚è¿°

SeeSharpTools Webçš„ä»ªå™¨æ§ä»¶æ˜¯ä¸“ä¸ºè™šæ‹Ÿä»ªå™¨åº”ç”¨è®¾è®¡çš„é«˜çº§æ§ä»¶é›†åˆï¼Œå®Œå…¨æ¨¡æ‹ŸçœŸå®ç¡¬ä»¶ä»ªå™¨çš„æ“ä½œç•Œé¢å’ŒåŠŸèƒ½ç‰¹æ€§ã€‚è¿™äº›æ§ä»¶ä¸ä»…æä¾›äº†ä¸“ä¸šçš„ç”¨æˆ·ç•Œé¢ï¼Œè¿˜é›†æˆäº†å®Œæ•´çš„ä¿¡å·å¤„ç†ç®—æ³•å’Œæµ‹é‡åŠŸèƒ½ï¼Œæ˜¯æ„å»ºä¸“ä¸šæµ‹æ§ç³»ç»Ÿçš„æ ¸å¿ƒç»„ä»¶ã€‚

### ğŸ¯ æ ¸å¿ƒç‰¹æ€§
- **çœŸå®ä»ªå™¨æ¨¡æ‹Ÿ**ï¼šå®Œå…¨æ¨¡æ‹Ÿç¡¬ä»¶ä»ªå™¨çš„æ“ä½œä½“éªŒ
- **ä¸“ä¸šæµ‹é‡ç®—æ³•**ï¼šé›†æˆä¸šç•Œæ ‡å‡†çš„æµ‹é‡å’Œåˆ†æç®—æ³•
- **é«˜æ€§èƒ½æ•°æ®å¤„ç†**ï¼šæ”¯æŒé«˜é€Ÿæ•°æ®é‡‡é›†å’Œå®æ—¶å¤„ç†
- **çµæ´»çš„ç¡¬ä»¶æ¥å£**ï¼šæ”¯æŒå¤šç§ç¡¬ä»¶è®¾å¤‡çš„æ— ç¼é›†æˆ

## ğŸ—ï¸ ä»ªå™¨æ§ä»¶ä½“ç³»

### æ§ä»¶åˆ†ç±»æ¶æ„
```
ä»ªå™¨æ§ä»¶ç³»ç»Ÿ
â”œâ”€â”€ ä¿¡å·åˆ†æç±»
â”‚   â”œâ”€â”€ Oscilloscope (æ•°å­—ç¤ºæ³¢å™¨)
â”‚   â”œâ”€â”€ SpectrumAnalyzer (é¢‘è°±åˆ†æä»ª)
â”‚   â””â”€â”€ WaveformAnalyzer (æ³¢å½¢åˆ†æä»ª)
â”œâ”€â”€ ä¿¡å·ç”Ÿæˆç±»
â”‚   â”œâ”€â”€ SignalGenerator (ä¿¡å·å‘ç”Ÿå™¨)
â”‚   â”œâ”€â”€ FunctionGenerator (å‡½æ•°å‘ç”Ÿå™¨)
â”‚   â””â”€â”€ ArbitraryWaveformGenerator (ä»»æ„æ³¢å½¢å‘ç”Ÿå™¨)
â”œâ”€â”€ æµ‹é‡ä»ªè¡¨ç±»
â”‚   â”œâ”€â”€ DigitalMultimeter (æ•°å­—ä¸‡ç”¨è¡¨)
â”‚   â”œâ”€â”€ PowerMeter (åŠŸç‡è®¡)
â”‚   â””â”€â”€ FrequencyCounter (é¢‘ç‡è®¡)
â”œâ”€â”€ æ•°æ®é‡‡é›†ç±»
â”‚   â”œâ”€â”€ DataAcquisitionCard (æ•°æ®é‡‡é›†å¡)
â”‚   â”œâ”€â”€ TemperatureAcquisitionCard (æ¸©åº¦é‡‡é›†å¡)
â”‚   â””â”€â”€ DIOCard (æ•°å­—I/Oå¡)
â””â”€â”€ ç”µæºæ§åˆ¶ç±»
    â”œâ”€â”€ PowerSupply (å¯ç¼–ç¨‹ç”µæº)
    â”œâ”€â”€ ElectronicLoad (ç”µå­è´Ÿè½½)
    â””â”€â”€ BatterySimulator (ç”µæ± æ¨¡æ‹Ÿå™¨)
```

### æ ¸å¿ƒæ¥å£å®šä¹‰
```typescript
// ä»ªå™¨åŸºç¡€æ¥å£
interface InstrumentBase {
  id: string                    // ä»ªå™¨å”¯ä¸€æ ‡è¯†
  name: string                  // ä»ªå™¨åç§°
  model: string                 // å‹å·
  connected: boolean            // è¿æ¥çŠ¶æ€
  enabled: boolean              // å¯ç”¨çŠ¶æ€
  lastError?: string           // æœ€åé”™è¯¯ä¿¡æ¯
}

// æµ‹é‡é…ç½®æ¥å£
interface MeasurementConfig {
  id: string                    // æµ‹é‡ID
  name: string                  // æµ‹é‡åç§°
  type: string                  // æµ‹é‡ç±»å‹
  channel?: number             // é€šé“å·
  enabled: boolean             // æ˜¯å¦å¯ç”¨
  unit: string                 // å•ä½
  precision: number            // ç²¾åº¦
  range?: [number, number]     // æµ‹é‡èŒƒå›´
}

// æ•°æ®é‡‡é›†æ¥å£
interface AcquisitionConfig {
  sampleRate: number           // é‡‡æ ·ç‡
  bufferSize: number           // ç¼“å†²åŒºå¤§å°
  triggerMode: string          // è§¦å‘æ¨¡å¼
  triggerLevel?: number        // è§¦å‘ç”µå¹³
  channels: ChannelConfig[]    // é€šé“é…ç½®
}

// é€šé“é…ç½®æ¥å£
interface ChannelConfig {
  index: number                // é€šé“ç´¢å¼•
  enabled: boolean             // æ˜¯å¦å¯ç”¨
  name: string                 // é€šé“åç§°
  range: number                // é‡ç¨‹
  coupling: string             // è€¦åˆæ–¹å¼
  offset: number               // åç§»
  unit: string                 // å•ä½
}
```

## ğŸ”¬ Oscilloscope æ•°å­—ç¤ºæ³¢å™¨è¯¦è§£

### æ§ä»¶æ¶æ„

#### åŠŸèƒ½æ¨¡å—ç»„æˆ
```
æ•°å­—ç¤ºæ³¢å™¨
â”œâ”€â”€ æ˜¾ç¤ºç³»ç»Ÿ
â”‚   â”œâ”€â”€ æ³¢å½¢æ˜¾ç¤ºåŒºåŸŸ
â”‚   â”œâ”€â”€ æµ‹é‡ç»“æœæ˜¾ç¤º
â”‚   â”œâ”€â”€ çŠ¶æ€ä¿¡æ¯æ˜¾ç¤º
â”‚   â””â”€â”€ æ¸¸æ ‡æµ‹é‡æ˜¾ç¤º
â”œâ”€â”€ æ—¶åŸºç³»ç»Ÿ
â”‚   â”œâ”€â”€ æ—¶é—´/æ ¼è®¾ç½®
â”‚   â”œâ”€â”€ æ°´å¹³ä½ç½®æ§åˆ¶
â”‚   â”œâ”€â”€ é‡‡æ ·ç‡é…ç½®
â”‚   â””â”€â”€ æ˜¾ç¤ºæ¨¡å¼é€‰æ‹©
â”œâ”€â”€ å‚ç›´ç³»ç»Ÿ
â”‚   â”œâ”€â”€ ç”µå‹/æ ¼è®¾ç½®
â”‚   â”œâ”€â”€ å‚ç›´ä½ç½®æ§åˆ¶
â”‚   â”œâ”€â”€ è€¦åˆæ–¹å¼é€‰æ‹©
â”‚   â””â”€â”€ å¸¦å®½é™åˆ¶è®¾ç½®
â”œâ”€â”€ è§¦å‘ç³»ç»Ÿ
â”‚   â”œâ”€â”€ è§¦å‘æºé€‰æ‹©
â”‚   â”œâ”€â”€ è§¦å‘ç±»å‹è®¾ç½®
â”‚   â”œâ”€â”€ è§¦å‘ç”µå¹³æ§åˆ¶
â”‚   â””â”€â”€ è§¦å‘æ¨¡å¼é…ç½®
â”œâ”€â”€ æµ‹é‡ç³»ç»Ÿ
â”‚   â”œâ”€â”€ è‡ªåŠ¨æµ‹é‡åŠŸèƒ½
â”‚   â”œâ”€â”€ æ¸¸æ ‡æµ‹é‡å·¥å…·
â”‚   â”œâ”€â”€ ç»Ÿè®¡åˆ†æåŠŸèƒ½
â”‚   â””â”€â”€ æ•°å­¦è¿ç®—åŠŸèƒ½
â””â”€â”€ é‡‡é›†ç³»ç»Ÿ
    â”œâ”€â”€ é‡‡é›†æ¨¡å¼é€‰æ‹©
    â”œâ”€â”€ å†…å­˜æ·±åº¦è®¾ç½®
    â”œâ”€â”€ æ•°æ®ç¼“å†²ç®¡ç†
    â””â”€â”€ æ€§èƒ½ç›‘æ§
```

#### æ ¸å¿ƒå±æ€§é…ç½®
```typescript
interface OscilloscopeProps {
  width?: number                // æ§ä»¶å®½åº¦
  height?: number               // æ§ä»¶é«˜åº¦
  channels?: number             // é€šé“æ•°é‡
  maxSampleRate?: number        // æœ€å¤§é‡‡æ ·ç‡
  memoryDepth?: number          // å†…å­˜æ·±åº¦
  bandwidthLimit?: number       // å¸¦å®½é™åˆ¶
  triggerTypes?: string[]       // æ”¯æŒçš„è§¦å‘ç±»å‹
  measurementTypes?: string[]   // æ”¯æŒçš„æµ‹é‡ç±»å‹
}
```

### æ—¶åŸºç³»ç»Ÿè¯¦è§£

#### æ—¶åŸºæ§åˆ¶å®ç°
```typescript
class TimebaseController {
  private scale: number = 0.001  // æ—¶é—´/æ ¼ (ç§’)
  private position: number = 0   // æ°´å¹³ä½ç½® (%)
  private mode: 'normal' | 'roll' | 'xy' = 'normal'
  
  // æ—¶åŸºåˆ»åº¦é…ç½®
  private readonly scales = [
    { label: '1ns/div', value: 1e-9 },
    { label: '2ns/div', value: 2e-9 },
    { label: '5ns/div', value: 5e-9 },
    { label: '10ns/div', value: 1e-8 },
    { label: '20ns/div', value: 2e-8 },
    { label: '50ns/div', value: 5e-8 },
    { label: '100ns/div', value: 1e-7 },
    { label: '200ns/div', value: 2e-7 },
    { label: '500ns/div', value: 5e-7 },
    { label: '1Î¼s/div', value: 1e-6 },
    { label: '2Î¼s/div', value: 2e-6 },
    { label: '5Î¼s/div', value: 5e-6 },
    { label: '10Î¼s/div', value: 1e-5 },
    { label: '20Î¼s/div', value: 2e-5 },
    { label: '50Î¼s/div', value: 5e-5 },
    { label: '100Î¼s/div', value: 1e-4 },
    { label: '200Î¼s/div', value: 2e-4 },
    { label: '500Î¼s/div', value: 5e-4 },
    { label: '1ms/div', value: 1e-3 },
    { label: '2ms/div', value: 2e-3 },
    { label: '5ms/div', value: 5e-3 },
    { label: '10ms/div', value: 1e-2 },
    { label: '20ms/div', value: 2e-2 },
    { label: '50ms/div', value: 5e-2 },
    { label: '100ms/div', value: 1e-1 },
    { label: '200ms/div', value: 2e-1 },
    { label: '500ms/div', value: 5e-1 },
    { label: '1s/div', value: 1 },
    { label: '2s/div', value: 2 },
    { label: '5s/div', value: 5 },
    { label: '10s/div', value: 10 }
  ]
  
  // è®¾ç½®æ—¶åŸº
  setScale(scale: number): void {
    this.scale = scale
    this.updateSampleRate()
    this.updateDisplayWindow()
  }
  
  // è®¾ç½®æ°´å¹³ä½ç½®
  setPosition(position: number): void {
    this.position = Math.max(-50, Math.min(50, position))
    this.updateDisplayWindow()
  }
  
  // è®¾ç½®æ˜¾ç¤ºæ¨¡å¼
  setMode(mode: 'normal' | 'roll' | 'xy'): void {
    this.mode = mode
    this.configureDisplayMode()
  }
  
  // è®¡ç®—é‡‡æ ·ç‡
  private updateSampleRate(): void {
    const pointsPerDiv = 100
    const totalDivs = 10
    const totalTime = this.scale * totalDivs
    const requiredSampleRate = (pointsPerDiv * totalDivs) / totalTime
    
    // é€‰æ‹©åˆé€‚çš„é‡‡æ ·ç‡
    const availableRates = [1e6, 10e6, 100e6, 1e9, 10e9]
    const selectedRate = availableRates.find(rate => rate >= requiredSampleRate * 2) || availableRates[0]
    
    this.emit('sampleRateChange', selectedRate)
  }
  
  // æ›´æ–°æ˜¾ç¤ºçª—å£
  private updateDisplayWindow(): void {
    const totalTime = this.scale * 10
    const startTime = -totalTime * (this.position / 100)
    
    this.emit('displayWindowChange', {
      startTime,
      duration: totalTime,
      scale: this.scale
    })
  }
  
  // é…ç½®æ˜¾ç¤ºæ¨¡å¼
  private configureDisplayMode(): void {
    switch (this.mode) {
      case 'normal':
        this.configureNormalMode()
        break
      case 'roll':
        this.configureRollMode()
        break
      case 'xy':
        this.configureXYMode()
        break
    }
  }
  
  private configureNormalMode(): void {
    // æ­£å¸¸æ¨¡å¼ï¼šè§¦å‘åæ˜¾ç¤ºå®Œæ•´æ³¢å½¢
    this.emit('displayModeChange', {
      mode: 'normal',
      triggerRequired: true,
      continuousUpdate: false
    })
  }
  
  private configureRollMode(): void {
    // æ»šåŠ¨æ¨¡å¼ï¼šè¿ç»­æ»šåŠ¨æ˜¾ç¤ºï¼Œé€‚ç”¨äºä½é¢‘ä¿¡å·
    this.emit('displayModeChange', {
      mode: 'roll',
      triggerRequired: false,
      continuousUpdate: true,
      scrollSpeed: this.scale
    })
  }
  
  private configureXYMode(): void {
    // XYæ¨¡å¼ï¼šCH1ä½œä¸ºXè½´ï¼ŒCH2ä½œä¸ºYè½´
    this.emit('displayModeChange', {
      mode: 'xy',
      triggerRequired: false,
      continuousUpdate: true,
      xChannel: 0,
      yChannel: 1
    })
  }
}
```

### å‚ç›´ç³»ç»Ÿè¯¦è§£

#### é€šé“æ§åˆ¶å®ç°
```typescript
class ChannelController {
  private channels: ChannelConfig[] = []
  
  // ç”µå‹åˆ»åº¦é…ç½®
  private readonly voltageScales = [
    { label: '1mV/div', value: 0.001 },
    { label: '2mV/div', value: 0.002 },
    { label: '5mV/div', value: 0.005 },
    { label: '10mV/div', value: 0.01 },
    { label: '20mV/div', value: 0.02 },
    { label: '50mV/div', value: 0.05 },
    { label: '100mV/div', value: 0.1 },
    { label: '200mV/div', value: 0.2 },
    { label: '500mV/div', value: 0.5 },
    { label: '1V/div', value: 1 },
    { label: '2V/div', value: 2 },
    { label: '5V/div', value: 5 },
    { label: '10V/div', value: 10 }
  ]
  
  constructor(channelCount: number = 4) {
    this.initializeChannels(channelCount)
  }
  
  // åˆå§‹åŒ–é€šé“
  private initializeChannels(count: number): void {
    const colors = ['#FFD700', '#00CED1', '#FF69B4', '#32CD32']
    
    for (let i = 0; i < count; i++) {
      this.channels.push({
        index: i,
        enabled: i < 2, // é»˜è®¤å¯ç”¨å‰ä¸¤ä¸ªé€šé“
        name: `CH${i + 1}`,
        range: 1, // 1V/div
        coupling: 'DC',
        offset: 0,
        unit: 'V',
        color: colors[i % colors.length],
        bandwidth: 0, // å…¨å¸¦å®½
        probe: 1, // 1xæ¢å¤´
        invert: false
      })
    }
  }
  
  // è®¾ç½®é€šé“å‚æ•°
  setChannelConfig(index: number, config: Partial<ChannelConfig>): void {
    if (index >= 0 && index < this.channels.length) {
      Object.assign(this.channels[index], config)
      this.updateChannelSettings(index)
    }
  }
  
  // å¯ç”¨/ç¦ç”¨é€šé“
  enableChannel(index: number, enabled: boolean): void {
    if (index >= 0 && index < this.channels.length) {
      this.channels[index].enabled = enabled
      this.emit('channelStateChange', { index, enabled })
    }
  }
  
  // è®¾ç½®ç”µå‹åˆ»åº¦
  setVoltageScale(index: number, scale: number): void {
    if (index >= 0 && index < this.channels.length) {
      this.channels[index].range = scale
      this.updateChannelRange(index)
    }
  }
  
  // è®¾ç½®å‚ç›´ä½ç½®
  setVerticalPosition(index: number, position: number): void {
    if (index >= 0 && index < this.channels.length) {
      // ä½ç½®ä»¥æ ¼ä¸ºå•ä½ï¼ŒèŒƒå›´é€šå¸¸æ˜¯-4åˆ°+4æ ¼
      this.channels[index].offset = Math.max(-4, Math.min(4, position)) * this.channels[index].range
      this.updateChannelOffset(index)
    }
  }
  
  // è®¾ç½®è€¦åˆæ–¹å¼
  setCoupling(index: number, coupling: 'DC' | 'AC' | 'GND'): void {
    if (index >= 0 && index < this.channels.length) {
      this.channels[index].coupling = coupling
      this.updateChannelCoupling(index)
    }
  }
  
  // è®¾ç½®å¸¦å®½é™åˆ¶
  setBandwidthLimit(index: number, bandwidth: number): void {
    if (index >= 0 && index < this.channels.length) {
      this.channels[index].bandwidth = bandwidth
      this.updateChannelBandwidth(index)
    }
  }
  
  // æ›´æ–°é€šé“è®¾ç½®
  private updateChannelSettings(index: number): void {
    const channel = this.channels[index]
    
    this.emit('channelConfigChange', {
      index,
      config: channel
    })
  }
  
  // æ›´æ–°é€šé“é‡ç¨‹
  private updateChannelRange(index: number): void {
    const channel = this.channels[index]
    
    // è®¡ç®—ADCé‡ç¨‹
    const adcRange = channel.range * 8 * channel.probe // 8æ ¼ Ã— æ¢å¤´å€æ•°
    
    this.emit('channelRangeChange', {
      index,
      range: adcRange,
      scale: channel.range
    })
  }
  
  // æ›´æ–°é€šé“åç§»
  private updateChannelOffset(index: number): void {
    const channel = this.channels[index]
    
    this.emit('channelOffsetChange', {
      index,
      offset: channel.offset
    })
  }
  
  // æ›´æ–°é€šé“è€¦åˆ
  private updateChannelCoupling(index: number): void {
    const channel = this.channels[index]
    
    this.emit('channelCouplingChange', {
      index,
      coupling: channel.coupling
    })
  }
  
  // æ›´æ–°é€šé“å¸¦å®½
  private updateChannelBandwidth(index: number): void {
    const channel = this.channels[index]
    
    this.emit('channelBandwidthChange', {
      index,
      bandwidth: channel.bandwidth
    })
  }
  
  // è·å–å¯ç”¨çš„é€šé“
  getEnabledChannels(): ChannelConfig[] {
    return this.channels.filter(ch => ch.enabled)
  }
  
  // è·å–é€šé“é…ç½®
  getChannelConfig(index: number): ChannelConfig | null {
    return index >= 0 && index < this.channels.length ? this.channels[index] : null
  }
}
```

### è§¦å‘ç³»ç»Ÿè¯¦è§£

#### è§¦å‘æ§åˆ¶å®ç°
```typescript
class TriggerController {
  private config: TriggerConfig = {
    source: 0,
    type: 'edge',
    slope: 'rising',
    level: 0,
    mode: 'auto',
    holdoff: 0
  }
  
  private triggerState: 'waiting' | 'triggered' | 'stopped' = 'stopped'
  private lastTriggerTime: number = 0
  
  // è®¾ç½®è§¦å‘æº
  setTriggerSource(source: number | 'external'): void {
    this.config.source = source
    this.updateTriggerConfig()
  }
  
  // è®¾ç½®è§¦å‘ç±»å‹
  setTriggerType(type: 'edge' | 'pulse' | 'video' | 'pattern'): void {
    this.config.type = type
    this.updateTriggerConfig()
  }
  
  // è®¾ç½®è§¦å‘æ–œç‡
  setTriggerSlope(slope: 'rising' | 'falling' | 'both'): void {
    this.config.slope = slope
    this.updateTriggerConfig()
  }
  
  // è®¾ç½®è§¦å‘ç”µå¹³
  setTriggerLevel(level: number): void {
    this.config.level = level
    this.updateTriggerConfig()
  }
  
  // è®¾ç½®è§¦å‘æ¨¡å¼
  setTriggerMode(mode: 'auto' | 'normal' | 'single'): void {
    this.config.mode = mode
    this.updateTriggerState()
  }
  
  // æ£€æµ‹è§¦å‘æ¡ä»¶
  checkTrigger(data: number[], timestamp: number): boolean {
    if (this.triggerState !== 'waiting') {
      return false
    }
    
    // æ£€æŸ¥è§¦å‘é‡ŠæŠ‘æ—¶é—´
    if (timestamp - this.lastTriggerTime < this.config.holdoff * 1000) {
      return false
    }
    
    let triggered = false
    
    switch (this.config.type) {
      case 'edge':
        triggered = this.checkEdgeTrigger(data)
        break
      case 'pulse':
        triggered = this.checkPulseTrigger(data)
        break
      case 'video':
        triggered = this.checkVideoTrigger(data)
        break
      case 'pattern':
        triggered = this.checkPatternTrigger(data)
        break
    }
    
    if (triggered) {
      this.onTriggerDetected(timestamp)
    }
    
    return triggered
  }
  
  // è¾¹æ²¿è§¦å‘æ£€æµ‹
  private checkEdgeTrigger(data: number[]): boolean {
    if (data.length < 2) return false
    
    const level = this.config.level
    
    for (let i = 1; i < data.length; i++) {
      const prev = data[i - 1]
      const curr = data[i]
      
      switch (this.config.slope) {
        case 'rising':
          if (prev < level && curr >= level) return true
          break
        case 'falling':
          if (prev > level && curr <= level) return true
          break
        case 'both':
          if ((prev < level && curr >= level) || (prev > level && curr <= level)) return true
          break
      }
    }
    
    return false
  }
  
  // è„‰å®½è§¦å‘æ£€æµ‹
  private checkPulseTrigger(data: number[]): boolean {
    // å®ç°è„‰å®½è§¦å‘é€»è¾‘
    const level = this.config.level
    let pulseStart = -1
    let pulseWidth = 0
    
    for (let i = 0; i < data.length; i++) {
      if (data[i] > level && pulseStart === -1) {
        pulseStart = i
      } else if (data[i] <= level && pulseStart !== -1) {
        pulseWidth = i - pulseStart
        // æ£€æŸ¥è„‰å®½æ˜¯å¦æ»¡è¶³æ¡ä»¶
        if (this.isPulseWidthValid(pulseWidth)) {
          return true
        }
        pulseStart = -1
      }
    }
    
    return false
  }
  
  // è§†é¢‘è§¦å‘æ£€æµ‹
  private checkVideoTrigger(data: number[]): boolean {
    // å®ç°è§†é¢‘ä¿¡å·è§¦å‘é€»è¾‘
    // æ£€æµ‹è§†é¢‘åŒæ­¥ä¿¡å·
    return this.detectVideoSync(data)
  }
  
  // æ¨¡å¼è§¦å‘æ£€æµ‹
  private checkPatternTrigger(data: number[]): boolean {
    // å®ç°æ•°å­—æ¨¡å¼è§¦å‘é€»è¾‘
    // æ£€æµ‹ç‰¹å®šçš„æ•°å­—æ¨¡å¼
    return this.detectDigitalPattern(data)
  }
  
  // è§¦å‘æ£€æµ‹å›è°ƒ
  private onTriggerDetected(timestamp: number): void {
    this.triggerState = 'triggered'
    this.lastTriggerTime = timestamp
    
    this.emit('triggerDetected', {
      timestamp,
      config: this.config
    })
    
    // æ ¹æ®è§¦å‘æ¨¡å¼å†³å®šä¸‹ä¸€æ­¥åŠ¨ä½œ
    if (this.config.mode === 'single') {
      this.triggerState = 'stopped'
    } else {
      // è‡ªåŠ¨æˆ–æ­£å¸¸æ¨¡å¼ï¼Œå‡†å¤‡ä¸‹æ¬¡è§¦å‘
      setTimeout(() => {
        if (this.config.mode === 'auto' || this.config.mode === 'normal') {
          this.triggerState = 'waiting'
        }
      }, 100)
    }
  }
  
  // å¼ºåˆ¶è§¦å‘
  forceTrigger(): void {
    this.onTriggerDetected(Date.now())
  }
  
  // å¯åŠ¨è§¦å‘
  startTrigger(): void {
    this.triggerState = 'waiting'
    this.emit('triggerStateChange', this.triggerState)
  }
  
  // åœæ­¢è§¦å‘
  stopTrigger(): void {
    this.triggerState = 'stopped'
    this.emit('triggerStateChange', this.triggerState)
  }
  
  // æ›´æ–°è§¦å‘é…ç½®
  private updateTriggerConfig(): void {
    this.emit('triggerConfigChange', this.config)
  }
  
  // æ›´æ–°è§¦å‘çŠ¶æ€
  private updateTriggerState(): void {
    if (this.config.mode === 'auto') {
      this.triggerState = 'waiting'
    }
    this.emit('triggerStateChange', this.triggerState)
  }
  
  // è¾…åŠ©æ–¹æ³•
  private isPulseWidthValid(width: number): boolean {
    // æ£€æŸ¥è„‰å®½æ˜¯å¦åœ¨è®¾å®šèŒƒå›´å†…
    return width > 0 // ç®€åŒ–å®ç°
  }
  
  private detectVideoSync(data: number[]): boolean {
    // è§†é¢‘åŒæ­¥æ£€æµ‹å®ç°
    return false // ç®€åŒ–å®ç°
  }
  
  private detectDigitalPattern(data: number[]): boolean {
    // æ•°å­—æ¨¡å¼æ£€æµ‹å®ç°
    return false // ç®€åŒ–å®ç°
  }
}
```

### æµ‹é‡ç³»ç»Ÿè¯¦è§£

#### è‡ªåŠ¨æµ‹é‡å®ç°
```typescript
class MeasurementEngine {
  private measurements: Map<string, MeasurementConfig> = new Map()
  private results: Map<string, number> = new Map()
  
  // æ”¯æŒçš„æµ‹é‡ç±»å‹
  private readonly measurementTypes = [
    { type: 'frequency', name: 'é¢‘ç‡', unit: 'Hz' },
    { type: 'period', name: 'å‘¨æœŸ', unit: 's' },
    { type: 'amplitude', name: 'å¹…åº¦', unit: 'V' },
    { type: 'peak-peak', name: 'å³°å³°å€¼', unit: 'V' },
    { type: 'rms', name: 'RMS', unit: 'V' },
    { type: 'mean', name: 'å¹³å‡å€¼', unit: 'V' },
    { type: 'max', name: 'æœ€å¤§å€¼', unit: 'V' },
    { type: 'min', name: 'æœ€å°å€¼', unit: 'V' },
    { type: 'rise-time', name: 'ä¸Šå‡æ—¶é—´', unit: 's' },
    { type: 'fall-time', name: 'ä¸‹é™æ—¶é—´', unit: 's' },
    { type: 'duty-cycle', name: 'å ç©ºæ¯”', unit: '%' },
    { type: 'overshoot', name: 'è¿‡å†²', unit: '%' },
    { type: 'undershoot', name: 'ä¸‹å†²', unit: '%' },
    { type: 'preshoot', name: 'é¢„å†²', unit: '%' }
  ]
  
  // æ·»åŠ æµ‹é‡
  addMeasurement(type: string, channel: number): string {
    const id = `${type}_ch${channel}_${Date.now()}`
    const measurementType = this.measurementTypes.find(m => m.type === type)
    
    if (!measurementType) {
      throw new Error(`ä¸æ”¯æŒçš„æµ‹é‡ç±»å‹: ${type}`)
    }
    
    const measurement: MeasurementConfig = {
      id,
      name: measurementType.name,
      type,
      channel,
      enabled: true,
      unit: measurementType.unit,
      precision: this.getDefaultPrecision(type)
    }
    
    this.measurements.set(id, measurement)
    return id
  }
  
  // ç§»é™¤æµ‹é‡
  removeMeasurement(id: string): void {
    this.measurements.delete(id)
    this.results.delete(id)
  }
  
  // æ¸…é™¤æ‰€æœ‰æµ‹é‡
  clearMeasurements(): void {
    this.measurements.clear()
    this.results.clear()
  }
  
  // æ‰§è¡Œæµ‹é‡
  performMeasurements(channelData: Map<number, number[]>): void {
    for (const [id, measurement] of this.measurements) {
      if (!measurement.enabled) continue
      
      const data = channelData.get(measurement.channel)
      if (!data || data.length === 0) continue
      
      try {
        const result = this.calculateMeasurement(measurement.type, data)
        this.results.set(id, result)
      } catch (error) {
        console.error(`æµ‹é‡è®¡ç®—é”™è¯¯ [${id}]:`, error)
        this.results.set(id, NaN)
      }
    }
    
    this.emit('measurementsUpdated', this.getMeasurementResults())
  }
  
  // è®¡ç®—å…·ä½“æµ‹é‡å€¼
  private calculateMeasurement(type: string, data: number[]): number {
    switch (type) {
      case 'frequency':
        return this.calculateFrequency(data)
      case 'period':
        return 1 / this.calculateFrequency(data)
      case 'amplitude':
        return this.calculateAmplitude(data)
      case 'peak-peak':
        return Math.max(...data) - Math.min(...data)
      case 'rms':
        return this.calculateRMS(data)
      case 'mean':
        return data.reduce((sum, val) => sum + val, 0) / data.length
      case 'max':
        return Math.max(...data)
      case 'min':
        return Math.min(...data)
      case 'rise-time':
        return this.calculateRiseTime(data)
      case 'fall-time':
        return this.calculateFallTime(data)
      case 'duty-cycle':
        return this.calculateDutyCycle(data)
      case 'overshoot':
        return this.calculateOvershoot(data)
      case 'undershoot':
        return this.calculateUndershoot(data)
      case 'preshoot':
        return this.calculatePreshoot(data)
      default:
        throw new Error(`æœªå®ç°çš„æµ‹é‡ç±»å‹: ${type}`)
    }
  }
  
  // é¢‘ç‡è®¡ç®—
  private calculateFrequency(data: number[]): number {
    const crossings = this.findZeroCrossings(data)
    if (crossings.length < 2) return 0
    
    // è®¡ç®—å¹³å‡å‘¨æœŸ
    const periods: number[] = []
    for (let i = 2; i < crossings.length; i += 2) {
      periods.push(crossings[i] - crossings[i - 2])
    }
    
    if (periods.length === 0) return 0
    
    const avgPeriod = periods.reduce((sum, p) => sum + p, 0) / periods.length
    const sampleRate = this.getSampleRate()
    
    return sampleRate / (avgPeriod * 2) // æ¯ä¸ªå‘¨æœŸæœ‰2ä¸ªé›¶ç‚¹äº¤å‰
  }
  
  // å¹…åº¦è®¡ç®—
  private calculateAmplitude(data: number[]): number {
    const max = Math.max(...data)
    const min = Math.min(...data)
    return (max - min) / 2
  }
  
  // RMSè®¡ç®—
  private calculateRMS(data: number[]): number {
    const sumSquares = data.reduce((sum, val) => sum + val * val, 0)
    return Math.sqrt(sumSquares / data.length)
  }
  
  // ä¸Šå‡æ—¶é—´è®¡ç®— (10%-90%)
  private calculateRiseTime(data: number[]): number {
    const max = Math.max(...data)
    const min = Math.min(...data)
    const level10 = min + (max - min) * 0.1
    const level90 = min + (max - min) * 0.9
    
    let start = -1, end = -1
    for (let i = 0; i < data.length; i++) {
      if (start === -1 && data[i] >= level10) start = i
      if (start !== -1 && data[i] >= level90) {
        end = i
        break
      }
    }
    
    if (start === -1 || end === -1) return 0
    const sampleRate = this.getSampleRate()
    return (end - start) / sampleRate
  }
  
  // ä¸‹é™æ—¶é—´è®¡ç®— (90%-10%)
  private calculateFallTime(data: number[]): number {
    const max = Math.max(...data)
    const min = Math.min(...data)
    const level90 = min + (max - min) * 0.9
    const level10 = min + (max - min) * 0.1
    
    let start = -1, end = -1
    for (let i = 0; i < data.length; i++) {
      if (start === -1 && data[i] <= level90) start = i
      if (start !== -1 && data[i] <= level10) {
        end = i
        break
      }
    }
    
    if (start === -1 || end === -1) return 0
    const sampleRate = this.getSampleRate()
    return (end - start) / sampleRate
  }
  
  // å ç©ºæ¯”è®¡ç®—
  private calculateDutyCycle(data: number[]): number {
    const threshold = (Math.max(...data) + Math.min(...data)) / 2
    let highCount = 0
    for (const value of data) {
      if (value > threshold) highCount++
    }
    return (highCount / data.length) * 100
  }
  
  // è¿‡å†²è®¡ç®—
  private calculateOvershoot(data: number[]): number {
    const max = Math.max(...data)
    const steadyState = this.calculateSteadyStateValue(data)
    return ((max - steadyState) / steadyState) * 100
  }
  
  // ä¸‹å†²è®¡ç®—
  private calculateUndershoot(data: number[]): number {
    const min = Math.min(...data)
    const steadyState = this.calculateSteadyStateValue(data)
    return ((steadyState - min) / steadyState) * 100
  }
  
  // é¢„å†²è®¡ç®—
  private calculatePreshoot(data: number[]): number {
    // ç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ›´å¤æ‚çš„ç®—æ³•
    return 0
  }
  
  // è¾…åŠ©æ–¹æ³•
  private findZeroCrossings(data: number[]): number[] {
    const crossings: number[] = []
    for (let i = 1; i < data.length; i++) {
      if ((data[i] >= 0 && data[i - 1] < 0) || (data[i] < 0 && data[i - 1] >= 0)) {
        crossings.push(i)
      }
    }
    return crossings
  }
  
  private calculateSteadyStateValue(data: number[]): number {
    // å–æœ€å10%çš„æ•°æ®è®¡ç®—ç¨³æ€å€¼
    const startIndex = Math.floor(data.length * 0.9)
    const steadyData = data.slice(startIndex)
    return steadyData.reduce((sum, val) => sum + val, 0) / steadyData.length
  }
  
  private getSampleRate(): number {
    // ä»å…¨å±€é…ç½®è·å–é‡‡æ ·ç‡
    return 100000000 // 100MS/s é»˜è®¤å€¼
  }
  
  private getDefaultPrecision(type: string): number {
    const precisionMap: Record<string, number> = {
      'frequency': 3,
      'period': 6,
      'amplitude': 3,
      'peak-peak': 3,
      'rms': 3,
      'mean': 3,
      'max': 3,
      'min': 3,
      'rise-time': 6,
      'fall-time': 6,
      'duty-cycle': 1,
      'overshoot': 1,
      'undershoot': 1,
      'preshoot': 1
    }
    return precisionMap[type] || 3
  }
  
  // è·å–æµ‹é‡ç»“æœ
  getMeasurementResults(): Array<{ id: string; config: MeasurementConfig; value: number }> {
    const results: Array<{ id: string; config: MeasurementConfig; value: number }> = []
    
    for (const [id, measurement] of this.measurements) {
      const value = this.results.get(id) || 0
      results.push({ id, config: measurement, value })
    }
    
    return results
  }
}
```

## ğŸ“¡ SignalGenerator ä¿¡å·å‘ç”Ÿå™¨è¯¦è§£

### æ§ä»¶æ¶æ„

#### åŠŸèƒ½æ¨¡å—ç»„æˆ
```
ä¿¡å·å‘ç”Ÿå™¨
â”œâ”€â”€ æ³¢å½¢ç”Ÿæˆç³»ç»Ÿ
â”‚   â”œâ”€â”€ åŸºç¡€æ³¢å½¢ç”Ÿæˆ
â”‚   â”œâ”€â”€ ä»»æ„æ³¢å½¢ç”Ÿæˆ
â”‚   â”œâ”€â”€ è°ƒåˆ¶æ³¢å½¢ç”Ÿæˆ
â”‚   â””â”€â”€ å™ªå£°ä¿¡å·ç”Ÿæˆ
â”œâ”€â”€ å‚æ•°æ§åˆ¶ç³»ç»Ÿ
â”‚   â”œâ”€â”€ é¢‘ç‡æ§åˆ¶
â”‚   â”œâ”€â”€ å¹…åº¦æ§åˆ¶
â”‚   â”œâ”€â”€ ç›¸ä½æ§åˆ¶
â”‚   â””â”€â”€ åç½®æ§åˆ¶
â”œâ”€â”€ è°ƒåˆ¶ç³»ç»Ÿ
â”‚   â”œâ”€â”€ å¹…åº¦è°ƒåˆ¶ (AM)
â”‚   â”œâ”€â”€ é¢‘ç‡è°ƒåˆ¶ (FM)
â”‚   â”œâ”€â”€ ç›¸ä½è°ƒåˆ¶ (PM)
â”‚   â””â”€â”€ è„‰å®½è°ƒåˆ¶ (PWM)
â”œâ”€â”€ æ‰«é¢‘ç³»ç»Ÿ
â”‚   â”œâ”€â”€ çº¿æ€§æ‰«é¢‘
â”‚   â”œâ”€â”€ å¯¹æ•°æ‰«é¢‘
â”‚   â”œâ”€â”€ æ­¥è¿›æ‰«é¢‘
â”‚   â””â”€â”€ åˆ—è¡¨æ‰«é¢‘
â”œâ”€â”€ è¾“å‡ºæ§åˆ¶ç³»ç»Ÿ
â”‚   â”œâ”€â”€ è¾“å‡ºå¼€å…³æ§åˆ¶
â”‚   â”œâ”€â”€ è´Ÿè½½åŒ¹é…
â”‚   â”œâ”€â”€ åŒæ­¥è¾“å‡º
â”‚   â””â”€â”€ ä¿æŠ¤åŠŸèƒ½
â””â”€â”€ é¢„è®¾ç®¡ç†ç³»ç»Ÿ
    â”œâ”€â”€ å†…ç½®é¢„è®¾
    â”œâ”€â”€ ç”¨æˆ·é¢„è®¾
    â”œâ”€â”€ é¢„è®¾å¯¼å…¥å¯¼å‡º
    â””â”€â”€ å¿«é€ŸåŠ è½½
```

#### æ ¸å¿ƒå±æ€§é…ç½®
```typescript
interface SignalGeneratorProps {
  width?: number                // æ§ä»¶å®½åº¦
  height?: number               // æ§ä»¶é«˜åº¦
  maxFrequency?: number         // æœ€å¤§é¢‘ç‡
  maxAmplitude?: number         // æœ€å¤§å¹…åº¦
  waveformTypes?: string[]      // æ”¯æŒçš„æ³¢å½¢ç±»å‹
  modulationTypes?: string[]    // æ”¯æŒçš„è°ƒåˆ¶ç±»å‹
  outputChannels?: number       // è¾“å‡ºé€šé“æ•°
}
```

### æ³¢å½¢ç”Ÿæˆå¼•æ“è¯¦è§£

#### åŸºç¡€æ³¢å½¢ç”Ÿæˆå™¨
```typescript
class WaveformGenerator {
  private sampleRate: number = 1000000 // 1MS/s
  private bufferSize: number = 1024
  
  // ç”Ÿæˆæ­£å¼¦æ³¢
  generateSineWave(config: WaveformConfig): number[] {
    const { frequency, amplitude, phase, offset, samples } = config
    const data: number[] = []
    const omega = 2 * Math.PI * frequency / this.sampleRate
    const phaseRad = (phase * Math.PI) / 180
    
    for (let i = 0; i < samples; i++) {
      const value = amplitude * Math.sin(omega * i + phaseRad) + offset
      data.push(value)
    }
    
    return data
  }
  
  // ç”Ÿæˆæ–¹æ³¢
  generateSquareWave(config: WaveformConfig & { dutyCycle: number }): number[] {
    const { frequency, amplitude, phase, offset, samples, dutyCycle } = config
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    
    for (let i = 0; i < samples; i++) {
      const adjustedIndex = (i + phaseOffset) % period
      const isHigh = adjustedIndex < (period * dutyCycle / 100)
      const value = (isHigh ? amplitude : -amplitude) + offset
      data.push(value)
    }
    
    return data
  }
  
  // ç”Ÿæˆä¸‰è§’æ³¢
  generateTriangleWave(config: WaveformConfig): number[] {
    const { frequency, amplitude, phase, offset, samples } = config
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    
    for (let i = 0; i < samples; i++) {
      const adjustedIndex = (i + phaseOffset) % period
      const progress = adjustedIndex / period
      
      let value: number
      if (progress < 0.5) {
        value = 4 * progress - 1 // ä¸Šå‡æ²¿
      } else {
        value = 3 - 4 * progress // ä¸‹é™æ²¿
      }
      
      data.push(amplitude * value + offset)
    }
    
    return data
  }
  
  // ç”Ÿæˆé”¯é½¿æ³¢
  generateSawtoothWave(config: WaveformConfig): number[] {
    const { frequency, amplitude, phase, offset, samples } = config
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    
    for (let i = 0; i < samples; i++) {
      const adjustedIndex = (i + phaseOffset) % period
      const progress = adjustedIndex / period
      const value = 2 * progress - 1
      data.push(amplitude * value + offset)
    }
    
    return data
  }
  
  // ç”Ÿæˆè„‰å†²æ³¢
  generatePulseWave(config: WaveformConfig & { pulseWidth: number }): number[] {
    const { frequency, amplitude, phase, offset, samples, pulseWidth } = config
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    const pulseSamples = (pulseWidth / 1000000) * this.sampleRate // è„‰å®½è½¬æ¢ä¸ºé‡‡æ ·ç‚¹æ•°
    
    for (let i = 0; i < samples; i++) {
      const adjustedIndex = (i + phaseOffset) % period
      const value = adjustedIndex < pulseSamples ? amplitude : 0
      data.push(value + offset)
    }
    
    return data
  }
  
  // ç”Ÿæˆç™½å™ªå£°
  generateWhiteNoise(config: WaveformConfig & { noiseLevel: number }): number[] {
    const { amplitude, offset, samples, noiseLevel } = config
    const data: number[] = []
    
    for (let i = 0; i < samples; i++) {
      const noise = (Math.random() - 0.5) * 2 * noiseLevel
      const value = amplitude * noise + offset
      data.push(value)
    }
    
    return data
  }
  
  // ç”Ÿæˆä»»æ„æ³¢å½¢
  generateArbitraryWaveform(points: number[], config: WaveformConfig): number[] {
    const { frequency, amplitude, phase, offset, samples } = config
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    
    for (let i = 0; i < samples; i++) {
      const adjustedIndex = (i + phaseOffset) % period
      const progress = adjustedIndex / period
      const pointIndex = progress * (points.length - 1)
      
      // çº¿æ€§æ’å€¼
      const lowerIndex = Math.floor(pointIndex)
      const upperIndex = Math.ceil(pointIndex)
      const fraction = pointIndex - lowerIndex
      
      const lowerValue = points[lowerIndex] || 0
      const upperValue = points[upperIndex] || 0
      const interpolatedValue = lowerValue + (upperValue - lowerValue) * fraction
      
      data.push(amplitude * interpolatedValue + offset)
    }
    
    return data
  }
}
```

### è°ƒåˆ¶ç³»ç»Ÿè¯¦è§£

#### è°ƒåˆ¶å¼•æ“å®ç°
```typescript
class ModulationEngine {
  // å¹…åº¦è°ƒåˆ¶ (AM)
  applyAmplitudeModulation(
    carrier: number[], 
    modConfig: { frequency: number; depth: number; phase: number }
  ): number[] {
    const { frequency, depth, phase } = modConfig
    const modulated: number[] = []
    const omega = 2 * Math.PI * frequency / this.sampleRate
    const phaseRad = (phase * Math.PI) / 180
    const modDepth = depth / 100
    
    for (let i = 0; i < carrier.length; i++) {
      const modSignal = Math.sin(omega * i + phaseRad)
      const modulationFactor = 1 + modDepth * modSignal
      modulated.push(carrier[i] * modulationFactor)
    }
    
    return modulated
  }
  
  // é¢‘ç‡è°ƒåˆ¶ (FM)
  applyFrequencyModulation(
    baseConfig: WaveformConfig,
    modConfig: { frequency: number; deviation: number; phase: number }
  ): number[] {
    const { frequency: carrierFreq, amplitude, phase: carrierPhase, offset, samples } = baseConfig
    const { frequency: modFreq, deviation, phase: modPhase } = modConfig
    
    const data: number[] = []
    const modOmega = 2 * Math.PI * modFreq / this.sampleRate
    const modPhaseRad = (modPhase * Math.PI) / 180
    const carrierPhaseRad = (carrierPhase * Math.PI) / 180
    
    let phaseAccumulator = carrierPhaseRad
    
    for (let i = 0; i < samples; i++) {
      // è®¡ç®—è°ƒåˆ¶ä¿¡å·
      const modSignal = Math.sin(modOmega * i + modPhaseRad)
      
      // è®¡ç®—ç¬æ—¶é¢‘ç‡
      const instantFreq = carrierFreq + deviation * modSignal
      const instantOmega = 2 * Math.PI * instantFreq / this.sampleRate
      
      // ç´¯ç§¯ç›¸ä½
      phaseAccumulator += instantOmega
      
      // ç”Ÿæˆè°ƒåˆ¶åçš„ä¿¡å·
      const value = amplitude * Math.sin(phaseAccumulator) + offset
      data.push(value)
    }
    
    return data
  }
  
  // ç›¸ä½è°ƒåˆ¶ (PM)
  applyPhaseModulation(
    baseConfig: WaveformConfig,
    modConfig: { frequency: number; deviation: number; phase: number }
  ): number[] {
    const { frequency, amplitude, phase: carrierPhase, offset, samples } = baseConfig
    const { frequency: modFreq, deviation, phase: modPhase } = modConfig
    
    const data: number[] = []
    const omega = 2 * Math.PI * frequency / this.sampleRate
    const modOmega = 2 * Math.PI * modFreq / this.sampleRate
    const carrierPhaseRad = (carrierPhase * Math.PI) / 180
    const modPhaseRad = (modPhase * Math.PI) / 180
    const deviationRad = (deviation * Math.PI) / 180
    
    for (let i = 0; i < samples; i++) {
      // è®¡ç®—è°ƒåˆ¶ä¿¡å·
      const modSignal = Math.sin(modOmega * i + modPhaseRad)
      
      // è®¡ç®—ç¬æ—¶ç›¸ä½
      const instantPhase = omega * i + carrierPhaseRad + deviationRad * modSignal
      
      // ç”Ÿæˆè°ƒåˆ¶åçš„ä¿¡å·
      const value = amplitude * Math.sin(instantPhase) + offset
      data.push(value)
    }
    
    return data
  }
  
  // è„‰å®½è°ƒåˆ¶ (PWM)
  applyPulseWidthModulation(
    baseConfig: WaveformConfig & { baseDutyCycle: number },
    modConfig: { frequency: number; depth: number; phase: number }
  ): number[] {
    const { frequency, amplitude, phase, offset, samples, baseDutyCycle } = baseConfig
    const { frequency: modFreq, depth, phase: modPhase } = modConfig
    
    const data: number[] = []
    const period = this.sampleRate / frequency
    const phaseOffset = (phase / 360) * period
    const modOmega = 2 * Math.PI * modFreq / this.sampleRate
    const modPhaseRad = (modPhase * Math.PI) / 180
    const modDepth = depth / 100
    
    for (let i = 0; i < samples; i++) {
      // è®¡ç®—è°ƒåˆ¶ä¿¡å·
      const modSignal = Math.sin(modOmega * i + modPhaseRad)
      
      // è®¡ç®—ç¬æ—¶å ç©ºæ¯”
      const instantDutyCycle = baseDutyCycle + modDepth * modSignal * 50
      const clampedDutyCycle = Math.max(1, Math.min(99, instantDutyCycle))
      
      // ç”ŸæˆPWMä¿¡å·
      const adjustedIndex = (i + phaseOffset) % period
      const isHigh = adjustedIndex < (period * clampedDutyCycle / 100)
      const value = (isHigh ? amplitude : -amplitude) + offset
      data.push(value)
    }
    
    return data
  }
}
```

### æ‰«é¢‘ç³»ç»Ÿè¯¦è§£

#### æ‰«é¢‘æ§åˆ¶å™¨å®ç°
```typescript
class SweepController {
  private sweepConfig: SweepConfig = {
    enabled: false,
    startFreq: 100,
    stopFreq: 10000,
    duration: 5,
    type: 'linear'
  }
  
  private sweepState: {
    active: boolean
    startTime: number
    currentFreq: number
    direction: 'up' | 'down'
  } = {
    active: false,
    startTime: 0,
    currentFreq: 0,
    direction: 'up'
  }
  
  // å¯åŠ¨æ‰«é¢‘
  startSweep(): void {
    this.sweepState.active = true
    this.sweepState.startTime = Date.now()
    this.sweepState.currentFreq = this.sweepConfig.startFreq
    this.sweepState.direction = 'up'
    
    this.emit('sweepStarted', this.sweepConfig)
    this.scheduleSweepUpdate()
  }
  
  // åœæ­¢æ‰«é¢‘
  stopSweep(): void {
    this.sweepState.active = false
    this.emit('sweepStopped')
  }
  
  // æ›´æ–°æ‰«é¢‘é¢‘ç‡
  private scheduleSweepUpdate(): void {
    if (!this.sweepState.active) return
    
    const elapsed = Date.now() - this.sweepState.startTime
    const progress = Math.min(elapsed / (this.sweepConfig.duration * 1000), 1)
    
    let newFreq: number
    
    switch (this.sweepConfig.type) {
      case 'linear':
        newFreq = this.calculateLinearSweep(progress)
        break
      case 'logarithmic':
        newFreq = this.calculateLogarithmicSweep(progress)
        break
      default:
        newFreq = this.sweepConfig.startFreq
    }
    
    this.sweepState.currentFreq = newFreq
    this.emit('frequencyChange', newFreq)
    
    if (progress >= 1) {
      // æ‰«é¢‘å®Œæˆï¼Œé‡æ–°å¼€å§‹æˆ–åœæ­¢
      if (this.sweepConfig.continuous) {
        this.sweepState.startTime = Date.now()
        setTimeout(() => this.scheduleSweepUpdate(), 50)
      } else {
        this.stopSweep()
      }
    } else {
      setTimeout(() => this.scheduleSweepUpdate(), 50)
    }
  }
  
  // çº¿æ€§æ‰«é¢‘è®¡ç®—
  private calculateLinearSweep(progress: number): number {
    const { startFreq, stopFreq } = this.sweepConfig
    return startFreq + (stopFreq - startFreq) * progress
  }
  
  // å¯¹æ•°æ‰«é¢‘è®¡ç®—
  private calculateLogarithmicSweep(progress: number): number {
    const { startFreq, stopFreq } = this.sweepConfig
    const logStart = Math.log10(startFreq)
    const logStop = Math.log10(stopFreq)
    const logCurrent = logStart + (logStop - logStart) * progress
    return Math.pow(10, logCurrent)
  }
  
  // æ­¥è¿›æ‰«é¢‘
  performStepSweep(steps: number[]): void {
    let stepIndex = 0
    
    const nextStep = () => {
      if (stepIndex < steps.length && this.sweepState.active) {
        this.sweepState.currentFreq = steps[stepIndex]
        this.emit('frequencyChange', steps[stepIndex])
        stepIndex++
        
        setTimeout(nextStep, this.sweepConfig.stepDwell || 1000)
      } else {
        this.stopSweep()
      }
    }
    
    this.sweepState.active = true
    nextStep()
  }
  
  // åˆ—è¡¨æ‰«é¢‘
  performListSweep(frequencyList: Array<{ freq: number; dwell: number }>): void {
    let listIndex = 0
    
    const nextFrequency = () => {
      if (listIndex < frequencyList.length && this.sweepState.active) {
        const item = frequencyList[listIndex]
        this.sweepState.currentFreq = item.freq
        this.emit('frequencyChange', item.freq)
        listIndex++
        
        setTimeout(nextFrequency, item.dwell)
      } else {
        this.stopSweep()
      }
    }
    
    this.sweepState.active = true
    nextFrequency()
  }
  
  // è·å–å½“å‰é¢‘ç‡
  getCurrentFrequency(): number {
    return this.sweepState.currentFreq
  }
  
  // è®¾ç½®æ‰«é¢‘é…ç½®
  setSweepConfig(config: Partial<SweepConfig>): void {
    Object.assign(this.sweepConfig, config)
    this.emit('sweepConfigChange', this.sweepConfig)
  }
}
```

## ğŸ”Œ DataAcquisitionCard æ•°æ®é‡‡é›†å¡è¯¦è§£

### æ§ä»¶æ¶æ„

#### åŠŸèƒ½æ¨¡å—ç»„æˆ
```
æ•°æ®é‡‡é›†å¡
â”œâ”€â”€ é€šé“ç®¡ç†ç³»ç»Ÿ
â”‚   â”œâ”€â”€ æ¨¡æ‹Ÿè¾“å…¥é€šé“
â”‚   â”œâ”€â”€ æ•°å­—è¾“å…¥é€šé“
â”‚   â”œâ”€â”€ è®¡æ•°å™¨é€šé“
â”‚   â””â”€â”€ é€šé“é…ç½®ç®¡ç†
â”œâ”€â”€ é‡‡é›†æ§åˆ¶ç³»ç»Ÿ
â”‚   â”œâ”€â”€ é‡‡æ ·ç‡æ§åˆ¶
â”‚   â”œâ”€â”€ è§¦å‘æ§åˆ¶
â”‚   â”œâ”€â”€ æ—¶é’Ÿé…ç½®
â”‚   â””â”€â”€ åŒæ­¥æ§åˆ¶
â”œâ”€â”€ æ•°æ®å¤„ç†ç³»ç»Ÿ
â”‚   â”œâ”€â”€ å®æ—¶æ•°æ®æµ
â”‚   â”œâ”€â”€ æ•°æ®ç¼“å†²ç®¡ç†
â”‚   â”œâ”€â”€ æ•°æ®å‹ç¼©
â”‚   â””â”€â”€ æ•°æ®è´¨é‡æ£€æŸ¥
â”œâ”€â”€ æ ¡å‡†ç³»ç»Ÿ
â”‚   â”œâ”€â”€ è‡ªåŠ¨æ ¡å‡†
â”‚   â”œâ”€â”€ æ‰‹åŠ¨æ ¡å‡†
â”‚   â”œâ”€â”€ æ ¡å‡†æ•°æ®ç®¡ç†
â”‚   â””â”€â”€ æ¸©åº¦è¡¥å¿
â””â”€â”€ è¯Šæ–­ç³»ç»Ÿ
    â”œâ”€â”€ è‡ªæ£€åŠŸèƒ½
    â”œâ”€â”€ æ€§èƒ½ç›‘æ§
    â”œâ”€â”€ é”™è¯¯è¯Šæ–­
    â””â”€â”€ çŠ¶æ€æŠ¥å‘Š
```

#### æ ¸å¿ƒå±æ€§é…ç½®
```typescript
interface DataAcquisitionProps {
  channels: number              // é€šé“æ•°é‡
  maxSampleRate: number         // æœ€å¤§é‡‡æ ·ç‡
  resolution: number            // åˆ†è¾¨ç‡ (ä½)
  inputRange: [number, number]  // è¾“å…¥èŒƒå›´
  couplingTypes: string[]       // è€¦åˆç±»å‹
  triggerTypes: string[]        // è§¦å‘ç±»å‹
  bufferSize: number           // ç¼“å†²åŒºå¤§å°
}
```

### é€šé“ç®¡ç†ç³»ç»Ÿè¯¦è§£

#### é€šé“æ§åˆ¶å™¨å®ç°
```typescript
class ChannelManager {
  private channels: Map<number, ChannelConfig> = new Map()
  private channelGroups: Map<string, number[]> = new Map()
  
  constructor(channelCount: number) {
    this.initializeChannels(channelCount)
  }
  
  // åˆå§‹åŒ–é€šé“
  private initializeChannels(count: number): void {
    for (let i = 0; i < count; i++) {
      const channel: ChannelConfig = {
        index: i,
        enabled: false,
        name: `AI${i}`,
        range: 10, // Â±10V
        coupling: 'DC',
        offset: 0,
        unit: 'V',
        calibration: {
          gain: 1.0,
          offset: 0.0,
          lastCalibration: new Date()
        },
        filter: {
          enabled: false,
          type: 'lowpass',
          cutoff: 1000
        }
      }
      
      this.channels.set(i, channel)
    }
  }
  
  // é…ç½®é€šé“
  configureChannel(index: number, config: Partial<ChannelConfig>): void {
    const channel = this.channels.get(index)
    if (!channel) {
      throw new Error(`é€šé“ ${index} ä¸å­˜åœ¨`)
    }
    
    Object.assign(channel, config)
    this.validateChannelConfig(channel)
    this.applyChannelConfig(index, channel)
  }
  
  // å¯ç”¨é€šé“ç»„
  enableChannelGroup(groupName: string, channels: number[]): void {
    this.channelGroups.set(groupName, channels)
    
    channels.forEach(index => {
      const channel = this.channels.get(index)
      if (channel) {
        channel.enabled = true
        this.applyChannelConfig(index, channel)
      }
    })
  }
  
  // ç¦ç”¨é€šé“ç»„
  disableChannelGroup(groupName: string): void {
    const channels = this.channelGroups.get(groupName)
    if (channels) {
      channels.forEach(index => {
        const channel = this.channels.get(index)
        if (channel) {
          channel.enabled = false
          this.applyChannelConfig(index, channel)
        }
      })
    }
  }
  
  // è®¾ç½®é€šé“é‡ç¨‹
  setChannelRange(index: number, range: number): void {
    const channel = this.channels.get(index)
    if (channel) {
      channel.range = range
      this.updateChannelGain(index, range)
    }
  }
  
  // è®¾ç½®é€šé“è€¦åˆ
  setChannelCoupling(index: number, coupling: 'DC' | 'AC' | 'GND'): void {
    const channel = this.channels.get(index)
    if (channel) {
      channel.coupling = coupling
      this.updateChannelCoupling(index, coupling)
    }
  }
  
  // æ ¡å‡†é€šé“
  calibrateChannel(index: number, referenceValues: number[]): void {
    const channel = this.channels.get(index)
    if (!channel) return
    
    // æ‰§è¡Œæ ¡å‡†ç®—æ³•
    const calibration = this.performCalibration(referenceValues)
    channel.calibration = {
      ...calibration,
      lastCalibration: new Date()
    }
    
    this.emit('channelCalibrated', { index, calibration })
  }
  
  // è‡ªåŠ¨æ ¡å‡†æ‰€æœ‰é€šé“
  async autoCalibrate(): Promise<void> {
    const enabledChannels = Array.from(this.channels.entries())
      .filter(([_, channel]) => channel.enabled)
      .map(([index, _]) => index)
    
    for (const index of enabledChannels) {
      try {
        await this.performAutoCalibration(index)
      } catch (error) {
        console.error(`é€šé“ ${index} è‡ªåŠ¨æ ¡å‡†å¤±è´¥:`, error)
      }
    }
  }
  
  // éªŒè¯é€šé“é…ç½®
  private validateChannelConfig(channel: ChannelConfig): void {
    if (channel.range <= 0) {
      throw new Error('é€šé“é‡ç¨‹å¿…é¡»å¤§äº0')
    }
    
    if (!['DC', 'AC', 'GND'].includes(channel.coupling)) {
      throw new Error('æ— æ•ˆçš„è€¦åˆç±»å‹')
    }
  }
  
  // åº”ç”¨é€šé“é…ç½®
  private applyChannelConfig(index: number, channel: ChannelConfig): void {
    this.emit('channelConfigChanged', { index, config: channel })
  }
  
  // æ›´æ–°é€šé“å¢ç›Š
  private updateChannelGain(index: number, range: number): void {
    // æ ¹æ®é‡ç¨‹è®¡ç®—å¢ç›Š
    const maxADCValue = Math.pow(2, 16) - 1 // 16ä½ADC
    const gain = maxADCValue / (2 * range) // åŒææ€§
    
    this.emit('channelGainChanged', { index, gain })
  }
  
  // æ›´æ–°é€šé“è€¦åˆ
  private updateChannelCoupling(index: number, coupling: string): void {
    this.emit('channelCouplingChanged', { index, coupling })
  }
  
  // æ‰§è¡Œæ ¡å‡†
  private performCalibration(referenceValues: number[]): CalibrationData {
    // ç®€åŒ–çš„çº¿æ€§æ ¡å‡†ç®—æ³•
    // å®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„æ ¡å‡†ç®—æ³•
    
    if (referenceValues.length < 2) {
      throw new Error('æ ¡å‡†éœ€è¦è‡³å°‘2ä¸ªå‚è€ƒç‚¹')
    }
    
    // å‡è®¾å·²æœ‰å¯¹åº”çš„æµ‹é‡å€¼
    const measuredValues = referenceValues.map(ref => ref + (Math.random() - 0.5) * 0.01)
    
    // çº¿æ€§å›å½’è®¡ç®—å¢ç›Šå’Œåç§»
    const n = referenceValues.length
    const sumX = referenceValues.reduce((sum, val) => sum + val, 0)
    const sumY = measuredValues.reduce((sum, val) => sum + val, 0)
    const sumXY = referenceValues.reduce((sum, val, i) => sum + val * measuredValues[i], 0)
    const sumXX = referenceValues.reduce((sum, val) => sum + val * val, 0)
    
    const gain = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX)
    const offset = (sumY - gain * sumX) / n
    
    return { gain, offset }
  }
  
  // æ‰§è¡Œè‡ªåŠ¨æ ¡å‡†
  private async performAutoCalibration(index: number): Promise<void> {
    // è‡ªåŠ¨æ ¡å‡†æµç¨‹
    const referencePoints = [-10, -5, 0, 5, 10] // æ ‡å‡†å‚è€ƒç‚¹
    const measuredValues: number[] = []
    
    for (const refValue of referencePoints) {
      // åº”ç”¨å‚è€ƒç”µå‹å¹¶æµ‹é‡
      await this.applyReferenceVoltage(refValue)
      await this.delay(100) // ç­‰å¾…ç¨³å®š
      const measured = await this.measureChannel(index)
      measuredValues.push(measured)
    }
    
    // è®¡ç®—æ ¡å‡†å‚æ•°
    const calibration = this.performCalibration(referencePoints)
    const channel = this.channels.get(index)
    if (channel) {
      channel.calibration = {
        ...calibration,
        lastCalibration: new Date()
      }
    }
  }
  
  // è¾…åŠ©æ–¹æ³•
  private async applyReferenceVoltage(voltage: number): Promise<void> {
    // åº”ç”¨å‚è€ƒç”µå‹çš„å®ç°
    return new Promise(resolve => setTimeout(resolve, 50))
  }
  
  private async measureChannel(index: number): Promise<number> {
    // æµ‹é‡é€šé“å€¼çš„å®ç°
    return Math.random() * 20 - 10 // æ¨¡æ‹Ÿæµ‹é‡å€¼
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}
```

## ğŸ”§ å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

### ç¤ºæ³¢å™¨ä½¿ç”¨é—®é¢˜

**é—®é¢˜1ï¼šæ³¢å½¢æ˜¾ç¤ºä¸ç¨³å®š**
- **åŸå› **ï¼šè§¦å‘è®¾ç½®ä¸å½“æˆ–ä¿¡å·å™ªå£°è¿‡å¤§
- **è§£å†³æ–¹æ¡ˆ**ï¼š
  ```typescript
  // ä¼˜åŒ–è§¦å‘è®¾ç½®
  const optimizeTrigger = (signalLevel: number) => {
    const triggerLevel = signalLevel * 0.5 // è®¾ç½®ä¸ºä¿¡å·å¹…åº¦çš„50%
    const holdoffTime = 1 / frequency * 0.1 // è®¾ç½®é€‚å½“çš„è§¦å‘é‡ŠæŠ‘æ—¶é—´
    
    triggerController.setTriggerLevel(triggerLevel)
    triggerController.setHoldoffTime(holdoffTime)
    triggerController.setTriggerMode('normal') // ä½¿ç”¨æ­£å¸¸è§¦å‘æ¨¡å¼
  }
  ```

**é—®é¢˜2ï¼šæµ‹é‡ç»“æœä¸å‡†ç¡®**
- **åŸå› **ï¼šé‡‡æ ·ç‡ä¸è¶³æˆ–æ¢å¤´è¡¥å¿ä¸å½“
- **è§£å†³æ–¹æ¡ˆ**ï¼š
  ```typescript
  // ç¡®ä¿é‡‡æ ·ç‡æ»¡è¶³å¥ˆå¥æ–¯ç‰¹å®šç†
  const validateSampleRate = (signalFreq: number, sampleRate: number) => {
    const nyquistRate = signalFreq * 2
    if (sampleRate < nyquistRate * 10) {
      console.warn(`å»ºè®®é‡‡æ ·ç‡è‡³å°‘ä¸º ${nyquistRate * 10} Hz`)
      return false
    }
    return true
  }
  
  // æ¢å¤´è¡¥å¿
  const compensateProbe = (channelIndex: number, probeRatio: number) => {
    channelController.setChannelConfig(channelIndex, {
      probe: probeRatio,
      // æ ¹æ®æ¢å¤´ç±»å‹è°ƒæ•´å¸¦å®½é™åˆ¶
      bandwidth: probeRatio === 10 ? 100e6 : 0
    })
  }
  ```

### ä¿¡å·å‘ç”Ÿå™¨ä½¿ç”¨é—®é¢˜

**é—®é¢˜3ï¼šè¾“å‡ºä¿¡å·å¤±çœŸ**
- **åŸå› **ï¼šè¾“å‡ºè´Ÿè½½ä¸åŒ¹é…æˆ–é¢‘ç‡è¿‡é«˜
- **è§£å†³æ–¹æ¡ˆ**ï¼š
  ```typescript
  // è´Ÿè½½åŒ¹é…æ£€æŸ¥
  const checkLoadMatching = (outputImpedance: number, loadImpedance: number) => {
    const mismatchRatio = Math.abs(outputImpedance - loadImpedance) / outputImpedance
    if (mismatchRatio > 0.1) {
      console.warn('è´Ÿè½½é˜»æŠ—ä¸åŒ¹é…ï¼Œå¯èƒ½å¯¼è‡´ä¿¡å·åå°„')
      return false
    }
    return true
  }
  
  // é¢‘ç‡é™åˆ¶æ£€æŸ¥
  const validateFrequency = (frequency: number, maxFreq: number) => {
    if (frequency > maxFreq * 0.8) {
      console.warn('é¢‘ç‡æ¥è¿‘ä¸Šé™ï¼Œå¯èƒ½å½±å“ä¿¡å·è´¨é‡')
      return false
    }
    return true
  }
  ```

**é—®é¢˜4ï¼šè°ƒåˆ¶æ•ˆæœä¸æ˜æ˜¾**
- **åŸå› **ï¼šè°ƒåˆ¶æ·±åº¦è®¾ç½®è¿‡å°æˆ–è°ƒåˆ¶é¢‘ç‡ä¸å½“
- **è§£å†³æ–¹æ¡ˆ**ï¼š
  ```typescript
  // ä¼˜åŒ–è°ƒåˆ¶å‚æ•°
  const optimizeModulation = (carrierFreq: number, modType: string) => {
    let optimalModFreq: number
    let optimalDepth: number
    
    switch (modType) {
      case 'AM':
        optimalModFreq = carrierFreq / 10 // è½½æ³¢é¢‘ç‡çš„1/10
        optimalDepth = 50 // 50%è°ƒåˆ¶æ·±åº¦
        break
      case 'FM':
        optimalModFreq = carrierFreq / 20
        optimalDepth = carrierFreq * 0.1 // é¢‘åä¸ºè½½æ³¢é¢‘ç‡çš„10%
        break
      default:
        optimalModFreq = 1000
        optimalDepth = 30
    }
    
    return { frequency: optimalModFreq, depth: optimalDepth }
  }
  ```

### æ•°æ®é‡‡é›†é—®é¢˜

**é—®é¢˜5ï¼šæ•°æ®ä¸¢å¤±æˆ–é‡‡é›†ä¸­æ–­**
- **åŸå› **ï¼šç¼“å†²åŒºæº¢å‡ºæˆ–ç³»ç»Ÿèµ„æºä¸è¶³
- **è§£å†³æ–¹æ¡ˆ**ï¼š
  ```typescript
  // åŠ¨æ€ç¼“å†²åŒºç®¡ç†
  class AdaptiveBufferManager {
    private bufferSize: number = 10000
    private maxBufferSize: number = 100000
    private overflowCount: number = 0
    
    checkBufferHealth(currentUsage: number): void {
      const usageRatio = currentUsage / this.bufferSize
      
      if (usageRatio > 0.9) {
        this.overflowCount++
        if (this.overflowCount > 3 && this.bufferSize < this.maxBufferSize) {
          this.bufferSize *= 2
          console.log(`ç¼“å†²åŒºæ‰©å±•åˆ° ${this.bufferSize}`)
        }
      } else if (usageRatio < 0.3 && this.overflowCount === 0) {
        this.bufferSize = Math.max(this.bufferSize / 2, 1000)
        console.log(`ç¼“å†²åŒºç¼©å‡åˆ° ${this.bufferSize}`)
      }
    }
  }
  ```

**é—®é¢˜6ï¼šé‡‡é›†ç²¾åº¦ä¸è¶³**
- **åŸå› **ï¼šé‡ç¨‹è®¾ç½®ä¸å½“æˆ–æ ¡å‡†è¿‡æœŸ
- **è§£å†³æ–¹æ¡ˆ**ï¼š
  ```typescript
  // è‡ªåŠ¨é‡ç¨‹é€‰æ‹©
  const autoRangeSelection = (signalLevel: number): number => {
    const ranges = [0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100]
    
    // é€‰æ‹©èƒ½è¦†ç›–ä¿¡å·ä¸”åˆ©ç”¨ç‡æœ€é«˜çš„é‡ç¨‹
    for (const range of ranges) {
      if (signalLevel <= range * 0.8) {
        return range
      }
    }
    
    return ranges[ranges.length - 1]
  }
  
  // æ ¡å‡†çŠ¶æ€æ£€æŸ¥
  const checkCalibrationStatus = (lastCalibration: Date): boolean => {
    const now = new Date()
    const daysSinceCalibration = (now.getTime() - lastCalibration.getTime()) / (1000 * 60 * 60 * 24)
    
    if (daysSinceCalibration > 30) {
      console.warn('æ ¡å‡†å·²è¿‡æœŸï¼Œå»ºè®®é‡æ–°æ ¡å‡†')
      return false
    }
    
    return true
  }
  ```

## ğŸ“š æœ€ä½³å®è·µ

### è®¾è®¡åŸåˆ™

1. **æ¨¡å—åŒ–è®¾è®¡**ï¼šæ¯ä¸ªä»ªå™¨æ§ä»¶éƒ½é‡‡ç”¨æ¨¡å—åŒ–æ¶æ„ï¼Œä¾¿äºç»´æŠ¤å’Œæ‰©å±•
2. **æ ‡å‡†åŒ–æ¥å£**ï¼šç»Ÿä¸€çš„æ¥å£è®¾è®¡ï¼Œç¡®ä¿æ§ä»¶é—´çš„å…¼å®¹æ€§
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šé’ˆå¯¹å®æ—¶æ•°æ®å¤„ç†è¿›è¡Œä¸“é—¨ä¼˜åŒ–
4. **ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›ç›´è§‚çš„æ“ä½œç•Œé¢å’Œä¸°å¯Œçš„åé¦ˆä¿¡æ¯

### å¼€å‘å»ºè®®

1. **åˆç†é€‰æ‹©æ§ä»¶**ï¼šæ ¹æ®åº”ç”¨éœ€æ±‚é€‰æ‹©æœ€é€‚åˆçš„ä»ªå™¨æ§ä»¶
2. **ä¼˜åŒ–æ•°æ®æµ**ï¼šåˆç†è®¾è®¡æ•°æ®é‡‡é›†å’Œå¤„ç†æµç¨‹
3. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯æ£€æµ‹å’Œæ¢å¤æœºåˆ¶
4. **æ€§èƒ½ç›‘æ§**ï¼šå®æ—¶ç›‘æ§ç³»ç»Ÿæ€§èƒ½ï¼ŒåŠæ—¶å‘ç°é—®é¢˜

### é›†æˆæŒ‡å—

1. **ç¡¬ä»¶æ¥å£**ï¼šç¡®ä¿ç¡¬ä»¶é©±åŠ¨çš„æ­£ç¡®å®‰è£…å’Œé…ç½®
2. **è½¯ä»¶é…ç½®**ï¼šæ ¹æ®ç¡¬ä»¶ç‰¹æ€§è°ƒæ•´è½¯ä»¶å‚æ•°
3. **ç³»ç»Ÿæµ‹è¯•**ï¼šå…¨é¢æµ‹è¯•å„é¡¹åŠŸèƒ½çš„æ­£ç¡®æ€§
4. **æ–‡æ¡£ç»´æŠ¤**ï¼šä¿æŒæŠ€æœ¯æ–‡æ¡£çš„åŠæ—¶æ›´æ–°

## ğŸ”® æœªæ¥å‘å±•

### æŠ€æœ¯è¶‹åŠ¿

1. **AIé›†æˆ**ï¼šé›†æˆæœºå™¨å­¦ä¹ ç®—æ³•ï¼Œæä¾›æ™ºèƒ½åˆ†æåŠŸèƒ½
2. **äº‘ç«¯å¤„ç†**ï¼šæ”¯æŒäº‘ç«¯æ•°æ®å¤„ç†å’Œå­˜å‚¨
3. **ç§»åŠ¨ç«¯é€‚é…**ï¼šä¼˜åŒ–ç§»åŠ¨è®¾å¤‡ä¸Šçš„ä½¿ç”¨ä½“éªŒ
4. **åè®®æ‰©å±•**ï¼šæ”¯æŒæ›´å¤šçš„é€šä¿¡åè®®å’Œç¡¬ä»¶æ¥å£

### åŠŸèƒ½æ‰©å±•

1. **é«˜çº§åˆ†æ**ï¼šå¢åŠ æ›´å¤šä¸“ä¸šåˆ†æç®—æ³•
2. **è‡ªåŠ¨åŒ–æµ‹è¯•**ï¼šæ”¯æŒè‡ªåŠ¨åŒ–æµ‹è¯•åºåˆ—
3. **è¿œç¨‹æ§åˆ¶**ï¼šæ”¯æŒè¿œç¨‹ä»ªå™¨æ§åˆ¶å’Œç›‘æ§
4. **æ•°æ®æŒ–æ˜**ï¼šæä¾›å¤§æ•°æ®åˆ†æå’ŒæŒ–æ˜åŠŸèƒ½

---

*ä»ªå™¨æ§ä»¶æ˜¯è™šæ‹Ÿä»ªå™¨ç³»ç»Ÿçš„æ ¸å¿ƒï¼ŒæŒæ¡å…¶åŸç†å’Œä½¿ç”¨æ–¹æ³•å¯¹äºæ„å»ºä¸“ä¸šçš„æµ‹æ§ç³»ç»Ÿè‡³å…³é‡è¦ã€‚é€šè¿‡åˆç†çš„è®¾è®¡å’Œä¼˜åŒ–ï¼Œå¯ä»¥å®ç°ä¸ç¡¬ä»¶ä»ªå™¨ç›¸åª²ç¾çš„æ€§èƒ½å’ŒåŠŸèƒ½ã€‚*
