# ğŸ›ï¸ SeeSharpTools Web æ§åˆ¶å…ƒä»¶è¯¦è§£

## ğŸ“‹ æ§åˆ¶å…ƒä»¶æ¦‚è¿°

æ§åˆ¶å…ƒä»¶æ˜¯ç”¨æˆ·ä¸ç³»ç»Ÿäº¤äº’çš„æ ¸å¿ƒç•Œé¢ç»„ä»¶ï¼Œæä¾›äº†ä¸°å¯Œçš„ç”¨æˆ·è¾“å…¥å’Œæ§åˆ¶åŠŸèƒ½ã€‚SeeSharpTools Webçš„æ§åˆ¶å…ƒä»¶é‡‡ç”¨ç°ä»£åŒ–è®¾è®¡ç†å¿µï¼Œç»“åˆä¸“ä¸šæµ‹æ§ç³»ç»Ÿçš„ä½¿ç”¨ä¹ æƒ¯ï¼Œä¸ºç”¨æˆ·æä¾›ç›´è§‚ã€é«˜æ•ˆçš„æ“ä½œä½“éªŒã€‚

### ğŸ¯ è®¾è®¡ç†å¿µ
- **ä¸“ä¸šæ€§**ï¼šç¬¦åˆå·¥ä¸šæ§åˆ¶ç•Œé¢çš„è®¾è®¡æ ‡å‡†
- **æ˜“ç”¨æ€§**ï¼šç›´è§‚çš„æ“ä½œé€»è¾‘å’Œè§†è§‰åé¦ˆ
- **å¯é æ€§**ï¼šç¨³å®šçš„çŠ¶æ€ç®¡ç†å’Œé”™è¯¯å¤„ç†
- **å¯å®šåˆ¶æ€§**ï¼šä¸°å¯Œçš„æ ·å¼å’Œè¡Œä¸ºé…ç½®é€‰é¡¹

### ğŸ—ï¸ æ§ä»¶åˆ†ç±»ä½“ç³»
```
æ§åˆ¶å…ƒä»¶ç³»ç»Ÿ
â”œâ”€â”€ æŒ‰é’®æ§ä»¶ç±»
â”‚   â”œâ”€â”€ æ ‡å‡†æŒ‰é’® (StandardButton)
â”‚   â”œâ”€â”€ åˆ‡æ¢æŒ‰é’® (ToggleButton)
â”‚   â”œâ”€â”€ å›¾æ ‡æŒ‰é’® (IconButton)
â”‚   â””â”€â”€ æŒ‰é’®ç»„ (ButtonGroup)
â”œâ”€â”€ å¼€å…³æ§ä»¶ç±»
â”‚   â”œâ”€â”€ æ‹¨åŠ¨å¼€å…³ (ToggleSwitch)
â”‚   â”œâ”€â”€ æ—‹è½¬å¼€å…³ (RotarySwitch)
â”‚   â”œâ”€â”€ æŒ‰å‹å¼€å…³ (PushSwitch)
â”‚   â””â”€â”€ å¤šä½å¼€å…³ (MultiPositionSwitch)
â”œâ”€â”€ è¾“å…¥æ§ä»¶ç±»
â”‚   â”œâ”€â”€ æ•°å€¼è¾“å…¥æ¡† (NumericInput)
â”‚   â”œâ”€â”€ æ–‡æœ¬è¾“å…¥æ¡† (TextInput)
â”‚   â”œâ”€â”€ ä¸‹æ‹‰é€‰æ‹©æ¡† (ComboBox)
â”‚   â””â”€â”€ åˆ—è¡¨é€‰æ‹©å™¨ (ListSelector)
â”œâ”€â”€ æ»‘åŠ¨æ§ä»¶ç±»
â”‚   â”œâ”€â”€ çº¿æ€§æ»‘å— (LinearSlider)
â”‚   â”œâ”€â”€ æ—‹é’®æ§ä»¶ (RotaryKnob)
â”‚   â”œâ”€â”€ èŒƒå›´æ»‘å— (RangeSlider)
â”‚   â””â”€â”€ æ­¥è¿›æ»‘å— (StepSlider)
â”œâ”€â”€ æŒ‡ç¤ºæ§ä»¶ç±»
â”‚   â”œâ”€â”€ LEDæŒ‡ç¤ºç¯ (LEDIndicator)
â”‚   â”œâ”€â”€ çŠ¶æ€æŒ‡ç¤ºå™¨ (StatusIndicator)
â”‚   â”œâ”€â”€ è¿›åº¦æ¡ (ProgressBar)
â”‚   â””â”€â”€ æ´»åŠ¨æŒ‡ç¤ºå™¨ (ActivityIndicator)
â””â”€â”€ å®¹å™¨æ§ä»¶ç±»
    â”œâ”€â”€ é¢æ¿å®¹å™¨ (Panel)
    â”œâ”€â”€ é€‰é¡¹å¡ (TabControl)
    â”œâ”€â”€ åˆ†ç»„æ¡† (GroupBox)
    â””â”€â”€ å·¥å…·æ  (Toolbar)
```

## ğŸ”˜ æŒ‰é’®æ§ä»¶è¯¦è§£

### StandardButton æ ‡å‡†æŒ‰é’®

#### åŠŸèƒ½ç‰¹æ€§
- **å¤šç§æ ·å¼**ï¼šä¸»è¦ã€æ¬¡è¦ã€å±é™©ã€æˆåŠŸç­‰é¢„è®¾æ ·å¼
- **çŠ¶æ€ç®¡ç†**ï¼šæ­£å¸¸ã€æ‚¬åœã€æŒ‰ä¸‹ã€ç¦ç”¨çŠ¶æ€
- **å›¾æ ‡æ”¯æŒ**ï¼šæ”¯æŒå›¾æ ‡å’Œæ–‡å­—ç»„åˆæ˜¾ç¤º
- **å°ºå¯¸è§„æ ¼**ï¼šå°ã€ä¸­ã€å¤§ã€è¶…å¤§å››ç§å°ºå¯¸

#### æ ¸å¿ƒå®ç°
```typescript
interface ButtonProps {
  type?: 'primary' | 'secondary' | 'danger' | 'success' | 'warning' | 'info'
  size?: 'small' | 'medium' | 'large' | 'extra-large'
  disabled?: boolean
  loading?: boolean
  icon?: string
  iconPosition?: 'left' | 'right'
  block?: boolean
  ghost?: boolean
  shape?: 'default' | 'round' | 'circle'
}

class StandardButton extends Vue {
  @Prop({ default: 'primary' }) type!: string
  @Prop({ default: 'medium' }) size!: string
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: false }) loading!: boolean
  
  private isPressed: boolean = false
  private rippleEffect: boolean = false
  
  // æŒ‰é’®ç‚¹å‡»å¤„ç†
  handleClick(event: MouseEvent): void {
    if (this.disabled || this.loading) {
      event.preventDefault()
      return
    }
    
    this.triggerRippleEffect(event)
    this.emitClickEvent(event)
  }
  
  // æ¶Ÿæ¼ªæ•ˆæœ
  private triggerRippleEffect(event: MouseEvent): void {
    if (!this.rippleEffect) return
    
    const button = event.currentTarget as HTMLElement
    const rect = button.getBoundingClientRect()
    const size = Math.max(rect.width, rect.height)
    const x = event.clientX - rect.left - size / 2
    const y = event.clientY - rect.top - size / 2
    
    const ripple = document.createElement('span')
    ripple.className = 'button-ripple'
    ripple.style.cssText = `
      width: ${size}px;
      height: ${size}px;
      left: ${x}px;
      top: ${y}px;
    `
    
    button.appendChild(ripple)
    
    setTimeout(() => {
      ripple.remove()
    }, 600)
  }
  
  // å‘å°„ç‚¹å‡»äº‹ä»¶
  private emitClickEvent(event: MouseEvent): void {
    this.$emit('click', {
      originalEvent: event,
      timestamp: Date.now(),
      buttonType: this.type,
      buttonSize: this.size
    })
  }
  
  // é”®ç›˜äº‹ä»¶å¤„ç†
  handleKeydown(event: KeyboardEvent): void {
    if (event.code === 'Space' || event.code === 'Enter') {
      event.preventDefault()
      this.handleClick(event as any)
    }
  }
  
  // è·å–æŒ‰é’®æ ·å¼ç±»
  get buttonClasses(): string[] {
    return [
      'standard-button',
      `button-${this.type}`,
      `button-${this.size}`,
      {
        'button-disabled': this.disabled,
        'button-loading': this.loading,
        'button-block': this.block,
        'button-ghost': this.ghost,
        'button-pressed': this.isPressed
      }
    ]
  }
}
```

### ToggleButton åˆ‡æ¢æŒ‰é’®

#### åŠŸèƒ½ç‰¹æ€§
- **åŒæ€åˆ‡æ¢**ï¼šå¼€å¯/å…³é—­çŠ¶æ€åˆ‡æ¢
- **çŠ¶æ€ä¿æŒ**ï¼šè‡ªåŠ¨ç»´æŠ¤åˆ‡æ¢çŠ¶æ€
- **è§†è§‰åé¦ˆ**ï¼šæ¸…æ™°çš„çŠ¶æ€æŒ‡ç¤º
- **åˆ†ç»„æ”¯æŒ**ï¼šæ”¯æŒå•é€‰å’Œå¤šé€‰åˆ†ç»„

#### æ ¸å¿ƒå®ç°
```typescript
interface ToggleButtonProps extends ButtonProps {
  value?: boolean
  exclusive?: boolean
  groupName?: string
}

class ToggleButton extends StandardButton {
  @Prop({ default: false }) value!: boolean
  @Prop({ default: false }) exclusive!: boolean
  @Prop() groupName?: string
  
  private internalValue: boolean = false
  
  created(): void {
    this.internalValue = this.value
    
    // æ³¨å†Œåˆ°æŒ‰é’®ç»„
    if (this.groupName) {
      this.registerToGroup()
    }
  }
  
  // åˆ‡æ¢çŠ¶æ€
  toggle(): void {
    if (this.disabled) return
    
    if (this.exclusive && this.groupName) {
      this.handleExclusiveToggle()
    } else {
      this.internalValue = !this.internalValue
      this.emitChange()
    }
  }
  
  // å¤„ç†æ’ä»–æ€§åˆ‡æ¢
  private handleExclusiveToggle(): void {
    if (!this.internalValue) {
      // å–æ¶ˆç»„å†…å…¶ä»–æŒ‰é’®çš„é€‰ä¸­çŠ¶æ€
      this.clearGroupSelection()
      this.internalValue = true
      this.emitChange()
    }
  }
  
  // æ¸…é™¤ç»„å†…é€‰æ‹©
  private clearGroupSelection(): void {
    const groupButtons = this.getGroupButtons()
    groupButtons.forEach(button => {
      if (button !== this) {
        button.internalValue = false
        button.emitChange()
      }
    })
  }
  
  // æ³¨å†Œåˆ°æŒ‰é’®ç»„
  private registerToGroup(): void {
    if (!window.buttonGroups) {
      window.buttonGroups = new Map()
    }
    
    if (!window.buttonGroups.has(this.groupName)) {
      window.buttonGroups.set(this.groupName, new Set())
    }
    
    window.buttonGroups.get(this.groupName).add(this)
  }
  
  // è·å–ç»„å†…æŒ‰é’®
  private getGroupButtons(): ToggleButton[] {
    if (!this.groupName || !window.buttonGroups) return []
    
    const group = window.buttonGroups.get(this.groupName)
    return group ? Array.from(group) : []
  }
  
  // å‘å°„å˜åŒ–äº‹ä»¶
  private emitChange(): void {
    this.$emit('change', {
      value: this.internalValue,
      groupName: this.groupName,
      timestamp: Date.now()
    })
    
    this.$emit('input', this.internalValue)
  }
  
  // é‡å†™ç‚¹å‡»å¤„ç†
  handleClick(event: MouseEvent): void {
    super.handleClick(event)
    this.toggle()
  }
  
  // è·å–åˆ‡æ¢æŒ‰é’®æ ·å¼
  get toggleClasses(): string[] {
    return [
      ...this.buttonClasses,
      'toggle-button',
      {
        'toggle-active': this.internalValue,
        'toggle-exclusive': this.exclusive
      }
    ]
  }
}
```

## ğŸ”„ å¼€å…³æ§ä»¶è¯¦è§£

### ToggleSwitch æ‹¨åŠ¨å¼€å…³

#### åŠŸèƒ½ç‰¹æ€§
- **å¹³æ»‘åŠ¨ç”»**ï¼šæµç•…çš„åˆ‡æ¢åŠ¨ç”»æ•ˆæœ
- **è§¦æ‘¸æ”¯æŒ**ï¼šæ”¯æŒé¼ æ ‡å’Œè§¦æ‘¸æ“ä½œ
- **è‡ªå®šä¹‰æ ·å¼**ï¼šå¯é…ç½®é¢œè‰²ã€å°ºå¯¸ã€å½¢çŠ¶
- **çŠ¶æ€æŒ‡ç¤º**ï¼šæ¸…æ™°çš„å¼€å…³çŠ¶æ€æ˜¾ç¤º

#### æ ¸å¿ƒå®ç°
```typescript
interface ToggleSwitchProps {
  value?: boolean
  disabled?: boolean
  size?: 'small' | 'medium' | 'large'
  color?: string
  labels?: { on: string; off: string }
  loading?: boolean
}

class ToggleSwitch extends Vue {
  @Prop({ default: false }) value!: boolean
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: 'medium' }) size!: string
  @Prop({ default: '#1890ff' }) color!: string
  @Prop() labels?: { on: string; off: string }
  @Prop({ default: false }) loading!: boolean
  
  private internalValue: boolean = false
  private isDragging: boolean = false
  private startX: number = 0
  private currentX: number = 0
  private switchRef: HTMLElement | null = null
  
  mounted(): void {
    this.internalValue = this.value
    this.switchRef = this.$refs.switch as HTMLElement
    this.bindEvents()
  }
  
  beforeDestroy(): void {
    this.unbindEvents()
  }
  
  // ç»‘å®šäº‹ä»¶
  private bindEvents(): void {
    if (!this.switchRef) return
    
    // é¼ æ ‡äº‹ä»¶
    this.switchRef.addEventListener('mousedown', this.handleMouseDown)
    document.addEventListener('mousemove', this.handleMouseMove)
    document.addEventListener('mouseup', this.handleMouseUp)
    
    // è§¦æ‘¸äº‹ä»¶
    this.switchRef.addEventListener('touchstart', this.handleTouchStart, { passive: false })
    document.addEventListener('touchmove', this.handleTouchMove, { passive: false })
    document.addEventListener('touchend', this.handleTouchEnd)
  }
  
  // è§£ç»‘äº‹ä»¶
  private unbindEvents(): void {
    if (!this.switchRef) return
    
    this.switchRef.removeEventListener('mousedown', this.handleMouseDown)
    document.removeEventListener('mousemove', this.handleMouseMove)
    document.removeEventListener('mouseup', this.handleMouseUp)
    
    this.switchRef.removeEventListener('touchstart', this.handleTouchStart)
    document.removeEventListener('touchmove', this.handleTouchMove)
    document.removeEventListener('touchend', this.handleTouchEnd)
  }
  
  // é¼ æ ‡æŒ‰ä¸‹
  private handleMouseDown(event: MouseEvent): void {
    if (this.disabled || this.loading) return
    
    this.startDrag(event.clientX)
    event.preventDefault()
  }
  
  // è§¦æ‘¸å¼€å§‹
  private handleTouchStart(event: TouchEvent): void {
    if (this.disabled || this.loading) return
    
    this.startDrag(event.touches[0].clientX)
    event.preventDefault()
  }
  
  // å¼€å§‹æ‹–æ‹½
  private startDrag(clientX: number): void {
    this.isDragging = true
    this.startX = clientX
    this.currentX = clientX
    
    this.$emit('dragStart', {
      value: this.internalValue,
      timestamp: Date.now()
    })
  }
  
  // é¼ æ ‡ç§»åŠ¨
  private handleMouseMove(event: MouseEvent): void {
    if (!this.isDragging) return
    
    this.updateDrag(event.clientX)
  }
  
  // è§¦æ‘¸ç§»åŠ¨
  private handleTouchMove(event: TouchEvent): void {
    if (!this.isDragging) return
    
    this.updateDrag(event.touches[0].clientX)
    event.preventDefault()
  }
  
  // æ›´æ–°æ‹–æ‹½
  private updateDrag(clientX: number): void {
    this.currentX = clientX
    const deltaX = clientX - this.startX
    const threshold = 20 // æ‹–æ‹½é˜ˆå€¼
    
    if (Math.abs(deltaX) > threshold) {
      const newValue = deltaX > 0 ? true : false
      if (newValue !== this.internalValue) {
        this.internalValue = newValue
        this.emitChange()
      }
    }
  }
  
  // é¼ æ ‡é‡Šæ”¾
  private handleMouseUp(): void {
    this.endDrag()
  }
  
  // è§¦æ‘¸ç»“æŸ
  private handleTouchEnd(): void {
    this.endDrag()
  }
  
  // ç»“æŸæ‹–æ‹½
  private endDrag(): void {
    if (!this.isDragging) return
    
    this.isDragging = false
    
    // å¦‚æœæ‹–æ‹½è·ç¦»å¾ˆå°ï¼Œè§†ä¸ºç‚¹å‡»
    const deltaX = Math.abs(this.currentX - this.startX)
    if (deltaX < 5) {
      this.toggle()
    }
    
    this.$emit('dragEnd', {
      value: this.internalValue,
      timestamp: Date.now()
    })
  }
  
  // åˆ‡æ¢çŠ¶æ€
  toggle(): void {
    if (this.disabled || this.loading) return
    
    this.internalValue = !this.internalValue
    this.emitChange()
  }
  
  // å‘å°„å˜åŒ–äº‹ä»¶
  private emitChange(): void {
    this.$emit('change', {
      value: this.internalValue,
      timestamp: Date.now()
    })
    
    this.$emit('input', this.internalValue)
  }
  
  // ç‚¹å‡»å¤„ç†
  handleClick(): void {
    if (!this.isDragging) {
      this.toggle()
    }
  }
  
  // é”®ç›˜äº‹ä»¶å¤„ç†
  handleKeydown(event: KeyboardEvent): void {
    if (event.code === 'Space' || event.code === 'Enter') {
      event.preventDefault()
      this.toggle()
    }
  }
  
  // è·å–å¼€å…³æ ·å¼
  get switchClasses(): string[] {
    return [
      'toggle-switch',
      `switch-${this.size}`,
      {
        'switch-checked': this.internalValue,
        'switch-disabled': this.disabled,
        'switch-loading': this.loading,
        'switch-dragging': this.isDragging
      }
    ]
  }
  
  // è·å–æ»‘å—æ ·å¼
  get sliderStyle(): object {
    const baseStyle = {
      backgroundColor: this.internalValue ? this.color : '#ccc',
      transform: this.internalValue ? 'translateX(100%)' : 'translateX(0%)'
    }
    
    if (this.isDragging) {
      const progress = Math.max(0, Math.min(1, (this.currentX - this.startX) / 40))
      baseStyle.transform = `translateX(${progress * 100}%)`
    }
    
    return baseStyle
  }
}
```

### RotarySwitch æ—‹è½¬å¼€å…³

#### åŠŸèƒ½ç‰¹æ€§
- **å¤šä½ç½®æ”¯æŒ**ï¼šæ”¯æŒ2-12ä¸ªä½ç½®
- **è§’åº¦æ§åˆ¶**ï¼šç²¾ç¡®çš„è§’åº¦å®šä½
- **è§†è§‰æŒ‡ç¤º**ï¼šæ¸…æ™°çš„ä½ç½®æ ‡è¯†
- **å¹³æ»‘æ—‹è½¬**ï¼šæµç•…çš„æ—‹è½¬åŠ¨ç”»

#### æ ¸å¿ƒå®ç°
```typescript
interface RotarySwitchProps {
  positions: number
  value?: number
  disabled?: boolean
  size?: number
  labels?: string[]
  snapToPosition?: boolean
  continuous?: boolean
}

class RotarySwitch extends Vue {
  @Prop({ default: 8 }) positions!: number
  @Prop({ default: 0 }) value!: number
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: 100 }) size!: number
  @Prop() labels?: string[]
  @Prop({ default: true }) snapToPosition!: boolean
  @Prop({ default: false }) continuous!: boolean
  
  private currentPosition: number = 0
  private isDragging: boolean = false
  private startAngle: number = 0
  private currentAngle: number = 0
  private centerX: number = 0
  private centerY: number = 0
  
  mounted(): void {
    this.currentPosition = this.value
    this.currentAngle = this.positionToAngle(this.currentPosition)
    this.bindEvents()
  }
  
  beforeDestroy(): void {
    this.unbindEvents()
  }
  
  // ä½ç½®è½¬è§’åº¦
  private positionToAngle(position: number): number {
    const anglePerPosition = 360 / this.positions
    return position * anglePerPosition
  }
  
  // è§’åº¦è½¬ä½ç½®
  private angleToPosition(angle: number): number {
    const normalizedAngle = ((angle % 360) + 360) % 360
    const anglePerPosition = 360 / this.positions
    return Math.round(normalizedAngle / anglePerPosition) % this.positions
  }
  
  // ç»‘å®šäº‹ä»¶
  private bindEvents(): void {
    const element = this.$el as HTMLElement
    element.addEventListener('mousedown', this.handleMouseDown)
    document.addEventListener('mousemove', this.handleMouseMove)
    document.addEventListener('mouseup', this.handleMouseUp)
    
    element.addEventListener('touchstart', this.handleTouchStart, { passive: false })
    document.addEventListener('touchmove', this.handleTouchMove, { passive: false })
    document.addEventListener('touchend', this.handleTouchEnd)
  }
  
  // è§£ç»‘äº‹ä»¶
  private unbindEvents(): void {
    const element = this.$el as HTMLElement
    element.removeEventListener('mousedown', this.handleMouseDown)
    document.removeEventListener('mousemove', this.handleMouseMove)
    document.removeEventListener('mouseup', this.handleMouseUp)
    
    element.removeEventListener('touchstart', this.handleTouchStart)
    document.removeEventListener('touchmove', this.handleTouchMove)
    document.removeEventListener('touchend', this.handleTouchEnd)
  }
  
  // é¼ æ ‡æŒ‰ä¸‹
  private handleMouseDown(event: MouseEvent): void {
    if (this.disabled) return
    
    this.startDrag(event.clientX, event.clientY)
    event.preventDefault()
  }
  
  // è§¦æ‘¸å¼€å§‹
  private handleTouchStart(event: TouchEvent): void {
    if (this.disabled) return
    
    const touch = event.touches[0]
    this.startDrag(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // å¼€å§‹æ‹–æ‹½
  private startDrag(clientX: number, clientY: number): void {
    const rect = (this.$el as HTMLElement).getBoundingClientRect()
    this.centerX = rect.left + rect.width / 2
    this.centerY = rect.top + rect.height / 2
    
    this.isDragging = true
    this.startAngle = this.calculateAngle(clientX, clientY)
  }
  
  // è®¡ç®—è§’åº¦
  private calculateAngle(clientX: number, clientY: number): number {
    const deltaX = clientX - this.centerX
    const deltaY = clientY - this.centerY
    return Math.atan2(deltaY, deltaX) * 180 / Math.PI
  }
  
  // é¼ æ ‡ç§»åŠ¨
  private handleMouseMove(event: MouseEvent): void {
    if (!this.isDragging) return
    
    this.updateDrag(event.clientX, event.clientY)
  }
  
  // è§¦æ‘¸ç§»åŠ¨
  private handleTouchMove(event: TouchEvent): void {
    if (!this.isDragging) return
    
    const touch = event.touches[0]
    this.updateDrag(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // æ›´æ–°æ‹–æ‹½
  private updateDrag(clientX: number, clientY: number): void {
    const currentAngle = this.calculateAngle(clientX, clientY)
    let deltaAngle = currentAngle - this.startAngle
    
    // å¤„ç†è§’åº¦è·¨è¶Š
    if (deltaAngle > 180) deltaAngle -= 360
    if (deltaAngle < -180) deltaAngle += 360
    
    this.currentAngle += deltaAngle
    this.startAngle = currentAngle
    
    if (this.snapToPosition) {
      const newPosition = this.angleToPosition(this.currentAngle)
      if (newPosition !== this.currentPosition) {
        this.setPosition(newPosition)
      }
    }
  }
  
  // é¼ æ ‡é‡Šæ”¾
  private handleMouseUp(): void {
    this.endDrag()
  }
  
  // è§¦æ‘¸ç»“æŸ
  private handleTouchEnd(): void {
    this.endDrag()
  }
  
  // ç»“æŸæ‹–æ‹½
  private endDrag(): void {
    if (!this.isDragging) return
    
    this.isDragging = false
    
    if (this.snapToPosition) {
      const finalPosition = this.angleToPosition(this.currentAngle)
      this.setPosition(finalPosition)
      this.currentAngle = this.positionToAngle(finalPosition)
    }
  }
  
  // è®¾ç½®ä½ç½®
  setPosition(position: number): void {
    if (position === this.currentPosition) return
    
    const clampedPosition = Math.max(0, Math.min(this.positions - 1, position))
    this.currentPosition = clampedPosition
    this.currentAngle = this.positionToAngle(clampedPosition)
    
    this.$emit('change', {
      position: clampedPosition,
      angle: this.currentAngle,
      label: this.labels?.[clampedPosition],
      timestamp: Date.now()
    })
    
    this.$emit('input', clampedPosition)
  }
  
  // è·å–æ—‹é’®æ ·å¼
  get knobStyle(): object {
    return {
      transform: `rotate(${this.currentAngle}deg)`,
      transition: this.isDragging ? 'none' : 'transform 0.2s ease'
    }
  }
  
  // è·å–ä½ç½®æ ‡è®°
  get positionMarkers(): Array<{ angle: number; label: string; active: boolean }> {
    const markers = []
    for (let i = 0; i < this.positions; i++) {
      markers.push({
        angle: this.positionToAngle(i),
        label: this.labels?.[i] || `${i + 1}`,
        active: i === this.currentPosition
      })
    }
    return markers
  }
}
```

## ğŸ”¢ è¾“å…¥æ§ä»¶è¯¦è§£

### NumericInput æ•°å€¼è¾“å…¥æ¡†

#### åŠŸèƒ½ç‰¹æ€§
- **æ•°å€¼éªŒè¯**ï¼šå®æ—¶æ•°å€¼æ ¼å¼éªŒè¯
- **èŒƒå›´é™åˆ¶**ï¼šæœ€å°å€¼ã€æœ€å¤§å€¼é™åˆ¶
- **ç²¾åº¦æ§åˆ¶**ï¼šå°æ•°ä½æ•°æ§åˆ¶
- **å•ä½æ”¯æŒ**ï¼šæ•°å€¼å•ä½æ˜¾ç¤ºå’Œè½¬æ¢
- **æ­¥è¿›æ§åˆ¶**ï¼šé”®ç›˜å’ŒæŒ‰é’®æ­¥è¿›è°ƒèŠ‚

#### æ ¸å¿ƒå®ç°
```typescript
interface NumericInputProps {
  value?: number
  min?: number
  max?: number
  step?: number
  precision?: number
  unit?: string
  disabled?: boolean
  readonly?: boolean
  placeholder?: string
  showControls?: boolean
  format?: 'decimal' | 'scientific' | 'engineering'
}

class NumericInput extends Vue {
  @Prop() value?: number
  @Prop() min?: number
  @Prop() max?: number
  @Prop({ default: 1 }) step!: number
  @Prop() precision?: number
  @Prop() unit?: string
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: false }) readonly!: boolean
  @Prop() placeholder?: string
  @Prop({ default: true }) showControls!: boolean
  @Prop({ default: 'decimal' }) format!: string
  
  private internalValue: number | null = null
  private displayValue: string = ''
  private isFocused: boolean = false
  private isValid: boolean = true
  private validationMessage: string = ''
  
  created(): void {
    this.internalValue = this.value || null
    this.updateDisplayValue()
  }
  
  watch: {
    value(newValue: number): void {
      this.internalValue = newValue
      this.updateDisplayValue()
    }
  }
  
  // æ›´æ–°æ˜¾ç¤ºå€¼
  private updateDisplayValue(): void {
    if (this.internalValue === null || this.internalValue === undefined) {
      this.displayValue = ''
      return
    }
    
    switch (this.format) {
      case 'scientific':
        this.displayValue = this.internalValue.toExponential(this.precision)
        break
      case 'engineering':
        this.displayValue = this.formatEngineering(this.internalValue)
        break
      default:
        this.displayValue = this.precision !== undefined 
          ? this.internalValue.toFixed(this.precision)
          : this.internalValue.toString()
    }
  }
  
  // å·¥ç¨‹è®¡æ•°æ³•æ ¼å¼åŒ–
  private formatEngineering(value: number): string {
    if (value === 0) return '0'
    
    const exponent = Math.floor(Math.log10(Math.abs(value)))
    const engineeringExponent = Math.floor(exponent / 3) * 3
    const mantissa = value / Math.pow(10, engineeringExponent)
    
    const precision = this.precision !== undefined ? this.precision : 3
    return `${mantissa.toFixed(precision)}e${engineeringExponent}`
  }
  
  // è¾“å…¥å¤„ç†
  handleInput(event: Event): void {
    const target = event.target as HTMLInputElement
    const inputValue = target.value
    
    this.displayValue = inputValue
    
    if (inputValue === '') {
      this.internalValue = null
      this.isValid = true
      this.emitChange()
      return
    }
    
    const numericValue = this.parseNumericValue(inputValue)
    
    if (numericValue !== null) {
      const validatedValue = this.validateValue(numericValue)
      if (validatedValue.isValid) {
        this.internalValue = validatedValue.value
        this.isValid = true
        this.validationMessage = ''
      } else {
        this.isValid = false
        this.validationMessage = validatedValue.message
      }
    } else {
      this.isValid = false
      this.validationMessage = 'æ— æ•ˆçš„æ•°å€¼æ ¼å¼'
    }
  }
  
  // è§£ææ•°å€¼
  private parseNumericValue(input: string): number | null {
    // ç§»é™¤å•ä½
    let cleanInput = input
    if (this.unit) {
      cleanInput = input.replace(new RegExp(this.unit + '$'), '').trim()
    }
    
    // è§£æç§‘å­¦è®¡æ•°æ³•
    const scientificMatch = cleanInput.match(/^([+-]?\d*\.?\d+)[eE]([+-]?\d+)$/)
    if (scientificMatch) {
      return parseFloat(cleanInput)
    }
    
    // è§£ææ™®é€šæ•°å€¼
    const numericMatch = cleanInput.match(/^[+-]?\d*\.?\d+$/)
    if (numericMatch) {
      return parseFloat(cleanInput)
    }
    
    return null
  }
  
  // éªŒè¯æ•°å€¼
  private validateValue(value: number): { isValid: boolean; value: number; message: string } {
    if (isNaN(value)) {
      return { isValid: false, value, message: 'æ— æ•ˆçš„æ•°å€¼' }
    }
    
    if (this.min !== undefined && value < this.min) {
      return { isValid: false, value, message: `å€¼ä¸èƒ½å°äº ${this.min}` }
    }
    
    if (this.max !== undefined && value > this.max) {
      return { isValid: false, value, message: `å€¼ä¸èƒ½å¤§äº ${this.max}` }
    }
    
    // åº”ç”¨ç²¾åº¦é™åˆ¶
    let finalValue = value
    if (this.precision !== undefined) {
      finalValue = parseFloat(value.toFixed(this.precision))
    }
    
    return { isValid: true, value: finalValue, message: '' }
  }
  
  // ç„¦ç‚¹å¤„ç†
  handleFocus(): void {
    this.isFocused = true
    
    // ç„¦ç‚¹æ—¶æ˜¾ç¤ºåŸå§‹æ•°å€¼
    if (this.internalValue !== null) {
      this.displayValue = this.internalValue.toString()
    }
  }
  
  // å¤±ç„¦å¤„ç†
  handleBlur(): void {
    this.isFocused = false
    
    if (this.isValid && this.internalValue !== null) {
      this.updateDisplayValue()
      this.emitChange()
    } else if (!this.isValid) {
      // æ¢å¤åˆ°ä¸Šä¸€ä¸ªæœ‰æ•ˆå€¼
      this.updateDisplayValue()
    }
  }
  
  // é”®ç›˜äº‹ä»¶å¤„ç†
  handleKeydown(event: KeyboardEvent): void {
    if (this.disabled || this.readonly) return
    
    switch (event.code) {
      case 'ArrowUp':
        event.preventDefault()
        this.increment()
        break
      case 'ArrowDown':
        event.preventDefault()
        this.decrement()
        break
      case 'Enter':
        this.handleBlur()
        break
    }
  }
  
  // å¢åŠ æ•°å€¼
  increment(): void {
    if (this.internalValue === null) {
      this.internalValue = this.min || 0
    } else {
      this.internalValue += this.step
    }
    
    const validated = this.validateValue(this.internalValue)
    if (validated.isValid) {
      this.internalValue = validated.value
      this.updateDisplayValue()
      this.emitChange()
    }
  }
  
  // å‡å°‘æ•°å€¼
  decrement(): void {
    if (this.internalValue === null) {
      this.internalValue = this.max || 0
    } else {
      this.internalValue -= this.step
    }
    
    const validated = this.validateValue(this.internalValue)
    if (validated.isValid) {
      this.internalValue = validated.value
      this.updateDisplayValue()
      this.emitChange()
    }
  }
  
  // å‘å°„å˜åŒ–äº‹ä»¶
  private emitChange(): void {
    this.$emit('change', {
      value: this.internalValue,
      displayValue: this.displayValue,
      isValid: this.isValid,
      timestamp: Date.now()
    })
    
    this.$emit('input', this.internalValue)
  }
  
  // è·å–è¾“å…¥æ¡†æ ·å¼
  get inputClasses(): string[] {
    return [
      'numeric-input',
      {
        'input-focused': this.isFocused,
        'input-disabled': this.disabled,
        'input-readonly': this.readonly,
        'input-invalid': !this.isValid,
        'input-has-controls': this.showControls
      }
    ]
  }
}
```

## ğŸšï¸ æ»‘åŠ¨æ§ä»¶è¯¦è§£

### LinearSlider çº¿æ€§æ»‘å—

#### åŠŸèƒ½ç‰¹æ€§
- **ç²¾ç¡®æ§åˆ¶**ï¼šæ”¯æŒè¿ç»­å’Œç¦»æ•£å€¼è°ƒèŠ‚
- **åŒå‘æ»‘åŠ¨**ï¼šæ°´å¹³å’Œå‚ç›´æ–¹å‘æ”¯æŒ
- **èŒƒå›´æ ‡è®°**ï¼šå¯è§†åŒ–çš„æ•°å€¼èŒƒå›´æ˜¾ç¤º
- **å®æ—¶åé¦ˆ**ï¼šæ‹–æ‹½è¿‡ç¨‹ä¸­çš„å®æ—¶æ•°å€¼æ›´æ–°

#### æ ¸å¿ƒå®ç°
```typescript
interface LinearSliderProps {
  value?: number
  min?: number
  max?: number
  step?: number
  orientation?: 'horizontal' | 'vertical'
  disabled?: boolean
  showTicks?: boolean
  showTooltip?: boolean
  marks?: Array<{ value: number; label: string }>
}

class LinearSlider extends Vue {
  @Prop({ default: 0 }) value!: number
  @Prop({ default: 0 }) min!: number
  @Prop({ default: 100 }) max!: number
  @Prop({ default: 1 }) step!: number
  @Prop({ default: 'horizontal' }) orientation!: string
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: false }) showTicks!: boolean
  @Prop({ default: true }) showTooltip!: boolean
  @Prop() marks?: Array<{ value: number; label: string }>
  
  private internalValue: number = 0
  private isDragging: boolean = false
  private sliderRect: DOMRect | null = null
  private tooltipVisible: boolean = false
  
  mounted(): void {
    this.internalValue = this.clampValue(this.value)
    this.bindEvents()
  }
  
  beforeDestroy(): void {
    this.unbindEvents()
  }
  
  // é™åˆ¶æ•°å€¼èŒƒå›´
  private clampValue(value: number): number {
    return Math.max(this.min, Math.min(this.max, value))
  }
  
  // å¯¹é½åˆ°æ­¥è¿›å€¼
  private snapToStep(value: number): number {
    const steps = Math.round((value - this.min) / this.step)
    return this.min + steps * this.step
  }
  
  // ç»‘å®šäº‹ä»¶
  private bindEvents(): void {
    const slider = this.$refs.slider as HTMLElement
    slider.addEventListener('mousedown', this.handleMouseDown)
    document.addEventListener('mousemove', this.handleMouseMove)
    document.addEventListener('mouseup', this.handleMouseUp)
    
    slider.addEventListener('touchstart', this.handleTouchStart, { passive: false })
    document.addEventListener('touchmove', this.handleTouchMove, { passive: false })
    document.addEventListener('touchend', this.handleTouchEnd)
  }
  
  // è§£ç»‘äº‹ä»¶
  private unbindEvents(): void {
    const slider = this.$refs.slider as HTMLElement
    slider.removeEventListener('mousedown', this.handleMouseDown)
    document.removeEventListener('mousemove', this.handleMouseMove)
    document.removeEventListener('mouseup', this.handleMouseUp)
    
    slider.removeEventListener('touchstart', this.handleTouchStart)
    document.removeEventListener('touchmove', this.handleTouchMove)
    document.removeEventListener('touchend', this.handleTouchEnd)
  }
  
  // é¼ æ ‡æŒ‰ä¸‹
  private handleMouseDown(event: MouseEvent): void {
    if (this.disabled) return
    
    this.startDrag(event.clientX, event.clientY)
    event.preventDefault()
  }
  
  // è§¦æ‘¸å¼€å§‹
  private handleTouchStart(event: TouchEvent): void {
    if (this.disabled) return
    
    const touch = event.touches[0]
    this.startDrag(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // å¼€å§‹æ‹–æ‹½
  private startDrag(clientX: number, clientY: number): void {
    this.isDragging = true
    this.tooltipVisible = true
    this.sliderRect = (this.$refs.slider as HTMLElement).getBoundingClientRect()
    
    this.updateValueFromPosition(clientX, clientY)
    
    this.$emit('dragStart', {
      value: this.internalValue,
      timestamp: Date.now()
    })
  }
  
  // é¼ æ ‡ç§»åŠ¨
  private handleMouseMove(event: MouseEvent): void {
    if (!this.isDragging) return
    
    this.updateValueFromPosition(event.clientX, event.clientY)
  }
  
  // è§¦æ‘¸ç§»åŠ¨
  private handleTouchMove(event: TouchEvent): void {
    if (!this.isDragging) return
    
    const touch = event.touches[0]
    this.updateValueFromPosition(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // ä»ä½ç½®æ›´æ–°æ•°å€¼
  private updateValueFromPosition(clientX: number, clientY: number): void {
    if (!this.sliderRect) return
    
    let progress: number
    
    if (this.orientation === 'horizontal') {
      progress = (clientX - this.sliderRect.left) / this.sliderRect.width
    } else {
      progress = 1 - (clientY - this.sliderRect.top) / this.sliderRect.height
    }
    
    progress = Math.max(0, Math.min(1, progress))
    
    const rawValue = this.min + progress * (this.max - this.min)
    const steppedValue = this.snapToStep(rawValue)
    
    if (steppedValue !== this.internalValue) {
      this.internalValue = steppedValue
      this.emitChange()
    }
  }
  
  // é¼ æ ‡é‡Šæ”¾
  private handleMouseUp(): void {
    this.endDrag()
  }
  
  // è§¦æ‘¸ç»“æŸ
  private handleTouchEnd(): void {
    this.endDrag()
  }
  
  // ç»“æŸæ‹–æ‹½
  private endDrag(): void {
    if (!this.isDragging) return
    
    this.isDragging = false
    this.tooltipVisible = false
    
    this.$emit('dragEnd', {
      value: this.internalValue,
      timestamp: Date.now()
    })
  }
  
  // ç‚¹å‡»è½¨é“
  handleTrackClick(event: MouseEvent): void {
    if (this.disabled || this.isDragging) return
    
    this.sliderRect = (this.$refs.slider as HTMLElement).getBoundingClientRect()
    this.updateValueFromPosition(event.clientX, event.clientY)
  }
  
  // é”®ç›˜äº‹ä»¶å¤„ç†
  handleKeydown(event: KeyboardEvent): void {
    if (this.disabled) return
    
    let newValue = this.internalValue
    
    switch (event.code) {
      case 'ArrowRight':
      case 'ArrowUp':
        newValue += this.step
        break
      case 'ArrowLeft':
      case 'ArrowDown':
        newValue -= this.step
        break
      case 'Home':
        newValue = this.min
        break
      case 'End':
        newValue = this.max
        break
      case 'PageUp':
        newValue += this.step * 10
        break
      case 'PageDown':
        newValue -= this.step * 10
        break
      default:
        return
    }
    
    event.preventDefault()
    this.internalValue = this.clampValue(newValue)
    this.emitChange()
  }
  
  // å‘å°„å˜åŒ–äº‹ä»¶
  private emitChange(): void {
    this.$emit('change', {
      value: this.internalValue,
      percentage: this.valueToPercentage(this.internalValue),
      timestamp: Date.now()
    })
    
    this.$emit('input', this.internalValue)
  }
  
  // æ•°å€¼è½¬ç™¾åˆ†æ¯”
  private valueToPercentage(value: number): number {
    return ((value - this.min) / (this.max - this.min)) * 100
  }
  
  // è·å–æ»‘å—ä½ç½®
  get thumbPosition(): number {
    return this.valueToPercentage(this.internalValue)
  }
  
  // è·å–åˆ»åº¦æ ‡è®°
  get tickMarks(): Array<{ position: number; value: number; label?: string }> {
    const ticks = []
    
    if (this.marks) {
      // ä½¿ç”¨è‡ªå®šä¹‰æ ‡è®°
      for (const mark of this.marks) {
        if (mark.value >= this.min && mark.value <= this.max) {
          ticks.push({
            position: this.valueToPercentage(mark.value),
            value: mark.value,
            label: mark.label
          })
        }
      }
    } else if (this.showTicks) {
      // è‡ªåŠ¨ç”Ÿæˆåˆ»åº¦
      const tickCount = Math.min(10, (this.max - this.min) / this.step + 1)
      const tickStep = (this.max - this.min) / (tickCount - 1)
      
      for (let i = 0; i < tickCount; i++) {
        const value = this.min + i * tickStep
        ticks.push({
          position: this.valueToPercentage(value),
          value: value,
          label: value.toString()
        })
      }
    }
    
    return ticks
  }
  
  // è·å–æ»‘å—æ ·å¼
  get sliderClasses(): string[] {
    return [
      'linear-slider',
      `slider-${this.orientation}`,
      {
        'slider-disabled': this.disabled,
        'slider-dragging': this.isDragging
      }
    ]
  }
}
```

### RotaryKnob æ—‹é’®æ§ä»¶

#### åŠŸèƒ½ç‰¹æ€§
- **360åº¦æ—‹è½¬**ï¼šæ”¯æŒè¿ç»­å’Œæœ‰é™è§’åº¦æ—‹è½¬
- **ç²¾å¯†æ§åˆ¶**ï¼šé«˜ç²¾åº¦çš„æ•°å€¼è°ƒèŠ‚
- **è§†è§‰åé¦ˆ**ï¼šæ¸…æ™°çš„è§’åº¦å’Œæ•°å€¼æŒ‡ç¤º
- **å¤šç§æ ·å¼**ï¼šç°ä»£åŒ–å’Œç»å…¸ä»ªè¡¨ç›˜æ ·å¼

#### æ ¸å¿ƒå®ç°
```typescript
interface RotaryKnobProps {
  value?: number
  min?: number
  max?: number
  step?: number
  size?: number
  disabled?: boolean
  continuous?: boolean
  startAngle?: number
  endAngle?: number
  showValue?: boolean
  unit?: string
}

class RotaryKnob extends Vue {
  @Prop({ default: 0 }) value!: number
  @Prop({ default: 0 }) min!: number
  @Prop({ default: 100 }) max!: number
  @Prop({ default: 1 }) step!: number
  @Prop({ default: 120 }) size!: number
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: false }) continuous!: boolean
  @Prop({ default: -135 }) startAngle!: number
  @Prop({ default: 135 }) endAngle!: number
  @Prop({ default: true }) showValue!: boolean
  @Prop() unit?: string
  
  private internalValue: number = 0
  private isDragging: boolean = false
  private lastAngle: number = 0
  private centerX: number = 0
  private centerY: number = 0
  private totalRotation: number = 0
  
  mounted(): void {
    this.internalValue = this.clampValue(this.value)
    this.updateAngleFromValue()
    this.bindEvents()
  }
  
  beforeDestroy(): void {
    this.unbindEvents()
  }
  
  // é™åˆ¶æ•°å€¼èŒƒå›´
  private clampValue(value: number): number {
    return Math.max(this.min, Math.min(this.max, value))
  }
  
  // ä»æ•°å€¼æ›´æ–°è§’åº¦
  private updateAngleFromValue(): void {
    const progress = (this.internalValue - this.min) / (this.max - this.min)
    const angleRange = this.endAngle - this.startAngle
    this.totalRotation = this.startAngle + progress * angleRange
  }
  
  // ä»è§’åº¦æ›´æ–°æ•°å€¼
  private updateValueFromAngle(): void {
    let normalizedAngle = this.totalRotation
    
    if (!this.continuous) {
      // é™åˆ¶è§’åº¦èŒƒå›´
      normalizedAngle = Math.max(this.startAngle, Math.min(this.endAngle, normalizedAngle))
    }
    
    const angleRange = this.endAngle - this.startAngle
    const progress = (normalizedAngle - this.startAngle) / angleRange
    const rawValue = this.min + progress * (this.max - this.min)
    const steppedValue = this.snapToStep(rawValue)
    
    if (steppedValue !== this.internalValue) {
      this.internalValue = this.clampValue(steppedValue)
      this.emitChange()
    }
  }
  
  // å¯¹é½åˆ°æ­¥è¿›å€¼
  private snapToStep(value: number): number {
    const steps = Math.round((value - this.min) / this.step)
    return this.min + steps * this.step
  }
  
  // ç»‘å®šäº‹ä»¶
  private bindEvents(): void {
    const knob = this.$refs.knob as HTMLElement
    knob.addEventListener('mousedown', this.handleMouseDown)
    document.addEventListener('mousemove', this.handleMouseMove)
    document.addEventListener('mouseup', this.handleMouseUp)
    
    knob.addEventListener('touchstart', this.handleTouchStart, { passive: false })
    document.addEventListener('touchmove', this.handleTouchMove, { passive: false })
    document.addEventListener('touchend', this.handleTouchEnd)
    
    knob.addEventListener('wheel', this.handleWheel, { passive: false })
  }
  
  // è§£ç»‘äº‹ä»¶
  private unbindEvents(): void {
    const knob = this.$refs.knob as HTMLElement
    knob.removeEventListener('mousedown', this.handleMouseDown)
    document.removeEventListener('mousemove', this.handleMouseMove)
    document.removeEventListener('mouseup', this.handleMouseUp)
    
    knob.removeEventListener('touchstart', this.handleTouchStart)
    document.removeEventListener('touchmove', this.handleTouchMove)
    document.removeEventListener('touchend', this.handleTouchEnd)
    
    knob.removeEventListener('wheel', this.handleWheel)
  }
  
  // è®¡ç®—è§’åº¦
  private calculateAngle(clientX: number, clientY: number): number {
    const deltaX = clientX - this.centerX
    const deltaY = clientY - this.centerY
    return Math.atan2(deltaY, deltaX) * 180 / Math.PI
  }
  
  // é¼ æ ‡æŒ‰ä¸‹
  private handleMouseDown(event: MouseEvent): void {
    if (this.disabled) return
    
    this.startDrag(event.clientX, event.clientY)
    event.preventDefault()
  }
  
  // è§¦æ‘¸å¼€å§‹
  private handleTouchStart(event: TouchEvent): void {
    if (this.disabled) return
    
    const touch = event.touches[0]
    this.startDrag(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // å¼€å§‹æ‹–æ‹½
  private startDrag(clientX: number, clientY: number): void {
    const rect = (this.$refs.knob as HTMLElement).getBoundingClientRect()
    this.centerX = rect.left + rect.width / 2
    this.centerY = rect.top + rect.height / 2
    
    this.isDragging = true
    this.lastAngle = this.calculateAngle(clientX, clientY)
    
    this.$emit('dragStart', {
      value: this.internalValue,
      angle: this.totalRotation,
      timestamp: Date.now()
    })
  }
  
  // é¼ æ ‡ç§»åŠ¨
  private handleMouseMove(event: MouseEvent): void {
    if (!this.isDragging) return
    
    this.updateDrag(event.clientX, event.clientY)
  }
  
  // è§¦æ‘¸ç§»åŠ¨
  private handleTouchMove(event: TouchEvent): void {
    if (!this.isDragging) return
    
    const touch = event.touches[0]
    this.updateDrag(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // æ›´æ–°æ‹–æ‹½
  private updateDrag(clientX: number, clientY: number): void {
    const currentAngle = this.calculateAngle(clientX, clientY)
    let deltaAngle = currentAngle - this.lastAngle
    
    // å¤„ç†è§’åº¦è·¨è¶Š
    if (deltaAngle > 180) deltaAngle -= 360
    if (deltaAngle < -180) deltaAngle += 360
    
    this.totalRotation += deltaAngle
    this.lastAngle = currentAngle
    
    this.updateValueFromAngle()
  }
  
  // é¼ æ ‡é‡Šæ”¾
  private handleMouseUp(): void {
    this.endDrag()
  }
  
  // è§¦æ‘¸ç»“æŸ
  private handleTouchEnd(): void {
    this.endDrag()
  }
  
  // ç»“æŸæ‹–æ‹½
  private endDrag(): void {
    if (!this.isDragging) return
    
    this.isDragging = false
    
    this.$emit('dragEnd', {
      value: this.internalValue,
      angle: this.totalRotation,
      timestamp: Date.now()
    })
  }
  
  // æ»šè½®äº‹ä»¶
  private handleWheel(event: WheelEvent): void {
    if (this.disabled) return
    
    event.preventDefault()
    
    const delta = event.deltaY > 0 ? -this.step : this.step
    this.internalValue = this.clampValue(this.internalValue + delta)
    this.updateAngleFromValue()
    this.emitChange()
  }
  
  // é”®ç›˜äº‹ä»¶å¤„ç†
  handleKeydown(event: KeyboardEvent): void {
    if (this.disabled) return
    
    let delta = 0
    
    switch (event.code) {
      case 'ArrowRight':
      case 'ArrowUp':
        delta = this.step
        break
      case 'ArrowLeft':
      case 'ArrowDown':
        delta = -this.step
        break
      case 'Home':
        this.internalValue = this.min
        this.updateAngleFromValue()
        this.emitChange()
        return
      case 'End':
        this.internalValue = this.max
        this.updateAngleFromValue()
        this.emitChange()
        return
      case 'PageUp':
        delta = this.step * 10
        break
      case 'PageDown':
        delta = -this.step * 10
        break
      default:
        return
    }
    
    event.preventDefault()
    this.internalValue = this.clampValue(this.internalValue + delta)
    this.updateAngleFromValue()
    this.emitChange()
  }
  
  // å‘å°„å˜åŒ–äº‹ä»¶
  private emitChange(): void {
    this.$emit('change', {
      value: this.internalValue,
      angle: this.totalRotation,
      percentage: this.valueToPercentage(this.internalValue),
      timestamp: Date.now()
    })
    
    this.$emit('input', this.internalValue)
  }
  
  // æ•°å€¼è½¬ç™¾åˆ†æ¯”
  private valueToPercentage(value: number): number {
    return ((value - this.min) / (this.max - this.min)) * 100
  }
  
  // è·å–æ—‹é’®æ ·å¼
  get knobStyle(): object {
    return {
      transform: `rotate(${this.totalRotation}deg)`,
      transition: this.isDragging ? 'none' : 'transform 0.1s ease'
    }
  }
  
  // è·å–æ•°å€¼æ˜¾ç¤º
  get displayValue(): string {
    const value = this.internalValue.toFixed(2)
    return this.unit ? `${value} ${this.unit}` : value
  }
  
  // è·å–æ—‹é’®æ ·å¼ç±»
  get knobClasses(): string[] {
    return [
      'rotary-knob',
      {
        'knob-disabled': this.disabled,
        'knob-dragging': this.isDragging,
        'knob-continuous': this.continuous
      }
    ]
  }
}
```

## ğŸ’¡ æŒ‡ç¤ºæ§ä»¶è¯¦è§£

### LEDIndicator LEDæŒ‡ç¤ºç¯

#### åŠŸèƒ½ç‰¹æ€§
- **å¤šç§é¢œè‰²**ï¼šçº¢ã€ç»¿ã€è“ã€é»„ã€æ©™ç­‰é¢„è®¾é¢œè‰²
- **çŠ¶æ€æŒ‡ç¤º**ï¼šå¼€ã€å…³ã€é—ªçƒã€å‘¼å¸ç­‰çŠ¶æ€
- **è‡ªå®šä¹‰æ ·å¼**ï¼šå¯é…ç½®å¤§å°ã€å½¢çŠ¶ã€äº®åº¦
- **åŠ¨ç”»æ•ˆæœ**ï¼šå¹³æ»‘çš„çŠ¶æ€åˆ‡æ¢åŠ¨ç”»

#### æ ¸å¿ƒå®ç°
```typescript
interface LEDIndicatorProps {
  state?: 'off' | 'on' | 'blink' | 'pulse'
  color?: string
  size?: 'small' | 'medium' | 'large'
  shape?: 'circle' | 'square' | 'diamond'
  intensity?: number
  blinkRate?: number
  label?: string
}

class LEDIndicator extends Vue {
  @Prop({ default: 'off' }) state!: string
  @Prop({ default: '#00ff00' }) color!: string
  @Prop({ default: 'medium' }) size!: string
  @Prop({ default: 'circle' }) shape!: string
  @Prop({ default: 1 }) intensity!: number
  @Prop({ default: 500 }) blinkRate!: number
  @Prop() label?: string
  
  private animationId: number | null = null
  private isVisible: boolean = true
  private pulsePhase: number = 0
  
  mounted(): void {
    this.startAnimation()
  }
  
  beforeDestroy(): void {
    this.stopAnimation()
  }
  
  watch: {
    state(): void {
      this.startAnimation()
    },
    blinkRate(): void {
      if (this.state === 'blink') {
        this.startAnimation()
      }
    }
  }
  
  // å¼€å§‹åŠ¨ç”»
  private startAnimation(): void {
    this.stopAnimation()
    
    switch (this.state) {
      case 'on':
        this.isVisible = true
        break
      case 'off':
        this.isVisible = false
        break
      case 'blink':
        this.startBlinkAnimation()
        break
      case 'pulse':
        this.startPulseAnimation()
        break
    }
  }
  
  // åœæ­¢åŠ¨ç”»
  private stopAnimation(): void {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId)
      this.animationId = null
    }
  }
  
  // é—ªçƒåŠ¨ç”»
  private startBlinkAnimation(): void {
    let lastTime = 0
    
    const animate = (currentTime: number) => {
      if (currentTime - lastTime >= this.blinkRate) {
        this.isVisible = !this.isVisible
        lastTime = currentTime
      }
      
      if (this.state === 'blink') {
        this.animationId = requestAnimationFrame(animate)
      }
    }
    
    this.animationId = requestAnimationFrame(animate)
  }
  
  // è„‰å†²åŠ¨ç”»
  private startPulseAnimation(): void {
    const animate = () => {
      this.pulsePhase += 0.05
      if (this.pulsePhase >= Math.PI * 2) {
        this.pulsePhase = 0
      }
      
      if (this.state === 'pulse') {
        this.animationId = requestAnimationFrame(animate)
      }
    }
    
    this.animationId = requestAnimationFrame(animate)
  }
  
  // è·å–LEDæ ·å¼
  get ledStyle(): object {
    const baseStyle: any = {
      backgroundColor: this.color,
      opacity: this.calculateOpacity(),
      boxShadow: this.calculateGlow()
    }
    
    // æ ¹æ®å°ºå¯¸è®¾ç½®å¤§å°
    const sizeMap = {
      small: '12px',
      medium: '16px',
      large: '24px'
    }
    
    const size = sizeMap[this.size] || sizeMap.medium
    baseStyle.width = size
    baseStyle.height = size
    
    // æ ¹æ®å½¢çŠ¶è®¾ç½®æ ·å¼
    switch (this.shape) {
      case 'circle':
        baseStyle.borderRadius = '50%'
        break
      case 'square':
        baseStyle.borderRadius = '2px'
        break
      case 'diamond':
        baseStyle.borderRadius = '2px'
        baseStyle.transform = 'rotate(45deg)'
        break
    }
    
    return baseStyle
  }
  
  // è®¡ç®—é€æ˜åº¦
  private calculateOpacity(): number {
    switch (this.state) {
      case 'off':
        return 0.2
      case 'on':
        return this.intensity
      case 'blink':
        return this.isVisible ? this.intensity : 0.2
      case 'pulse':
        const pulseIntensity = (Math.sin(this.pulsePhase) + 1) / 2
        return 0.2 + pulseIntensity * (this.intensity - 0.2)
      default:
        return this.intensity
    }
  }
  
  // è®¡ç®—å‘å…‰æ•ˆæœ
  private calculateGlow(): string {
    const opacity = this.calculateOpacity()
    if (opacity <= 0.2) return 'none'
    
    const glowIntensity = opacity * 0.8
    return `0 0 10px ${this.color}${Math.round(glowIntensity * 255).toString(16).padStart(2, '0')}`
  }
  
  // è·å–LEDæ ·å¼ç±»
  get ledClasses(): string[] {
    return [
      'led-indicator',
      `led-${this.size}`,
      `led-${this.shape}`,
      `led-${this.state}`
    ]
  }
}
```

## ğŸ“Š æœ€ä½³å®è·µå’Œä½¿ç”¨æŒ‡å—

### æ§ä»¶é€‰æ‹©åŸåˆ™

#### 1. æŒ‰é’®æ§ä»¶é€‰æ‹©
```typescript
// æ ‡å‡†æ“ä½œæŒ‰é’®
<StandardButton type="primary" @click="handleSave">ä¿å­˜</StandardButton>

// çŠ¶æ€åˆ‡æ¢æŒ‰é’®
<ToggleButton v-model="isEnabled" exclusive group-name="mode">å¯ç”¨</ToggleButton>

// å±é™©æ“ä½œæŒ‰é’®
<StandardButton type="danger" @click="handleDelete">åˆ é™¤</StandardButton>
```

#### 2. å¼€å…³æ§ä»¶é€‰æ‹©
```typescript
// ç®€å•å¼€å…³
<ToggleSwitch v-model="power" color="#ff4d4f">ç”µæº</ToggleSwitch>

// å¤šä½ç½®é€‰æ‹©
<RotarySwitch :positions="8" v-model="mode" :labels="modeLabels" />
```

#### 3. è¾“å…¥æ§ä»¶é€‰æ‹©
```typescript
// ç²¾ç¡®æ•°å€¼è¾“å…¥
<NumericInput 
  v-model="frequency" 
  :min="1" 
  :max="1000000" 
  :step="0.1" 
  unit="Hz"
  format="engineering"
/>

// èŒƒå›´è°ƒèŠ‚
<LinearSlider 
  v-model="amplitude" 
  :min="0" 
  :max="10" 
  :step="0.01" 
  show-tooltip
/>
```

### æ€§èƒ½ä¼˜åŒ–å»ºè®®

#### 1. äº‹ä»¶å¤„ç†ä¼˜åŒ–
```typescript
// ä½¿ç”¨é˜²æŠ–å¤„ç†é«˜é¢‘äº‹ä»¶
import { debounce } from 'lodash-es'

class OptimizedSlider extends LinearSlider {
  private debouncedEmit = debounce((value: number) => {
    this.$emit('change', value)
  }, 16) // 60fps
  
  protected emitChange(): void {
    this.debouncedEmit(this.internalValue)
  }
}
```

#### 2. å†…å­˜ç®¡ç†ä¼˜åŒ–
```typescript
// åŠæ—¶æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
class MemoryOptimizedControl extends Vue {
  private eventListeners: Array<() => void> = []
  
  mounted(): void {
    const cleanup = this.bindEvents()
    this.eventListeners.push(cleanup)
  }
  
  beforeDestroy(): void {
    this.eventListeners.forEach(cleanup => cleanup())
    this.eventListeners = []
  }
  
  private bindEvents(): () => void {
    const handler = this.handleEvent.bind(this)
    document.addEventListener('mousemove', handler)
    
    return () => {
      document.removeEventListener('mousemove', handler)
    }
  }
}
```

#### 3. æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–
```typescript
// ä½¿ç”¨è®¡ç®—å±æ€§ç¼“å­˜å¤æ‚è®¡ç®—
class PerformantControl extends Vue {
  @Prop() data!: number[]
  
  // ç¼“å­˜å¤æ‚è®¡ç®—ç»“æœ
  get processedData(): ProcessedData {
    return this.data.map(value => ({
      value,
      normalized: this.normalizeValue(value),
      formatted: this.formatValue(value)
    }))
  }
  
  // ä½¿ç”¨ shouldUpdate é¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
  shouldComponentUpdate(nextProps: any): boolean {
    return nextProps.value !== this.value
  }
}
```

### æ— éšœç¢è®¿é—®æ”¯æŒ

#### 1. é”®ç›˜å¯¼èˆª
```typescript
// å®Œæ•´çš„é”®ç›˜æ”¯æŒ
class AccessibleControl extends Vue {
  private focusIndex: number = 0
  
  handleKeydown(event: KeyboardEvent): void {
    switch (event.code) {
      case 'Tab':
        this.handleTabNavigation(event)
        break
      case 'Enter':
      case 'Space':
        this.handleActivation(event)
        break
      case 'Escape':
        this.handleEscape(event)
        break
      case 'ArrowUp':
      case 'ArrowDown':
      case 'ArrowLeft':
      case 'ArrowRight':
        this.handleArrowNavigation(event)
        break
    }
  }
  
  private handleTabNavigation(event: KeyboardEvent): void {
    // å®ç°Tabé”®å¯¼èˆªé€»è¾‘
    const focusableElements = this.getFocusableElements()
    if (event.shiftKey) {
      this.focusIndex = Math.max(0, this.focusIndex - 1)
    } else {
      this.focusIndex = Math.min(focusableElements.length - 1, this.focusIndex + 1)
    }
    focusableElements[this.focusIndex]?.focus()
    event.preventDefault()
  }
}
```

#### 2. ARIAå±æ€§æ”¯æŒ
```vue
<template>
  <div
    class="control-element"
    :aria-label="ariaLabel"
    :aria-valuemin="min"
    :aria-valuemax="max"
    :aria-valuenow="value"
    :aria-valuetext="ariaValueText"
    :aria-disabled="disabled"
    role="slider"
    tabindex="0"
    @keydown="handleKeydown"
  >
    <div class="control-track" aria-hidden="true">
      <div class="control-thumb" :style="thumbStyle" />
    </div>
    <div class="sr-only">{{ screenReaderText }}</div>
  </div>
</template>

<script lang="ts">
export default class AccessibleSlider extends Vue {
  get ariaLabel(): string {
    return this.label || `è°ƒèŠ‚ ${this.unit || 'æ•°å€¼'}`
  }
  
  get ariaValueText(): string {
    return `${this.value} ${this.unit || ''}`
  }
  
  get screenReaderText(): string {
    return `å½“å‰å€¼: ${this.ariaValueText}, æœ€å°å€¼: ${this.min}, æœ€å¤§å€¼: ${this.max}`
  }
}
</script>
```

### ä¸»é¢˜å’Œæ ·å¼å®šåˆ¶

#### 1. CSSå˜é‡ç³»ç»Ÿ
```scss
// æ§ä»¶ä¸»é¢˜å˜é‡
:root {
  // åŸºç¡€é¢œè‰²
  --control-primary-color: #1890ff;
  --control-success-color: #52c41a;
  --control-warning-color: #faad14;
  --control-danger-color: #ff4d4f;
  
  // å°ºå¯¸å˜é‡
  --control-border-radius: 4px;
  --control-padding: 8px 16px;
  --control-font-size: 14px;
  
  // çŠ¶æ€é¢œè‰²
  --control-hover-color: rgba(24, 144, 255, 0.1);
  --control-active-color: rgba(24, 144, 255, 0.2);
  --control-disabled-color: #f5f5f5;
  
  // é˜´å½±æ•ˆæœ
  --control-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  --control-shadow-hover: 0 4px 12px rgba(0, 0, 0, 0.15);
}

// æ·±è‰²ä¸»é¢˜
[data-theme="dark"] {
  --control-primary-color: #177ddc;
  --control-disabled-color: #262626;
  --control-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
```

#### 2. åŠ¨æ€ä¸»é¢˜åˆ‡æ¢
```typescript
class ThemeManager {
  private currentTheme: string = 'light'
  
  setTheme(theme: string): void {
    this.currentTheme = theme
    document.documentElement.setAttribute('data-theme', theme)
    
    // è§¦å‘ä¸»é¢˜å˜æ›´äº‹ä»¶
    window.dispatchEvent(new CustomEvent('themeChange', {
      detail: { theme }
    }))
  }
  
  getTheme(): string {
    return this.currentTheme
  }
  
  // è‡ªåŠ¨æ£€æµ‹ç³»ç»Ÿä¸»é¢˜
  detectSystemTheme(): string {
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark'
    }
    return 'light'
  }
}
```

### å›½é™…åŒ–æ”¯æŒ

#### 1. å¤šè¯­è¨€æ–‡æœ¬
```typescript
// å›½é™…åŒ–é…ç½®
const i18nMessages = {
  'zh-CN': {
    controls: {
      increment: 'å¢åŠ ',
      decrement: 'å‡å°‘',
      reset: 'é‡ç½®',
      confirm: 'ç¡®è®¤',
      cancel: 'å–æ¶ˆ',
      loading: 'åŠ è½½ä¸­...',
      error: 'é”™è¯¯',
      success: 'æˆåŠŸ'
    }
  },
  'en-US': {
    controls: {
      increment: 'Increment',
      decrement: 'Decrement',
      reset: 'Reset',
      confirm: 'Confirm',
      cancel: 'Cancel',
      loading: 'Loading...',
      error: 'Error',
      success: 'Success'
    }
  }
}

class I18nControl extends Vue {
  get t(): (key: string) => string {
    return (key: string) => {
      const locale = this.$i18n.locale
      const keys = key.split('.')
      let value = i18nMessages[locale]
      
      for (const k of keys) {
        value = value?.[k]
      }
      
      return value || key
    }
  }
}
```

#### 2. æ•°å€¼æ ¼å¼åŒ–
```typescript
class NumberFormatter {
  private locale: string
  private options: Intl.NumberFormatOptions
  
  constructor(locale: string = 'zh-CN') {
    this.locale = locale
    this.options = {
      minimumFractionDigits: 0,
      maximumFractionDigits: 3
    }
  }
  
  format(value: number, unit?: string): string {
    const formatter = new Intl.NumberFormat(this.locale, this.options)
    const formattedValue = formatter.format(value)
    
    return unit ? `${formattedValue} ${unit}` : formattedValue
  }
  
  formatCurrency(value: number, currency: string = 'CNY'): string {
    const formatter = new Intl.NumberFormat(this.locale, {
      style: 'currency',
      currency
    })
    
    return formatter.format(value)
  }
  
  formatPercentage(value: number): string {
    const formatter = new Intl.NumberFormat(this.locale, {
      style: 'percent',
      minimumFractionDigits: 1,
      maximumFractionDigits: 2
    })
    
    return formatter.format(value / 100)
  }
}
```

## ğŸ”§ æ•…éšœæ’é™¤å’Œå¸¸è§é—®é¢˜

### å¸¸è§é—®é¢˜è§£å†³

#### 1. æ§ä»¶å“åº”æ€§é—®é¢˜
```typescript
// é—®é¢˜ï¼šæ§ä»¶åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šå“åº”ç¼“æ…¢
// è§£å†³æ–¹æ¡ˆï¼šä¼˜åŒ–è§¦æ‘¸äº‹ä»¶å¤„ç†
class ResponsiveControl extends Vue {
  private touchStartTime: number = 0
  
  handleTouchStart(event: TouchEvent): void {
    this.touchStartTime = Date.now()
    
    // é˜²æ­¢é»˜è®¤è¡Œä¸ºï¼Œæé«˜å“åº”é€Ÿåº¦
    event.preventDefault()
    
    // ä½¿ç”¨ passive: false ç¡®ä¿å¯ä»¥é˜»æ­¢é»˜è®¤è¡Œä¸º
    this.startInteraction(event.touches[0])
  }
  
  handleTouchMove(event: TouchEvent): void {
    // é™åˆ¶å¤„ç†é¢‘ç‡ï¼Œé¿å…æ€§èƒ½é—®é¢˜
    const now = Date.now()
    if (now - this.touchStartTime < 16) return // 60fps
    
    this.updateInteraction(event.touches[0])
  }
}
```

#### 2. æ•°å€¼ç²¾åº¦é—®é¢˜
```typescript
// é—®é¢˜ï¼šæµ®ç‚¹æ•°è®¡ç®—ç²¾åº¦ä¸¢å¤±
// è§£å†³æ–¹æ¡ˆï¼šä½¿ç”¨ç²¾åº¦å®‰å…¨çš„æ•°å­¦è¿ç®—
class PrecisionMath {
  static add(a: number, b: number, precision: number = 10): number {
    const factor = Math.pow(10, precision)
    return Math.round((a + b) * factor) / factor
  }
  
  static subtract(a: number, b: number, precision: number = 10): number {
    const factor = Math.pow(10, precision)
    return Math.round((a - b) * factor) / factor
  }
  
  static multiply(a: number, b: number, precision: number = 10): number {
    const factor = Math.pow(10, precision)
    return Math.round(a * b * factor) / factor
  }
  
  static divide(a: number, b: number, precision: number = 10): number {
    if (b === 0) throw new Error('Division by zero')
    const factor = Math.pow(10, precision)
    return Math.round((a / b) * factor) / factor
  }
}
```

#### 3. å†…å­˜æ³„æ¼é—®é¢˜
```typescript
// é—®é¢˜ï¼šé•¿æ—¶é—´ä½¿ç”¨åå†…å­˜å ç”¨è¿‡é«˜
// è§£å†³æ–¹æ¡ˆï¼šå®Œå–„çš„èµ„æºæ¸…ç†æœºåˆ¶
class MemoryManagedControl extends Vue {
  private timers: number[] = []
  private observers: ResizeObserver[] = []
  private eventCleanups: Array<() => void> = []
  
  mounted(): void {
    this.setupResizeObserver()
    this.setupEventListeners()
  }
  
  beforeDestroy(): void {
    // æ¸…ç†å®šæ—¶å™¨
    this.timers.forEach(timer => clearTimeout(timer))
    this.timers = []
    
    // æ¸…ç†è§‚å¯Ÿå™¨
    this.observers.forEach(observer => observer.disconnect())
    this.observers = []
    
    // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
    this.eventCleanups.forEach(cleanup => cleanup())
    this.eventCleanups = []
  }
  
  private setupResizeObserver(): void {
    const observer = new ResizeObserver(entries => {
      this.handleResize(entries)
    })
    
    observer.observe(this.$el as Element)
    this.observers.push(observer)
  }
  
  private addTimer(callback: () => void, delay: number): void {
    const timer = setTimeout(callback, delay)
    this.timers.push(timer)
  }
}
```

### è°ƒè¯•å·¥å…·

#### 1. æ§ä»¶çŠ¶æ€ç›‘æ§
```typescript
class ControlDebugger {
  private static instance: ControlDebugger
  private controls: Map<string, any> = new Map()
  
  static getInstance(): ControlDebugger {
    if (!this.instance) {
      this.instance = new ControlDebugger()
    }
    return this.instance
  }
  
  registerControl(id: string, control: any): void {
    this.controls.set(id, control)
    console.log(`Control registered: ${id}`, control)
  }
  
  unregisterControl(id: string): void {
    this.controls.delete(id)
    console.log(`Control unregistered: ${id}`)
  }
  
  getControlState(id: string): any {
    const control = this.controls.get(id)
    if (!control) return null
    
    return {
      id,
      type: control.constructor.name,
      value: control.value,
      disabled: control.disabled,
      focused: control.isFocused,
      valid: control.isValid
    }
  }
  
  getAllControlStates(): any[] {
    return Array.from(this.controls.keys()).map(id => this.getControlState(id))
  }
}
```

#### 2. æ€§èƒ½åˆ†æå·¥å…·
```typescript
class PerformanceProfiler {
  private measurements: Map<string, number[]> = new Map()
  
  startMeasurement(name: string): void {
    performance.mark(`${name}-start`)
  }
  
  endMeasurement(name: string): number {
    performance.mark(`${name}-end`)
    performance.measure(name, `${name}-start`, `${name}-end`)
    
    const measure = performance.getEntriesByName(name, 'measure')[0]
    const duration = measure.duration
    
    if (!this.measurements.has(name)) {
      this.measurements.set(name, [])
    }
    
    this.measurements.get(name)!.push(duration)
    
    // æ¸…ç†æ€§èƒ½æ ‡è®°
    performance.clearMarks(`${name}-start`)
    performance.clearMarks(`${name}-end`)
    performance.clearMeasures(name)
    
    return duration
  }
  
  getAverageTime(name: string): number {
    const times = this.measurements.get(name)
    if (!times || times.length === 0) return 0
    
    return times.reduce((sum, time) => sum + time, 0) / times.length
  }
  
  getReport(): Record<string, { average: number; count: number; total: number }> {
    const report: Record<string, any> = {}
    
    for (const [name, times] of this.measurements) {
      report[name] = {
        average: this.getAverageTime(name),
        count: times.length,
        total: times.reduce((sum, time) => sum + time, 0)
      }
    }
    
    return report
  }
}
```

## ğŸš€ æœªæ¥å‘å±•æ–¹å‘

### æŠ€æœ¯æ¼”è¿›

#### 1. Web Componentsæ ‡å‡†åŒ–
```typescript
// åŸºäºWeb Componentsçš„æ§ä»¶å®ç°
class WebComponentControl extends HTMLElement {
  private shadow: ShadowRoot
  private template: HTMLTemplateElement
  
  constructor() {
    super()
    this.shadow = this.attachShadow({ mode: 'open' })
    this.setupTemplate()
  }
  
  connectedCallback(): void {
    this.render()
    this.bindEvents()
  }
  
  disconnectedCallback(): void {
    this.cleanup()
  }
  
  attributeChangedCallback(name: string, oldValue: string, newValue: string): void {
    this.handleAttributeChange(name, oldValue, newValue)
  }
  
  static get observedAttributes(): string[] {
    return ['value', 'disabled', 'min', 'max']
  }
}

// æ³¨å†Œè‡ªå®šä¹‰å…ƒç´ 
customElements.define('seesharp-slider', WebComponentControl)
```

#### 2. AIè¾…åŠ©æ§ä»¶ç”Ÿæˆ
```typescript
// AIé©±åŠ¨çš„æ§ä»¶è‡ªåŠ¨ç”Ÿæˆ
class AIControlGenerator {
  async generateControl(description: string): Promise<ControlDefinition> {
    const prompt = this.buildPrompt(description)
    const response = await this.callAIService(prompt)
    
    return this.parseControlDefinition(response)
  }
  
  private buildPrompt(description: string): string {
    return `
      åŸºäºä»¥ä¸‹æè¿°ç”Ÿæˆä¸€ä¸ªVueæ§ä»¶:
      ${description}
      
      è¦æ±‚:
      1. ç¬¦åˆSeeSharpToolsè®¾è®¡è§„èŒƒ
      2. åŒ…å«å®Œæ•´çš„TypeScriptç±»å‹å®šä¹‰
      3. æ”¯æŒæ— éšœç¢è®¿é—®
      4. å…·å¤‡å“åº”å¼è®¾è®¡
      5. åŒ…å«å•å…ƒæµ‹è¯•
    `
  }
  
  private async callAIService(prompt: string): Promise<string> {
    // è°ƒç”¨AIæœåŠ¡API
    const response = await fetch('/api/ai/generate-control', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ prompt })
    })
    
    return response.text()
  }
}
```

#### 3. è™šæ‹Ÿç°å®é›†æˆ
```typescript
// VR/ARç¯å¢ƒä¸­çš„3Dæ§ä»¶
class VRControl extends Vue {
  private scene: THREE.Scene
  private camera: THREE.Camera
  private renderer: THREE.WebGLRenderer
  
  mounted(): void {
    this.initVREnvironment()
    this.create3DControl()
  }
  
  private initVREnvironment(): void {
    this.scene = new THREE.Scene()
    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
    this.renderer = new THREE.WebGLRenderer({ antialias: true })
    
    // å¯ç”¨VRæ”¯æŒ
    this.renderer.xr.enabled = true
    document.body.appendChild(VRButton.createButton(this.renderer))
  }
  
  private create3DControl(): void {
    // åˆ›å»º3Dæ§ä»¶å‡ ä½•ä½“
    const geometry = new THREE.CylinderGeometry(1, 1, 0.2, 32)
    const material = new THREE.MeshPhongMaterial({ color: 0x1890ff })
    const knob = new THREE.Mesh(geometry, material)
    
    this.scene.add(knob)
    
    // æ·»åŠ äº¤äº’é€»è¾‘
    this.setupVRInteraction(knob)
  }
}
```

---

*æ§åˆ¶å…ƒä»¶æ˜¯ç”¨æˆ·ç•Œé¢çš„åŸºç¡€æ„å»ºå—ï¼Œé€šè¿‡åˆç†çš„è®¾è®¡å’Œå®ç°ï¼Œå¯ä»¥ä¸ºç”¨æˆ·æä¾›ç›´è§‚ã€é«˜æ•ˆçš„äº¤äº’ä½“éªŒã€‚éšç€æŠ€æœ¯çš„ä¸æ–­å‘å±•ï¼Œæ§åˆ¶å…ƒä»¶å°†æœç€æ›´åŠ æ™ºèƒ½åŒ–ã€ä¸ªæ€§åŒ–çš„æ–¹å‘æ¼”è¿›ã€‚*
