# 🎛️ SeeSharpTools Web 控制元件详解

## 📋 控制元件概述

控制元件是用户与系统交互的核心界面组件，提供了丰富的用户输入和控制功能。SeeSharpTools Web的控制元件采用现代化设计理念，结合专业测控系统的使用习惯，为用户提供直观、高效的操作体验。

### 🎯 设计理念
- **专业性**：符合工业控制界面的设计标准
- **易用性**：直观的操作逻辑和视觉反馈
- **可靠性**：稳定的状态管理和错误处理
- **可定制性**：丰富的样式和行为配置选项

### 🏗️ 控件分类体系
```
控制元件系统
├── 按钮控件类
│   ├── 标准按钮 (StandardButton)
│   ├── 切换按钮 (ToggleButton)
│   ├── 图标按钮 (IconButton)
│   └── 按钮组 (ButtonGroup)
├── 开关控件类
│   ├── 拨动开关 (ToggleSwitch)
│   ├── 旋转开关 (RotarySwitch)
│   ├── 按压开关 (PushSwitch)
│   └── 多位开关 (MultiPositionSwitch)
├── 输入控件类
│   ├── 数值输入框 (NumericInput)
│   ├── 文本输入框 (TextInput)
│   ├── 下拉选择框 (ComboBox)
│   └── 列表选择器 (ListSelector)
├── 滑动控件类
│   ├── 线性滑块 (LinearSlider)
│   ├── 旋钮控件 (RotaryKnob)
│   ├── 范围滑块 (RangeSlider)
│   └── 步进滑块 (StepSlider)
├── 指示控件类
│   ├── LED指示灯 (LEDIndicator)
│   ├── 状态指示器 (StatusIndicator)
│   ├── 进度条 (ProgressBar)
│   └── 活动指示器 (ActivityIndicator)
└── 容器控件类
    ├── 面板容器 (Panel)
    ├── 选项卡 (TabControl)
    ├── 分组框 (GroupBox)
    └── 工具栏 (Toolbar)
```

## 🔘 按钮控件详解

### StandardButton 标准按钮

#### 功能特性
- **多种样式**：主要、次要、危险、成功等预设样式
- **状态管理**：正常、悬停、按下、禁用状态
- **图标支持**：支持图标和文字组合显示
- **尺寸规格**：小、中、大、超大四种尺寸

#### 核心实现
```typescript
interface ButtonProps {
  type?: 'primary' | 'secondary' | 'danger' | 'success' | 'warning' | 'info'
  size?: 'small' | 'medium' | 'large' | 'extra-large'
  disabled?: boolean
  loading?: boolean
  icon?: string
  iconPosition?: 'left' | 'right'
  block?: boolean
  ghost?: boolean
  shape?: 'default' | 'round' | 'circle'
}

class StandardButton extends Vue {
  @Prop({ default: 'primary' }) type!: string
  @Prop({ default: 'medium' }) size!: string
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: false }) loading!: boolean
  
  private isPressed: boolean = false
  private rippleEffect: boolean = false
  
  // 按钮点击处理
  handleClick(event: MouseEvent): void {
    if (this.disabled || this.loading) {
      event.preventDefault()
      return
    }
    
    this.triggerRippleEffect(event)
    this.emitClickEvent(event)
  }
  
  // 涟漪效果
  private triggerRippleEffect(event: MouseEvent): void {
    if (!this.rippleEffect) return
    
    const button = event.currentTarget as HTMLElement
    const rect = button.getBoundingClientRect()
    const size = Math.max(rect.width, rect.height)
    const x = event.clientX - rect.left - size / 2
    const y = event.clientY - rect.top - size / 2
    
    const ripple = document.createElement('span')
    ripple.className = 'button-ripple'
    ripple.style.cssText = `
      width: ${size}px;
      height: ${size}px;
      left: ${x}px;
      top: ${y}px;
    `
    
    button.appendChild(ripple)
    
    setTimeout(() => {
      ripple.remove()
    }, 600)
  }
  
  // 发射点击事件
  private emitClickEvent(event: MouseEvent): void {
    this.$emit('click', {
      originalEvent: event,
      timestamp: Date.now(),
      buttonType: this.type,
      buttonSize: this.size
    })
  }
  
  // 键盘事件处理
  handleKeydown(event: KeyboardEvent): void {
    if (event.code === 'Space' || event.code === 'Enter') {
      event.preventDefault()
      this.handleClick(event as any)
    }
  }
  
  // 获取按钮样式类
  get buttonClasses(): string[] {
    return [
      'standard-button',
      `button-${this.type}`,
      `button-${this.size}`,
      {
        'button-disabled': this.disabled,
        'button-loading': this.loading,
        'button-block': this.block,
        'button-ghost': this.ghost,
        'button-pressed': this.isPressed
      }
    ]
  }
}
```

### ToggleButton 切换按钮

#### 功能特性
- **双态切换**：开启/关闭状态切换
- **状态保持**：自动维护切换状态
- **视觉反馈**：清晰的状态指示
- **分组支持**：支持单选和多选分组

#### 核心实现
```typescript
interface ToggleButtonProps extends ButtonProps {
  value?: boolean
  exclusive?: boolean
  groupName?: string
}

class ToggleButton extends StandardButton {
  @Prop({ default: false }) value!: boolean
  @Prop({ default: false }) exclusive!: boolean
  @Prop() groupName?: string
  
  private internalValue: boolean = false
  
  created(): void {
    this.internalValue = this.value
    
    // 注册到按钮组
    if (this.groupName) {
      this.registerToGroup()
    }
  }
  
  // 切换状态
  toggle(): void {
    if (this.disabled) return
    
    if (this.exclusive && this.groupName) {
      this.handleExclusiveToggle()
    } else {
      this.internalValue = !this.internalValue
      this.emitChange()
    }
  }
  
  // 处理排他性切换
  private handleExclusiveToggle(): void {
    if (!this.internalValue) {
      // 取消组内其他按钮的选中状态
      this.clearGroupSelection()
      this.internalValue = true
      this.emitChange()
    }
  }
  
  // 清除组内选择
  private clearGroupSelection(): void {
    const groupButtons = this.getGroupButtons()
    groupButtons.forEach(button => {
      if (button !== this) {
        button.internalValue = false
        button.emitChange()
      }
    })
  }
  
  // 注册到按钮组
  private registerToGroup(): void {
    if (!window.buttonGroups) {
      window.buttonGroups = new Map()
    }
    
    if (!window.buttonGroups.has(this.groupName)) {
      window.buttonGroups.set(this.groupName, new Set())
    }
    
    window.buttonGroups.get(this.groupName).add(this)
  }
  
  // 获取组内按钮
  private getGroupButtons(): ToggleButton[] {
    if (!this.groupName || !window.buttonGroups) return []
    
    const group = window.buttonGroups.get(this.groupName)
    return group ? Array.from(group) : []
  }
  
  // 发射变化事件
  private emitChange(): void {
    this.$emit('change', {
      value: this.internalValue,
      groupName: this.groupName,
      timestamp: Date.now()
    })
    
    this.$emit('input', this.internalValue)
  }
  
  // 重写点击处理
  handleClick(event: MouseEvent): void {
    super.handleClick(event)
    this.toggle()
  }
  
  // 获取切换按钮样式
  get toggleClasses(): string[] {
    return [
      ...this.buttonClasses,
      'toggle-button',
      {
        'toggle-active': this.internalValue,
        'toggle-exclusive': this.exclusive
      }
    ]
  }
}
```

## 🔄 开关控件详解

### ToggleSwitch 拨动开关

#### 功能特性
- **平滑动画**：流畅的切换动画效果
- **触摸支持**：支持鼠标和触摸操作
- **自定义样式**：可配置颜色、尺寸、形状
- **状态指示**：清晰的开关状态显示

#### 核心实现
```typescript
interface ToggleSwitchProps {
  value?: boolean
  disabled?: boolean
  size?: 'small' | 'medium' | 'large'
  color?: string
  labels?: { on: string; off: string }
  loading?: boolean
}

class ToggleSwitch extends Vue {
  @Prop({ default: false }) value!: boolean
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: 'medium' }) size!: string
  @Prop({ default: '#1890ff' }) color!: string
  @Prop() labels?: { on: string; off: string }
  @Prop({ default: false }) loading!: boolean
  
  private internalValue: boolean = false
  private isDragging: boolean = false
  private startX: number = 0
  private currentX: number = 0
  private switchRef: HTMLElement | null = null
  
  mounted(): void {
    this.internalValue = this.value
    this.switchRef = this.$refs.switch as HTMLElement
    this.bindEvents()
  }
  
  beforeDestroy(): void {
    this.unbindEvents()
  }
  
  // 绑定事件
  private bindEvents(): void {
    if (!this.switchRef) return
    
    // 鼠标事件
    this.switchRef.addEventListener('mousedown', this.handleMouseDown)
    document.addEventListener('mousemove', this.handleMouseMove)
    document.addEventListener('mouseup', this.handleMouseUp)
    
    // 触摸事件
    this.switchRef.addEventListener('touchstart', this.handleTouchStart, { passive: false })
    document.addEventListener('touchmove', this.handleTouchMove, { passive: false })
    document.addEventListener('touchend', this.handleTouchEnd)
  }
  
  // 解绑事件
  private unbindEvents(): void {
    if (!this.switchRef) return
    
    this.switchRef.removeEventListener('mousedown', this.handleMouseDown)
    document.removeEventListener('mousemove', this.handleMouseMove)
    document.removeEventListener('mouseup', this.handleMouseUp)
    
    this.switchRef.removeEventListener('touchstart', this.handleTouchStart)
    document.removeEventListener('touchmove', this.handleTouchMove)
    document.removeEventListener('touchend', this.handleTouchEnd)
  }
  
  // 鼠标按下
  private handleMouseDown(event: MouseEvent): void {
    if (this.disabled || this.loading) return
    
    this.startDrag(event.clientX)
    event.preventDefault()
  }
  
  // 触摸开始
  private handleTouchStart(event: TouchEvent): void {
    if (this.disabled || this.loading) return
    
    this.startDrag(event.touches[0].clientX)
    event.preventDefault()
  }
  
  // 开始拖拽
  private startDrag(clientX: number): void {
    this.isDragging = true
    this.startX = clientX
    this.currentX = clientX
    
    this.$emit('dragStart', {
      value: this.internalValue,
      timestamp: Date.now()
    })
  }
  
  // 鼠标移动
  private handleMouseMove(event: MouseEvent): void {
    if (!this.isDragging) return
    
    this.updateDrag(event.clientX)
  }
  
  // 触摸移动
  private handleTouchMove(event: TouchEvent): void {
    if (!this.isDragging) return
    
    this.updateDrag(event.touches[0].clientX)
    event.preventDefault()
  }
  
  // 更新拖拽
  private updateDrag(clientX: number): void {
    this.currentX = clientX
    const deltaX = clientX - this.startX
    const threshold = 20 // 拖拽阈值
    
    if (Math.abs(deltaX) > threshold) {
      const newValue = deltaX > 0 ? true : false
      if (newValue !== this.internalValue) {
        this.internalValue = newValue
        this.emitChange()
      }
    }
  }
  
  // 鼠标释放
  private handleMouseUp(): void {
    this.endDrag()
  }
  
  // 触摸结束
  private handleTouchEnd(): void {
    this.endDrag()
  }
  
  // 结束拖拽
  private endDrag(): void {
    if (!this.isDragging) return
    
    this.isDragging = false
    
    // 如果拖拽距离很小，视为点击
    const deltaX = Math.abs(this.currentX - this.startX)
    if (deltaX < 5) {
      this.toggle()
    }
    
    this.$emit('dragEnd', {
      value: this.internalValue,
      timestamp: Date.now()
    })
  }
  
  // 切换状态
  toggle(): void {
    if (this.disabled || this.loading) return
    
    this.internalValue = !this.internalValue
    this.emitChange()
  }
  
  // 发射变化事件
  private emitChange(): void {
    this.$emit('change', {
      value: this.internalValue,
      timestamp: Date.now()
    })
    
    this.$emit('input', this.internalValue)
  }
  
  // 点击处理
  handleClick(): void {
    if (!this.isDragging) {
      this.toggle()
    }
  }
  
  // 键盘事件处理
  handleKeydown(event: KeyboardEvent): void {
    if (event.code === 'Space' || event.code === 'Enter') {
      event.preventDefault()
      this.toggle()
    }
  }
  
  // 获取开关样式
  get switchClasses(): string[] {
    return [
      'toggle-switch',
      `switch-${this.size}`,
      {
        'switch-checked': this.internalValue,
        'switch-disabled': this.disabled,
        'switch-loading': this.loading,
        'switch-dragging': this.isDragging
      }
    ]
  }
  
  // 获取滑块样式
  get sliderStyle(): object {
    const baseStyle = {
      backgroundColor: this.internalValue ? this.color : '#ccc',
      transform: this.internalValue ? 'translateX(100%)' : 'translateX(0%)'
    }
    
    if (this.isDragging) {
      const progress = Math.max(0, Math.min(1, (this.currentX - this.startX) / 40))
      baseStyle.transform = `translateX(${progress * 100}%)`
    }
    
    return baseStyle
  }
}
```

### RotarySwitch 旋转开关

#### 功能特性
- **多位置支持**：支持2-12个位置
- **角度控制**：精确的角度定位
- **视觉指示**：清晰的位置标识
- **平滑旋转**：流畅的旋转动画

#### 核心实现
```typescript
interface RotarySwitchProps {
  positions: number
  value?: number
  disabled?: boolean
  size?: number
  labels?: string[]
  snapToPosition?: boolean
  continuous?: boolean
}

class RotarySwitch extends Vue {
  @Prop({ default: 8 }) positions!: number
  @Prop({ default: 0 }) value!: number
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: 100 }) size!: number
  @Prop() labels?: string[]
  @Prop({ default: true }) snapToPosition!: boolean
  @Prop({ default: false }) continuous!: boolean
  
  private currentPosition: number = 0
  private isDragging: boolean = false
  private startAngle: number = 0
  private currentAngle: number = 0
  private centerX: number = 0
  private centerY: number = 0
  
  mounted(): void {
    this.currentPosition = this.value
    this.currentAngle = this.positionToAngle(this.currentPosition)
    this.bindEvents()
  }
  
  beforeDestroy(): void {
    this.unbindEvents()
  }
  
  // 位置转角度
  private positionToAngle(position: number): number {
    const anglePerPosition = 360 / this.positions
    return position * anglePerPosition
  }
  
  // 角度转位置
  private angleToPosition(angle: number): number {
    const normalizedAngle = ((angle % 360) + 360) % 360
    const anglePerPosition = 360 / this.positions
    return Math.round(normalizedAngle / anglePerPosition) % this.positions
  }
  
  // 绑定事件
  private bindEvents(): void {
    const element = this.$el as HTMLElement
    element.addEventListener('mousedown', this.handleMouseDown)
    document.addEventListener('mousemove', this.handleMouseMove)
    document.addEventListener('mouseup', this.handleMouseUp)
    
    element.addEventListener('touchstart', this.handleTouchStart, { passive: false })
    document.addEventListener('touchmove', this.handleTouchMove, { passive: false })
    document.addEventListener('touchend', this.handleTouchEnd)
  }
  
  // 解绑事件
  private unbindEvents(): void {
    const element = this.$el as HTMLElement
    element.removeEventListener('mousedown', this.handleMouseDown)
    document.removeEventListener('mousemove', this.handleMouseMove)
    document.removeEventListener('mouseup', this.handleMouseUp)
    
    element.removeEventListener('touchstart', this.handleTouchStart)
    document.removeEventListener('touchmove', this.handleTouchMove)
    document.removeEventListener('touchend', this.handleTouchEnd)
  }
  
  // 鼠标按下
  private handleMouseDown(event: MouseEvent): void {
    if (this.disabled) return
    
    this.startDrag(event.clientX, event.clientY)
    event.preventDefault()
  }
  
  // 触摸开始
  private handleTouchStart(event: TouchEvent): void {
    if (this.disabled) return
    
    const touch = event.touches[0]
    this.startDrag(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // 开始拖拽
  private startDrag(clientX: number, clientY: number): void {
    const rect = (this.$el as HTMLElement).getBoundingClientRect()
    this.centerX = rect.left + rect.width / 2
    this.centerY = rect.top + rect.height / 2
    
    this.isDragging = true
    this.startAngle = this.calculateAngle(clientX, clientY)
  }
  
  // 计算角度
  private calculateAngle(clientX: number, clientY: number): number {
    const deltaX = clientX - this.centerX
    const deltaY = clientY - this.centerY
    return Math.atan2(deltaY, deltaX) * 180 / Math.PI
  }
  
  // 鼠标移动
  private handleMouseMove(event: MouseEvent): void {
    if (!this.isDragging) return
    
    this.updateDrag(event.clientX, event.clientY)
  }
  
  // 触摸移动
  private handleTouchMove(event: TouchEvent): void {
    if (!this.isDragging) return
    
    const touch = event.touches[0]
    this.updateDrag(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // 更新拖拽
  private updateDrag(clientX: number, clientY: number): void {
    const currentAngle = this.calculateAngle(clientX, clientY)
    let deltaAngle = currentAngle - this.startAngle
    
    // 处理角度跨越
    if (deltaAngle > 180) deltaAngle -= 360
    if (deltaAngle < -180) deltaAngle += 360
    
    this.currentAngle += deltaAngle
    this.startAngle = currentAngle
    
    if (this.snapToPosition) {
      const newPosition = this.angleToPosition(this.currentAngle)
      if (newPosition !== this.currentPosition) {
        this.setPosition(newPosition)
      }
    }
  }
  
  // 鼠标释放
  private handleMouseUp(): void {
    this.endDrag()
  }
  
  // 触摸结束
  private handleTouchEnd(): void {
    this.endDrag()
  }
  
  // 结束拖拽
  private endDrag(): void {
    if (!this.isDragging) return
    
    this.isDragging = false
    
    if (this.snapToPosition) {
      const finalPosition = this.angleToPosition(this.currentAngle)
      this.setPosition(finalPosition)
      this.currentAngle = this.positionToAngle(finalPosition)
    }
  }
  
  // 设置位置
  setPosition(position: number): void {
    if (position === this.currentPosition) return
    
    const clampedPosition = Math.max(0, Math.min(this.positions - 1, position))
    this.currentPosition = clampedPosition
    this.currentAngle = this.positionToAngle(clampedPosition)
    
    this.$emit('change', {
      position: clampedPosition,
      angle: this.currentAngle,
      label: this.labels?.[clampedPosition],
      timestamp: Date.now()
    })
    
    this.$emit('input', clampedPosition)
  }
  
  // 获取旋钮样式
  get knobStyle(): object {
    return {
      transform: `rotate(${this.currentAngle}deg)`,
      transition: this.isDragging ? 'none' : 'transform 0.2s ease'
    }
  }
  
  // 获取位置标记
  get positionMarkers(): Array<{ angle: number; label: string; active: boolean }> {
    const markers = []
    for (let i = 0; i < this.positions; i++) {
      markers.push({
        angle: this.positionToAngle(i),
        label: this.labels?.[i] || `${i + 1}`,
        active: i === this.currentPosition
      })
    }
    return markers
  }
}
```

## 🔢 输入控件详解

### NumericInput 数值输入框

#### 功能特性
- **数值验证**：实时数值格式验证
- **范围限制**：最小值、最大值限制
- **精度控制**：小数位数控制
- **单位支持**：数值单位显示和转换
- **步进控制**：键盘和按钮步进调节

#### 核心实现
```typescript
interface NumericInputProps {
  value?: number
  min?: number
  max?: number
  step?: number
  precision?: number
  unit?: string
  disabled?: boolean
  readonly?: boolean
  placeholder?: string
  showControls?: boolean
  format?: 'decimal' | 'scientific' | 'engineering'
}

class NumericInput extends Vue {
  @Prop() value?: number
  @Prop() min?: number
  @Prop() max?: number
  @Prop({ default: 1 }) step!: number
  @Prop() precision?: number
  @Prop() unit?: string
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: false }) readonly!: boolean
  @Prop() placeholder?: string
  @Prop({ default: true }) showControls!: boolean
  @Prop({ default: 'decimal' }) format!: string
  
  private internalValue: number | null = null
  private displayValue: string = ''
  private isFocused: boolean = false
  private isValid: boolean = true
  private validationMessage: string = ''
  
  created(): void {
    this.internalValue = this.value || null
    this.updateDisplayValue()
  }
  
  watch: {
    value(newValue: number): void {
      this.internalValue = newValue
      this.updateDisplayValue()
    }
  }
  
  // 更新显示值
  private updateDisplayValue(): void {
    if (this.internalValue === null || this.internalValue === undefined) {
      this.displayValue = ''
      return
    }
    
    switch (this.format) {
      case 'scientific':
        this.displayValue = this.internalValue.toExponential(this.precision)
        break
      case 'engineering':
        this.displayValue = this.formatEngineering(this.internalValue)
        break
      default:
        this.displayValue = this.precision !== undefined 
          ? this.internalValue.toFixed(this.precision)
          : this.internalValue.toString()
    }
  }
  
  // 工程计数法格式化
  private formatEngineering(value: number): string {
    if (value === 0) return '0'
    
    const exponent = Math.floor(Math.log10(Math.abs(value)))
    const engineeringExponent = Math.floor(exponent / 3) * 3
    const mantissa = value / Math.pow(10, engineeringExponent)
    
    const precision = this.precision !== undefined ? this.precision : 3
    return `${mantissa.toFixed(precision)}e${engineeringExponent}`
  }
  
  // 输入处理
  handleInput(event: Event): void {
    const target = event.target as HTMLInputElement
    const inputValue = target.value
    
    this.displayValue = inputValue
    
    if (inputValue === '') {
      this.internalValue = null
      this.isValid = true
      this.emitChange()
      return
    }
    
    const numericValue = this.parseNumericValue(inputValue)
    
    if (numericValue !== null) {
      const validatedValue = this.validateValue(numericValue)
      if (validatedValue.isValid) {
        this.internalValue = validatedValue.value
        this.isValid = true
        this.validationMessage = ''
      } else {
        this.isValid = false
        this.validationMessage = validatedValue.message
      }
    } else {
      this.isValid = false
      this.validationMessage = '无效的数值格式'
    }
  }
  
  // 解析数值
  private parseNumericValue(input: string): number | null {
    // 移除单位
    let cleanInput = input
    if (this.unit) {
      cleanInput = input.replace(new RegExp(this.unit + '$'), '').trim()
    }
    
    // 解析科学计数法
    const scientificMatch = cleanInput.match(/^([+-]?\d*\.?\d+)[eE]([+-]?\d+)$/)
    if (scientificMatch) {
      return parseFloat(cleanInput)
    }
    
    // 解析普通数值
    const numericMatch = cleanInput.match(/^[+-]?\d*\.?\d+$/)
    if (numericMatch) {
      return parseFloat(cleanInput)
    }
    
    return null
  }
  
  // 验证数值
  private validateValue(value: number): { isValid: boolean; value: number; message: string } {
    if (isNaN(value)) {
      return { isValid: false, value, message: '无效的数值' }
    }
    
    if (this.min !== undefined && value < this.min) {
      return { isValid: false, value, message: `值不能小于 ${this.min}` }
    }
    
    if (this.max !== undefined && value > this.max) {
      return { isValid: false, value, message: `值不能大于 ${this.max}` }
    }
    
    // 应用精度限制
    let finalValue = value
    if (this.precision !== undefined) {
      finalValue = parseFloat(value.toFixed(this.precision))
    }
    
    return { isValid: true, value: finalValue, message: '' }
  }
  
  // 焦点处理
  handleFocus(): void {
    this.isFocused = true
    
    // 焦点时显示原始数值
    if (this.internalValue !== null) {
      this.displayValue = this.internalValue.toString()
    }
  }
  
  // 失焦处理
  handleBlur(): void {
    this.isFocused = false
    
    if (this.isValid && this.internalValue !== null) {
      this.updateDisplayValue()
      this.emitChange()
    } else if (!this.isValid) {
      // 恢复到上一个有效值
      this.updateDisplayValue()
    }
  }
  
  // 键盘事件处理
  handleKeydown(event: KeyboardEvent): void {
    if (this.disabled || this.readonly) return
    
    switch (event.code) {
      case 'ArrowUp':
        event.preventDefault()
        this.increment()
        break
      case 'ArrowDown':
        event.preventDefault()
        this.decrement()
        break
      case 'Enter':
        this.handleBlur()
        break
    }
  }
  
  // 增加数值
  increment(): void {
    if (this.internalValue === null) {
      this.internalValue = this.min || 0
    } else {
      this.internalValue += this.step
    }
    
    const validated = this.validateValue(this.internalValue)
    if (validated.isValid) {
      this.internalValue = validated.value
      this.updateDisplayValue()
      this.emitChange()
    }
  }
  
  // 减少数值
  decrement(): void {
    if (this.internalValue === null) {
      this.internalValue = this.max || 0
    } else {
      this.internalValue -= this.step
    }
    
    const validated = this.validateValue(this.internalValue)
    if (validated.isValid) {
      this.internalValue = validated.value
      this.updateDisplayValue()
      this.emitChange()
    }
  }
  
  // 发射变化事件
  private emitChange(): void {
    this.$emit('change', {
      value: this.internalValue,
      displayValue: this.displayValue,
      isValid: this.isValid,
      timestamp: Date.now()
    })
    
    this.$emit('input', this.internalValue)
  }
  
  // 获取输入框样式
  get inputClasses(): string[] {
    return [
      'numeric-input',
      {
        'input-focused': this.isFocused,
        'input-disabled': this.disabled,
        'input-readonly': this.readonly,
        'input-invalid': !this.isValid,
        'input-has-controls': this.showControls
      }
    ]
  }
}
```

## 🎚️ 滑动控件详解

### LinearSlider 线性滑块

#### 功能特性
- **精确控制**：支持连续和离散值调节
- **双向滑动**：水平和垂直方向支持
- **范围标记**：可视化的数值范围显示
- **实时反馈**：拖拽过程中的实时数值更新

#### 核心实现
```typescript
interface LinearSliderProps {
  value?: number
  min?: number
  max?: number
  step?: number
  orientation?: 'horizontal' | 'vertical'
  disabled?: boolean
  showTicks?: boolean
  showTooltip?: boolean
  marks?: Array<{ value: number; label: string }>
}

class LinearSlider extends Vue {
  @Prop({ default: 0 }) value!: number
  @Prop({ default: 0 }) min!: number
  @Prop({ default: 100 }) max!: number
  @Prop({ default: 1 }) step!: number
  @Prop({ default: 'horizontal' }) orientation!: string
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: false }) showTicks!: boolean
  @Prop({ default: true }) showTooltip!: boolean
  @Prop() marks?: Array<{ value: number; label: string }>
  
  private internalValue: number = 0
  private isDragging: boolean = false
  private sliderRect: DOMRect | null = null
  private tooltipVisible: boolean = false
  
  mounted(): void {
    this.internalValue = this.clampValue(this.value)
    this.bindEvents()
  }
  
  beforeDestroy(): void {
    this.unbindEvents()
  }
  
  // 限制数值范围
  private clampValue(value: number): number {
    return Math.max(this.min, Math.min(this.max, value))
  }
  
  // 对齐到步进值
  private snapToStep(value: number): number {
    const steps = Math.round((value - this.min) / this.step)
    return this.min + steps * this.step
  }
  
  // 绑定事件
  private bindEvents(): void {
    const slider = this.$refs.slider as HTMLElement
    slider.addEventListener('mousedown', this.handleMouseDown)
    document.addEventListener('mousemove', this.handleMouseMove)
    document.addEventListener('mouseup', this.handleMouseUp)
    
    slider.addEventListener('touchstart', this.handleTouchStart, { passive: false })
    document.addEventListener('touchmove', this.handleTouchMove, { passive: false })
    document.addEventListener('touchend', this.handleTouchEnd)
  }
  
  // 解绑事件
  private unbindEvents(): void {
    const slider = this.$refs.slider as HTMLElement
    slider.removeEventListener('mousedown', this.handleMouseDown)
    document.removeEventListener('mousemove', this.handleMouseMove)
    document.removeEventListener('mouseup', this.handleMouseUp)
    
    slider.removeEventListener('touchstart', this.handleTouchStart)
    document.removeEventListener('touchmove', this.handleTouchMove)
    document.removeEventListener('touchend', this.handleTouchEnd)
  }
  
  // 鼠标按下
  private handleMouseDown(event: MouseEvent): void {
    if (this.disabled) return
    
    this.startDrag(event.clientX, event.clientY)
    event.preventDefault()
  }
  
  // 触摸开始
  private handleTouchStart(event: TouchEvent): void {
    if (this.disabled) return
    
    const touch = event.touches[0]
    this.startDrag(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // 开始拖拽
  private startDrag(clientX: number, clientY: number): void {
    this.isDragging = true
    this.tooltipVisible = true
    this.sliderRect = (this.$refs.slider as HTMLElement).getBoundingClientRect()
    
    this.updateValueFromPosition(clientX, clientY)
    
    this.$emit('dragStart', {
      value: this.internalValue,
      timestamp: Date.now()
    })
  }
  
  // 鼠标移动
  private handleMouseMove(event: MouseEvent): void {
    if (!this.isDragging) return
    
    this.updateValueFromPosition(event.clientX, event.clientY)
  }
  
  // 触摸移动
  private handleTouchMove(event: TouchEvent): void {
    if (!this.isDragging) return
    
    const touch = event.touches[0]
    this.updateValueFromPosition(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // 从位置更新数值
  private updateValueFromPosition(clientX: number, clientY: number): void {
    if (!this.sliderRect) return
    
    let progress: number
    
    if (this.orientation === 'horizontal') {
      progress = (clientX - this.sliderRect.left) / this.sliderRect.width
    } else {
      progress = 1 - (clientY - this.sliderRect.top) / this.sliderRect.height
    }
    
    progress = Math.max(0, Math.min(1, progress))
    
    const rawValue = this.min + progress * (this.max - this.min)
    const steppedValue = this.snapToStep(rawValue)
    
    if (steppedValue !== this.internalValue) {
      this.internalValue = steppedValue
      this.emitChange()
    }
  }
  
  // 鼠标释放
  private handleMouseUp(): void {
    this.endDrag()
  }
  
  // 触摸结束
  private handleTouchEnd(): void {
    this.endDrag()
  }
  
  // 结束拖拽
  private endDrag(): void {
    if (!this.isDragging) return
    
    this.isDragging = false
    this.tooltipVisible = false
    
    this.$emit('dragEnd', {
      value: this.internalValue,
      timestamp: Date.now()
    })
  }
  
  // 点击轨道
  handleTrackClick(event: MouseEvent): void {
    if (this.disabled || this.isDragging) return
    
    this.sliderRect = (this.$refs.slider as HTMLElement).getBoundingClientRect()
    this.updateValueFromPosition(event.clientX, event.clientY)
  }
  
  // 键盘事件处理
  handleKeydown(event: KeyboardEvent): void {
    if (this.disabled) return
    
    let newValue = this.internalValue
    
    switch (event.code) {
      case 'ArrowRight':
      case 'ArrowUp':
        newValue += this.step
        break
      case 'ArrowLeft':
      case 'ArrowDown':
        newValue -= this.step
        break
      case 'Home':
        newValue = this.min
        break
      case 'End':
        newValue = this.max
        break
      case 'PageUp':
        newValue += this.step * 10
        break
      case 'PageDown':
        newValue -= this.step * 10
        break
      default:
        return
    }
    
    event.preventDefault()
    this.internalValue = this.clampValue(newValue)
    this.emitChange()
  }
  
  // 发射变化事件
  private emitChange(): void {
    this.$emit('change', {
      value: this.internalValue,
      percentage: this.valueToPercentage(this.internalValue),
      timestamp: Date.now()
    })
    
    this.$emit('input', this.internalValue)
  }
  
  // 数值转百分比
  private valueToPercentage(value: number): number {
    return ((value - this.min) / (this.max - this.min)) * 100
  }
  
  // 获取滑块位置
  get thumbPosition(): number {
    return this.valueToPercentage(this.internalValue)
  }
  
  // 获取刻度标记
  get tickMarks(): Array<{ position: number; value: number; label?: string }> {
    const ticks = []
    
    if (this.marks) {
      // 使用自定义标记
      for (const mark of this.marks) {
        if (mark.value >= this.min && mark.value <= this.max) {
          ticks.push({
            position: this.valueToPercentage(mark.value),
            value: mark.value,
            label: mark.label
          })
        }
      }
    } else if (this.showTicks) {
      // 自动生成刻度
      const tickCount = Math.min(10, (this.max - this.min) / this.step + 1)
      const tickStep = (this.max - this.min) / (tickCount - 1)
      
      for (let i = 0; i < tickCount; i++) {
        const value = this.min + i * tickStep
        ticks.push({
          position: this.valueToPercentage(value),
          value: value,
          label: value.toString()
        })
      }
    }
    
    return ticks
  }
  
  // 获取滑块样式
  get sliderClasses(): string[] {
    return [
      'linear-slider',
      `slider-${this.orientation}`,
      {
        'slider-disabled': this.disabled,
        'slider-dragging': this.isDragging
      }
    ]
  }
}
```

### RotaryKnob 旋钮控件

#### 功能特性
- **360度旋转**：支持连续和有限角度旋转
- **精密控制**：高精度的数值调节
- **视觉反馈**：清晰的角度和数值指示
- **多种样式**：现代化和经典仪表盘样式

#### 核心实现
```typescript
interface RotaryKnobProps {
  value?: number
  min?: number
  max?: number
  step?: number
  size?: number
  disabled?: boolean
  continuous?: boolean
  startAngle?: number
  endAngle?: number
  showValue?: boolean
  unit?: string
}

class RotaryKnob extends Vue {
  @Prop({ default: 0 }) value!: number
  @Prop({ default: 0 }) min!: number
  @Prop({ default: 100 }) max!: number
  @Prop({ default: 1 }) step!: number
  @Prop({ default: 120 }) size!: number
  @Prop({ default: false }) disabled!: boolean
  @Prop({ default: false }) continuous!: boolean
  @Prop({ default: -135 }) startAngle!: number
  @Prop({ default: 135 }) endAngle!: number
  @Prop({ default: true }) showValue!: boolean
  @Prop() unit?: string
  
  private internalValue: number = 0
  private isDragging: boolean = false
  private lastAngle: number = 0
  private centerX: number = 0
  private centerY: number = 0
  private totalRotation: number = 0
  
  mounted(): void {
    this.internalValue = this.clampValue(this.value)
    this.updateAngleFromValue()
    this.bindEvents()
  }
  
  beforeDestroy(): void {
    this.unbindEvents()
  }
  
  // 限制数值范围
  private clampValue(value: number): number {
    return Math.max(this.min, Math.min(this.max, value))
  }
  
  // 从数值更新角度
  private updateAngleFromValue(): void {
    const progress = (this.internalValue - this.min) / (this.max - this.min)
    const angleRange = this.endAngle - this.startAngle
    this.totalRotation = this.startAngle + progress * angleRange
  }
  
  // 从角度更新数值
  private updateValueFromAngle(): void {
    let normalizedAngle = this.totalRotation
    
    if (!this.continuous) {
      // 限制角度范围
      normalizedAngle = Math.max(this.startAngle, Math.min(this.endAngle, normalizedAngle))
    }
    
    const angleRange = this.endAngle - this.startAngle
    const progress = (normalizedAngle - this.startAngle) / angleRange
    const rawValue = this.min + progress * (this.max - this.min)
    const steppedValue = this.snapToStep(rawValue)
    
    if (steppedValue !== this.internalValue) {
      this.internalValue = this.clampValue(steppedValue)
      this.emitChange()
    }
  }
  
  // 对齐到步进值
  private snapToStep(value: number): number {
    const steps = Math.round((value - this.min) / this.step)
    return this.min + steps * this.step
  }
  
  // 绑定事件
  private bindEvents(): void {
    const knob = this.$refs.knob as HTMLElement
    knob.addEventListener('mousedown', this.handleMouseDown)
    document.addEventListener('mousemove', this.handleMouseMove)
    document.addEventListener('mouseup', this.handleMouseUp)
    
    knob.addEventListener('touchstart', this.handleTouchStart, { passive: false })
    document.addEventListener('touchmove', this.handleTouchMove, { passive: false })
    document.addEventListener('touchend', this.handleTouchEnd)
    
    knob.addEventListener('wheel', this.handleWheel, { passive: false })
  }
  
  // 解绑事件
  private unbindEvents(): void {
    const knob = this.$refs.knob as HTMLElement
    knob.removeEventListener('mousedown', this.handleMouseDown)
    document.removeEventListener('mousemove', this.handleMouseMove)
    document.removeEventListener('mouseup', this.handleMouseUp)
    
    knob.removeEventListener('touchstart', this.handleTouchStart)
    document.removeEventListener('touchmove', this.handleTouchMove)
    document.removeEventListener('touchend', this.handleTouchEnd)
    
    knob.removeEventListener('wheel', this.handleWheel)
  }
  
  // 计算角度
  private calculateAngle(clientX: number, clientY: number): number {
    const deltaX = clientX - this.centerX
    const deltaY = clientY - this.centerY
    return Math.atan2(deltaY, deltaX) * 180 / Math.PI
  }
  
  // 鼠标按下
  private handleMouseDown(event: MouseEvent): void {
    if (this.disabled) return
    
    this.startDrag(event.clientX, event.clientY)
    event.preventDefault()
  }
  
  // 触摸开始
  private handleTouchStart(event: TouchEvent): void {
    if (this.disabled) return
    
    const touch = event.touches[0]
    this.startDrag(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // 开始拖拽
  private startDrag(clientX: number, clientY: number): void {
    const rect = (this.$refs.knob as HTMLElement).getBoundingClientRect()
    this.centerX = rect.left + rect.width / 2
    this.centerY = rect.top + rect.height / 2
    
    this.isDragging = true
    this.lastAngle = this.calculateAngle(clientX, clientY)
    
    this.$emit('dragStart', {
      value: this.internalValue,
      angle: this.totalRotation,
      timestamp: Date.now()
    })
  }
  
  // 鼠标移动
  private handleMouseMove(event: MouseEvent): void {
    if (!this.isDragging) return
    
    this.updateDrag(event.clientX, event.clientY)
  }
  
  // 触摸移动
  private handleTouchMove(event: TouchEvent): void {
    if (!this.isDragging) return
    
    const touch = event.touches[0]
    this.updateDrag(touch.clientX, touch.clientY)
    event.preventDefault()
  }
  
  // 更新拖拽
  private updateDrag(clientX: number, clientY: number): void {
    const currentAngle = this.calculateAngle(clientX, clientY)
    let deltaAngle = currentAngle - this.lastAngle
    
    // 处理角度跨越
    if (deltaAngle > 180) deltaAngle -= 360
    if (deltaAngle < -180) deltaAngle += 360
    
    this.totalRotation += deltaAngle
    this.lastAngle = currentAngle
    
    this.updateValueFromAngle()
  }
  
  // 鼠标释放
  private handleMouseUp(): void {
    this.endDrag()
  }
  
  // 触摸结束
  private handleTouchEnd(): void {
    this.endDrag()
  }
  
  // 结束拖拽
  private endDrag(): void {
    if (!this.isDragging) return
    
    this.isDragging = false
    
    this.$emit('dragEnd', {
      value: this.internalValue,
      angle: this.totalRotation,
      timestamp: Date.now()
    })
  }
  
  // 滚轮事件
  private handleWheel(event: WheelEvent): void {
    if (this.disabled) return
    
    event.preventDefault()
    
    const delta = event.deltaY > 0 ? -this.step : this.step
    this.internalValue = this.clampValue(this.internalValue + delta)
    this.updateAngleFromValue()
    this.emitChange()
  }
  
  // 键盘事件处理
  handleKeydown(event: KeyboardEvent): void {
    if (this.disabled) return
    
    let delta = 0
    
    switch (event.code) {
      case 'ArrowRight':
      case 'ArrowUp':
        delta = this.step
        break
      case 'ArrowLeft':
      case 'ArrowDown':
        delta = -this.step
        break
      case 'Home':
        this.internalValue = this.min
        this.updateAngleFromValue()
        this.emitChange()
        return
      case 'End':
        this.internalValue = this.max
        this.updateAngleFromValue()
        this.emitChange()
        return
      case 'PageUp':
        delta = this.step * 10
        break
      case 'PageDown':
        delta = -this.step * 10
        break
      default:
        return
    }
    
    event.preventDefault()
    this.internalValue = this.clampValue(this.internalValue + delta)
    this.updateAngleFromValue()
    this.emitChange()
  }
  
  // 发射变化事件
  private emitChange(): void {
    this.$emit('change', {
      value: this.internalValue,
      angle: this.totalRotation,
      percentage: this.valueToPercentage(this.internalValue),
      timestamp: Date.now()
    })
    
    this.$emit('input', this.internalValue)
  }
  
  // 数值转百分比
  private valueToPercentage(value: number): number {
    return ((value - this.min) / (this.max - this.min)) * 100
  }
  
  // 获取旋钮样式
  get knobStyle(): object {
    return {
      transform: `rotate(${this.totalRotation}deg)`,
      transition: this.isDragging ? 'none' : 'transform 0.1s ease'
    }
  }
  
  // 获取数值显示
  get displayValue(): string {
    const value = this.internalValue.toFixed(2)
    return this.unit ? `${value} ${this.unit}` : value
  }
  
  // 获取旋钮样式类
  get knobClasses(): string[] {
    return [
      'rotary-knob',
      {
        'knob-disabled': this.disabled,
        'knob-dragging': this.isDragging,
        'knob-continuous': this.continuous
      }
    ]
  }
}
```

## 💡 指示控件详解

### LEDIndicator LED指示灯

#### 功能特性
- **多种颜色**：红、绿、蓝、黄、橙等预设颜色
- **状态指示**：开、关、闪烁、呼吸等状态
- **自定义样式**：可配置大小、形状、亮度
- **动画效果**：平滑的状态切换动画

#### 核心实现
```typescript
interface LEDIndicatorProps {
  state?: 'off' | 'on' | 'blink' | 'pulse'
  color?: string
  size?: 'small' | 'medium' | 'large'
  shape?: 'circle' | 'square' | 'diamond'
  intensity?: number
  blinkRate?: number
  label?: string
}

class LEDIndicator extends Vue {
  @Prop({ default: 'off' }) state!: string
  @Prop({ default: '#00ff00' }) color!: string
  @Prop({ default: 'medium' }) size!: string
  @Prop({ default: 'circle' }) shape!: string
  @Prop({ default: 1 }) intensity!: number
  @Prop({ default: 500 }) blinkRate!: number
  @Prop() label?: string
  
  private animationId: number | null = null
  private isVisible: boolean = true
  private pulsePhase: number = 0
  
  mounted(): void {
    this.startAnimation()
  }
  
  beforeDestroy(): void {
    this.stopAnimation()
  }
  
  watch: {
    state(): void {
      this.startAnimation()
    },
    blinkRate(): void {
      if (this.state === 'blink') {
        this.startAnimation()
      }
    }
  }
  
  // 开始动画
  private startAnimation(): void {
    this.stopAnimation()
    
    switch (this.state) {
      case 'on':
        this.isVisible = true
        break
      case 'off':
        this.isVisible = false
        break
      case 'blink':
        this.startBlinkAnimation()
        break
      case 'pulse':
        this.startPulseAnimation()
        break
    }
  }
  
  // 停止动画
  private stopAnimation(): void {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId)
      this.animationId = null
    }
  }
  
  // 闪烁动画
  private startBlinkAnimation(): void {
    let lastTime = 0
    
    const animate = (currentTime: number) => {
      if (currentTime - lastTime >= this.blinkRate) {
        this.isVisible = !this.isVisible
        lastTime = currentTime
      }
      
      if (this.state === 'blink') {
        this.animationId = requestAnimationFrame(animate)
      }
    }
    
    this.animationId = requestAnimationFrame(animate)
  }
  
  // 脉冲动画
  private startPulseAnimation(): void {
    const animate = () => {
      this.pulsePhase += 0.05
      if (this.pulsePhase >= Math.PI * 2) {
        this.pulsePhase = 0
      }
      
      if (this.state === 'pulse') {
        this.animationId = requestAnimationFrame(animate)
      }
    }
    
    this.animationId = requestAnimationFrame(animate)
  }
  
  // 获取LED样式
  get ledStyle(): object {
    const baseStyle: any = {
      backgroundColor: this.color,
      opacity: this.calculateOpacity(),
      boxShadow: this.calculateGlow()
    }
    
    // 根据尺寸设置大小
    const sizeMap = {
      small: '12px',
      medium: '16px',
      large: '24px'
    }
    
    const size = sizeMap[this.size] || sizeMap.medium
    baseStyle.width = size
    baseStyle.height = size
    
    // 根据形状设置样式
    switch (this.shape) {
      case 'circle':
        baseStyle.borderRadius = '50%'
        break
      case 'square':
        baseStyle.borderRadius = '2px'
        break
      case 'diamond':
        baseStyle.borderRadius = '2px'
        baseStyle.transform = 'rotate(45deg)'
        break
    }
    
    return baseStyle
  }
  
  // 计算透明度
  private calculateOpacity(): number {
    switch (this.state) {
      case 'off':
        return 0.2
      case 'on':
        return this.intensity
      case 'blink':
        return this.isVisible ? this.intensity : 0.2
      case 'pulse':
        const pulseIntensity = (Math.sin(this.pulsePhase) + 1) / 2
        return 0.2 + pulseIntensity * (this.intensity - 0.2)
      default:
        return this.intensity
    }
  }
  
  // 计算发光效果
  private calculateGlow(): string {
    const opacity = this.calculateOpacity()
    if (opacity <= 0.2) return 'none'
    
    const glowIntensity = opacity * 0.8
    return `0 0 10px ${this.color}${Math.round(glowIntensity * 255).toString(16).padStart(2, '0')}`
  }
  
  // 获取LED样式类
  get ledClasses(): string[] {
    return [
      'led-indicator',
      `led-${this.size}`,
      `led-${this.shape}`,
      `led-${this.state}`
    ]
  }
}
```

## 📊 最佳实践和使用指南

### 控件选择原则

#### 1. 按钮控件选择
```typescript
// 标准操作按钮
<StandardButton type="primary" @click="handleSave">保存</StandardButton>

// 状态切换按钮
<ToggleButton v-model="isEnabled" exclusive group-name="mode">启用</ToggleButton>

// 危险操作按钮
<StandardButton type="danger" @click="handleDelete">删除</StandardButton>
```

#### 2. 开关控件选择
```typescript
// 简单开关
<ToggleSwitch v-model="power" color="#ff4d4f">电源</ToggleSwitch>

// 多位置选择
<RotarySwitch :positions="8" v-model="mode" :labels="modeLabels" />
```

#### 3. 输入控件选择
```typescript
// 精确数值输入
<NumericInput 
  v-model="frequency" 
  :min="1" 
  :max="1000000" 
  :step="0.1" 
  unit="Hz"
  format="engineering"
/>

// 范围调节
<LinearSlider 
  v-model="amplitude" 
  :min="0" 
  :max="10" 
  :step="0.01" 
  show-tooltip
/>
```

### 性能优化建议

#### 1. 事件处理优化
```typescript
// 使用防抖处理高频事件
import { debounce } from 'lodash-es'

class OptimizedSlider extends LinearSlider {
  private debouncedEmit = debounce((value: number) => {
    this.$emit('change', value)
  }, 16) // 60fps
  
  protected emitChange(): void {
    this.debouncedEmit(this.internalValue)
  }
}
```

#### 2. 内存管理优化
```typescript
// 及时清理事件监听器
class MemoryOptimizedControl extends Vue {
  private eventListeners: Array<() => void> = []
  
  mounted(): void {
    const cleanup = this.bindEvents()
    this.eventListeners.push(cleanup)
  }
  
  beforeDestroy(): void {
    this.eventListeners.forEach(cleanup => cleanup())
    this.eventListeners = []
  }
  
  private bindEvents(): () => void {
    const handler = this.handleEvent.bind(this)
    document.addEventListener('mousemove', handler)
    
    return () => {
      document.removeEventListener('mousemove', handler)
    }
  }
}
```

#### 3. 渲染性能优化
```typescript
// 使用计算属性缓存复杂计算
class PerformantControl extends Vue {
  @Prop() data!: number[]
  
  // 缓存复杂计算结果
  get processedData(): ProcessedData {
    return this.data.map(value => ({
      value,
      normalized: this.normalizeValue(value),
      formatted: this.formatValue(value)
    }))
  }
  
  // 使用 shouldUpdate 避免不必要的重渲染
  shouldComponentUpdate(nextProps: any): boolean {
    return nextProps.value !== this.value
  }
}
```

### 无障碍访问支持

#### 1. 键盘导航
```typescript
// 完整的键盘支持
class AccessibleControl extends Vue {
  private focusIndex: number = 0
  
  handleKeydown(event: KeyboardEvent): void {
    switch (event.code) {
      case 'Tab':
        this.handleTabNavigation(event)
        break
      case 'Enter':
      case 'Space':
        this.handleActivation(event)
        break
      case 'Escape':
        this.handleEscape(event)
        break
      case 'ArrowUp':
      case 'ArrowDown':
      case 'ArrowLeft':
      case 'ArrowRight':
        this.handleArrowNavigation(event)
        break
    }
  }
  
  private handleTabNavigation(event: KeyboardEvent): void {
    // 实现Tab键导航逻辑
    const focusableElements = this.getFocusableElements()
    if (event.shiftKey) {
      this.focusIndex = Math.max(0, this.focusIndex - 1)
    } else {
      this.focusIndex = Math.min(focusableElements.length - 1, this.focusIndex + 1)
    }
    focusableElements[this.focusIndex]?.focus()
    event.preventDefault()
  }
}
```

#### 2. ARIA属性支持
```vue
<template>
  <div
    class="control-element"
    :aria-label="ariaLabel"
    :aria-valuemin="min"
    :aria-valuemax="max"
    :aria-valuenow="value"
    :aria-valuetext="ariaValueText"
    :aria-disabled="disabled"
    role="slider"
    tabindex="0"
    @keydown="handleKeydown"
  >
    <div class="control-track" aria-hidden="true">
      <div class="control-thumb" :style="thumbStyle" />
    </div>
    <div class="sr-only">{{ screenReaderText }}</div>
  </div>
</template>

<script lang="ts">
export default class AccessibleSlider extends Vue {
  get ariaLabel(): string {
    return this.label || `调节 ${this.unit || '数值'}`
  }
  
  get ariaValueText(): string {
    return `${this.value} ${this.unit || ''}`
  }
  
  get screenReaderText(): string {
    return `当前值: ${this.ariaValueText}, 最小值: ${this.min}, 最大值: ${this.max}`
  }
}
</script>
```

### 主题和样式定制

#### 1. CSS变量系统
```scss
// 控件主题变量
:root {
  // 基础颜色
  --control-primary-color: #1890ff;
  --control-success-color: #52c41a;
  --control-warning-color: #faad14;
  --control-danger-color: #ff4d4f;
  
  // 尺寸变量
  --control-border-radius: 4px;
  --control-padding: 8px 16px;
  --control-font-size: 14px;
  
  // 状态颜色
  --control-hover-color: rgba(24, 144, 255, 0.1);
  --control-active-color: rgba(24, 144, 255, 0.2);
  --control-disabled-color: #f5f5f5;
  
  // 阴影效果
  --control-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  --control-shadow-hover: 0 4px 12px rgba(0, 0, 0, 0.15);
}

// 深色主题
[data-theme="dark"] {
  --control-primary-color: #177ddc;
  --control-disabled-color: #262626;
  --control-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
```

#### 2. 动态主题切换
```typescript
class ThemeManager {
  private currentTheme: string = 'light'
  
  setTheme(theme: string): void {
    this.currentTheme = theme
    document.documentElement.setAttribute('data-theme', theme)
    
    // 触发主题变更事件
    window.dispatchEvent(new CustomEvent('themeChange', {
      detail: { theme }
    }))
  }
  
  getTheme(): string {
    return this.currentTheme
  }
  
  // 自动检测系统主题
  detectSystemTheme(): string {
    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark'
    }
    return 'light'
  }
}
```

### 国际化支持

#### 1. 多语言文本
```typescript
// 国际化配置
const i18nMessages = {
  'zh-CN': {
    controls: {
      increment: '增加',
      decrement: '减少',
      reset: '重置',
      confirm: '确认',
      cancel: '取消',
      loading: '加载中...',
      error: '错误',
      success: '成功'
    }
  },
  'en-US': {
    controls: {
      increment: 'Increment',
      decrement: 'Decrement',
      reset: 'Reset',
      confirm: 'Confirm',
      cancel: 'Cancel',
      loading: 'Loading...',
      error: 'Error',
      success: 'Success'
    }
  }
}

class I18nControl extends Vue {
  get t(): (key: string) => string {
    return (key: string) => {
      const locale = this.$i18n.locale
      const keys = key.split('.')
      let value = i18nMessages[locale]
      
      for (const k of keys) {
        value = value?.[k]
      }
      
      return value || key
    }
  }
}
```

#### 2. 数值格式化
```typescript
class NumberFormatter {
  private locale: string
  private options: Intl.NumberFormatOptions
  
  constructor(locale: string = 'zh-CN') {
    this.locale = locale
    this.options = {
      minimumFractionDigits: 0,
      maximumFractionDigits: 3
    }
  }
  
  format(value: number, unit?: string): string {
    const formatter = new Intl.NumberFormat(this.locale, this.options)
    const formattedValue = formatter.format(value)
    
    return unit ? `${formattedValue} ${unit}` : formattedValue
  }
  
  formatCurrency(value: number, currency: string = 'CNY'): string {
    const formatter = new Intl.NumberFormat(this.locale, {
      style: 'currency',
      currency
    })
    
    return formatter.format(value)
  }
  
  formatPercentage(value: number): string {
    const formatter = new Intl.NumberFormat(this.locale, {
      style: 'percent',
      minimumFractionDigits: 1,
      maximumFractionDigits: 2
    })
    
    return formatter.format(value / 100)
  }
}
```

## 🔧 故障排除和常见问题

### 常见问题解决

#### 1. 控件响应性问题
```typescript
// 问题：控件在移动设备上响应缓慢
// 解决方案：优化触摸事件处理
class ResponsiveControl extends Vue {
  private touchStartTime: number = 0
  
  handleTouchStart(event: TouchEvent): void {
    this.touchStartTime = Date.now()
    
    // 防止默认行为，提高响应速度
    event.preventDefault()
    
    // 使用 passive: false 确保可以阻止默认行为
    this.startInteraction(event.touches[0])
  }
  
  handleTouchMove(event: TouchEvent): void {
    // 限制处理频率，避免性能问题
    const now = Date.now()
    if (now - this.touchStartTime < 16) return // 60fps
    
    this.updateInteraction(event.touches[0])
  }
}
```

#### 2. 数值精度问题
```typescript
// 问题：浮点数计算精度丢失
// 解决方案：使用精度安全的数学运算
class PrecisionMath {
  static add(a: number, b: number, precision: number = 10): number {
    const factor = Math.pow(10, precision)
    return Math.round((a + b) * factor) / factor
  }
  
  static subtract(a: number, b: number, precision: number = 10): number {
    const factor = Math.pow(10, precision)
    return Math.round((a - b) * factor) / factor
  }
  
  static multiply(a: number, b: number, precision: number = 10): number {
    const factor = Math.pow(10, precision)
    return Math.round(a * b * factor) / factor
  }
  
  static divide(a: number, b: number, precision: number = 10): number {
    if (b === 0) throw new Error('Division by zero')
    const factor = Math.pow(10, precision)
    return Math.round((a / b) * factor) / factor
  }
}
```

#### 3. 内存泄漏问题
```typescript
// 问题：长时间使用后内存占用过高
// 解决方案：完善的资源清理机制
class MemoryManagedControl extends Vue {
  private timers: number[] = []
  private observers: ResizeObserver[] = []
  private eventCleanups: Array<() => void> = []
  
  mounted(): void {
    this.setupResizeObserver()
    this.setupEventListeners()
  }
  
  beforeDestroy(): void {
    // 清理定时器
    this.timers.forEach(timer => clearTimeout(timer))
    this.timers = []
    
    // 清理观察器
    this.observers.forEach(observer => observer.disconnect())
    this.observers = []
    
    // 清理事件监听器
    this.eventCleanups.forEach(cleanup => cleanup())
    this.eventCleanups = []
  }
  
  private setupResizeObserver(): void {
    const observer = new ResizeObserver(entries => {
      this.handleResize(entries)
    })
    
    observer.observe(this.$el as Element)
    this.observers.push(observer)
  }
  
  private addTimer(callback: () => void, delay: number): void {
    const timer = setTimeout(callback, delay)
    this.timers.push(timer)
  }
}
```

### 调试工具

#### 1. 控件状态监控
```typescript
class ControlDebugger {
  private static instance: ControlDebugger
  private controls: Map<string, any> = new Map()
  
  static getInstance(): ControlDebugger {
    if (!this.instance) {
      this.instance = new ControlDebugger()
    }
    return this.instance
  }
  
  registerControl(id: string, control: any): void {
    this.controls.set(id, control)
    console.log(`Control registered: ${id}`, control)
  }
  
  unregisterControl(id: string): void {
    this.controls.delete(id)
    console.log(`Control unregistered: ${id}`)
  }
  
  getControlState(id: string): any {
    const control = this.controls.get(id)
    if (!control) return null
    
    return {
      id,
      type: control.constructor.name,
      value: control.value,
      disabled: control.disabled,
      focused: control.isFocused,
      valid: control.isValid
    }
  }
  
  getAllControlStates(): any[] {
    return Array.from(this.controls.keys()).map(id => this.getControlState(id))
  }
}
```

#### 2. 性能分析工具
```typescript
class PerformanceProfiler {
  private measurements: Map<string, number[]> = new Map()
  
  startMeasurement(name: string): void {
    performance.mark(`${name}-start`)
  }
  
  endMeasurement(name: string): number {
    performance.mark(`${name}-end`)
    performance.measure(name, `${name}-start`, `${name}-end`)
    
    const measure = performance.getEntriesByName(name, 'measure')[0]
    const duration = measure.duration
    
    if (!this.measurements.has(name)) {
      this.measurements.set(name, [])
    }
    
    this.measurements.get(name)!.push(duration)
    
    // 清理性能标记
    performance.clearMarks(`${name}-start`)
    performance.clearMarks(`${name}-end`)
    performance.clearMeasures(name)
    
    return duration
  }
  
  getAverageTime(name: string): number {
    const times = this.measurements.get(name)
    if (!times || times.length === 0) return 0
    
    return times.reduce((sum, time) => sum + time, 0) / times.length
  }
  
  getReport(): Record<string, { average: number; count: number; total: number }> {
    const report: Record<string, any> = {}
    
    for (const [name, times] of this.measurements) {
      report[name] = {
        average: this.getAverageTime(name),
        count: times.length,
        total: times.reduce((sum, time) => sum + time, 0)
      }
    }
    
    return report
  }
}
```

## 🚀 未来发展方向

### 技术演进

#### 1. Web Components标准化
```typescript
// 基于Web Components的控件实现
class WebComponentControl extends HTMLElement {
  private shadow: ShadowRoot
  private template: HTMLTemplateElement
  
  constructor() {
    super()
    this.shadow = this.attachShadow({ mode: 'open' })
    this.setupTemplate()
  }
  
  connectedCallback(): void {
    this.render()
    this.bindEvents()
  }
  
  disconnectedCallback(): void {
    this.cleanup()
  }
  
  attributeChangedCallback(name: string, oldValue: string, newValue: string): void {
    this.handleAttributeChange(name, oldValue, newValue)
  }
  
  static get observedAttributes(): string[] {
    return ['value', 'disabled', 'min', 'max']
  }
}

// 注册自定义元素
customElements.define('seesharp-slider', WebComponentControl)
```

#### 2. AI辅助控件生成
```typescript
// AI驱动的控件自动生成
class AIControlGenerator {
  async generateControl(description: string): Promise<ControlDefinition> {
    const prompt = this.buildPrompt(description)
    const response = await this.callAIService(prompt)
    
    return this.parseControlDefinition(response)
  }
  
  private buildPrompt(description: string): string {
    return `
      基于以下描述生成一个Vue控件:
      ${description}
      
      要求:
      1. 符合SeeSharpTools设计规范
      2. 包含完整的TypeScript类型定义
      3. 支持无障碍访问
      4. 具备响应式设计
      5. 包含单元测试
    `
  }
  
  private async callAIService(prompt: string): Promise<string> {
    // 调用AI服务API
    const response = await fetch('/api/ai/generate-control', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ prompt })
    })
    
    return response.text()
  }
}
```

#### 3. 虚拟现实集成
```typescript
// VR/AR环境中的3D控件
class VRControl extends Vue {
  private scene: THREE.Scene
  private camera: THREE.Camera
  private renderer: THREE.WebGLRenderer
  
  mounted(): void {
    this.initVREnvironment()
    this.create3DControl()
  }
  
  private initVREnvironment(): void {
    this.scene = new THREE.Scene()
    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000)
    this.renderer = new THREE.WebGLRenderer({ antialias: true })
    
    // 启用VR支持
    this.renderer.xr.enabled = true
    document.body.appendChild(VRButton.createButton(this.renderer))
  }
  
  private create3DControl(): void {
    // 创建3D控件几何体
    const geometry = new THREE.CylinderGeometry(1, 1, 0.2, 32)
    const material = new THREE.MeshPhongMaterial({ color: 0x1890ff })
    const knob = new THREE.Mesh(geometry, material)
    
    this.scene.add(knob)
    
    // 添加交互逻辑
    this.setupVRInteraction(knob)
  }
}
```

---

*控制元件是用户界面的基础构建块，通过合理的设计和实现，可以为用户提供直观、高效的交互体验。随着技术的不断发展，控制元件将朝着更加智能化、个性化的方向演进。*
