# ğŸ“ˆ SeeSharpTools Web å›¾è¡¨æ§ä»¶è¯¦è§£

## ğŸ“‹ æ§ä»¶æ¦‚è¿°

SeeSharpTools Webçš„å›¾è¡¨æ§ä»¶æ˜¯ä¸“ä¸ºç§‘å­¦æµ‹é‡å’Œæ•°æ®åˆ†æè®¾è®¡çš„é«˜æ€§èƒ½å¯è§†åŒ–ç»„ä»¶ã€‚åŸºäºEChartså¼•æ“æ„å»ºï¼Œæä¾›äº†ä¸°å¯Œçš„å›¾è¡¨ç±»å‹ã€å¼ºå¤§çš„æ•°æ®å¤„ç†èƒ½åŠ›å’Œä¸“ä¸šçš„åˆ†æå·¥å…·ã€‚è¿™äº›æ§ä»¶å¹¿æ³›åº”ç”¨äºä¿¡å·åˆ†æã€é¢‘è°±åˆ†æã€æ³¢å½¢æ˜¾ç¤ºã€æ•°æ®ç›‘æ§ç­‰æµ‹æ§åœºæ™¯ã€‚

### ğŸ¯ æ ¸å¿ƒç‰¹æ€§
- **é«˜æ€§èƒ½æ¸²æŸ“**ï¼šæ”¯æŒå¤§æ•°æ®é‡å®æ—¶æ˜¾ç¤º
- **ä¸“ä¸šåˆ†æå·¥å…·**ï¼šå†…ç½®FFTã€å³°å€¼æ£€æµ‹ã€ç»Ÿè®¡åˆ†æ
- **ä¸°å¯Œäº¤äº’åŠŸèƒ½**ï¼šç¼©æ”¾ã€æ¸¸æ ‡ã€æµ‹é‡ã€å¯¼å‡º
- **å¤šç§å›¾è¡¨ç±»å‹**ï¼šçº¿å›¾ã€æ¡å½¢å›¾ã€æ•£ç‚¹å›¾ã€é¢‘è°±å›¾

## ğŸ—ï¸ å›¾è¡¨æ§ä»¶ä½“ç³»

### æ§ä»¶åˆ†ç±»æ¶æ„
```
å›¾è¡¨æ§ä»¶ç³»ç»Ÿ
â”œâ”€â”€ åŸºç¡€å›¾è¡¨
â”‚   â”œâ”€â”€ EnhancedEasyChart (å¢å¼ºå‹çº¿å›¾)
â”‚   â”œâ”€â”€ StripChart (æ¡å¸¦å›¾)
â”‚   â”œâ”€â”€ SpectrumChart (é¢‘è°±å›¾)
â”‚   â””â”€â”€ WaveformChart (æ³¢å½¢å›¾)
â”œâ”€â”€ ä¸“ä¸šå›¾è¡¨
â”‚   â”œâ”€â”€ DualAxisEasyChart (åŒè½´å›¾è¡¨)
â”‚   â”œâ”€â”€ ProfessionalEasyChart (ä¸“ä¸šå›¾è¡¨)
â”‚   â””â”€â”€ AdvancedEasyChart (é«˜çº§å›¾è¡¨)
â”œâ”€â”€ åˆ†æå·¥å…·
â”‚   â”œâ”€â”€ FFTåˆ†æå™¨
â”‚   â”œâ”€â”€ å³°å€¼æ£€æµ‹å™¨
â”‚   â”œâ”€â”€ ç»Ÿè®¡åˆ†æå™¨
â”‚   â””â”€â”€ æ¸¸æ ‡æµ‹é‡å™¨
â””â”€â”€ æ•°æ®å¤„ç†
    â”œâ”€â”€ æ•°æ®ç¼“å†²ç®¡ç†
    â”œâ”€â”€ å®æ—¶æ•°æ®æµ
    â”œâ”€â”€ æ•°æ®å‹ç¼©
    â””â”€â”€ å¯¼å‡ºåŠŸèƒ½
```

### æ ¸å¿ƒæ¥å£å®šä¹‰
```typescript
// å›¾è¡¨æ•°æ®æ¥å£
interface ChartData {
  series: number[] | number[][]  // æ•°æ®ç³»åˆ—
  labels?: string[]              // Xè½´æ ‡ç­¾
  xStart?: number               // Xè½´èµ·å§‹å€¼
  xInterval?: number            // Xè½´é—´éš”
  timestamp?: number            // æ—¶é—´æˆ³
}

// å›¾è¡¨é…ç½®æ¥å£
interface ChartOptions {
  autoScale: boolean            // è‡ªåŠ¨ç¼©æ”¾
  logarithmic: boolean          // å¯¹æ•°åæ ‡
  splitView: boolean           // åˆ†å±æ˜¾ç¤º
  legendVisible: boolean       // æ˜¾ç¤ºå›¾ä¾‹
  cursorMode: 'zoom' | 'measure' // æ¸¸æ ‡æ¨¡å¼
  gridEnabled: boolean         // æ˜¾ç¤ºç½‘æ ¼
  minorGridEnabled: boolean    // æ˜¾ç¤ºæ¬¡ç½‘æ ¼
  theme: 'light' | 'dark' | 'scientific' // ä¸»é¢˜
}

// ç³»åˆ—é…ç½®æ¥å£
interface SeriesConfig {
  name: string                 // ç³»åˆ—åç§°
  color: string               // é¢œè‰²
  lineWidth: number           // çº¿å®½
  lineType: 'solid' | 'dashed' | 'dotted' // çº¿å‹
  markerType: 'none' | 'circle' | 'square' | 'triangle' // æ ‡è®°ç±»å‹
  markerSize: number          // æ ‡è®°å¤§å°
  visible: boolean            // æ˜¯å¦å¯è§
}
```

## ğŸ“Š EnhancedEasyChart è¯¦è§£

### ç»„ä»¶æ¶æ„

#### åŠŸèƒ½æ¨¡å—ç»„æˆ
```
EnhancedEasyChart
â”œâ”€â”€ å·¥å…·æ æ¨¡å—
â”‚   â”œâ”€â”€ åŸºç¡€æ“ä½œ (é‡ç½®ã€å¯¼å‡º)
â”‚   â”œâ”€â”€ FFTåˆ†ææ§åˆ¶
â”‚   â”œâ”€â”€ æµ‹é‡å·¥å…·
â”‚   â””â”€â”€ æ˜¾ç¤ºé€‰é¡¹
â”œâ”€â”€ å›¾è¡¨æ¸²æŸ“æ¨¡å—
â”‚   â”œâ”€â”€ ä¸»å›¾è¡¨åŒºåŸŸ
â”‚   â”œâ”€â”€ FFTå›¾è¡¨åŒºåŸŸ
â”‚   â””â”€â”€ å…¨å±æ˜¾ç¤º
â”œâ”€â”€ æ§åˆ¶é¢æ¿æ¨¡å—
â”‚   â”œâ”€â”€ æ˜¾ç¤ºé€‰é¡¹
â”‚   â”œâ”€â”€ åæ ‡è½´è®¾ç½®
â”‚   â”œâ”€â”€ æ•°å­¦åŠŸèƒ½
â”‚   â””â”€â”€ ä¸»é¢˜é€‰æ‹©
â”œâ”€â”€ æµ‹é‡é¢æ¿æ¨¡å—
â”‚   â”œâ”€â”€ æ¸¸æ ‡æµ‹é‡
â”‚   â”œâ”€â”€ å³°å€¼æ£€æµ‹
â”‚   â””â”€â”€ ç»Ÿè®¡åˆ†æ
â””â”€â”€ çŠ¶æ€ä¿¡æ¯æ¨¡å—
    â”œâ”€â”€ æ•°æ®ç»Ÿè®¡
    â”œâ”€â”€ æ¸¸æ ‡ä½ç½®
    â””â”€â”€ ç³»ç»ŸçŠ¶æ€
```

#### æ ¸å¿ƒå±æ€§é…ç½®
```typescript
interface EnhancedEasyChartProps {
  data?: ChartData              // å›¾è¡¨æ•°æ®
  options?: Partial<ChartOptions> // å›¾è¡¨é€‰é¡¹
  seriesConfigs?: SeriesConfig[] // ç³»åˆ—é…ç½®
  showToolbar?: boolean         // æ˜¾ç¤ºå·¥å…·æ 
  showControls?: boolean        // æ˜¾ç¤ºæ§åˆ¶é¢æ¿
  showStatus?: boolean          // æ˜¾ç¤ºçŠ¶æ€æ 
  width?: string | number       // å®½åº¦
  height?: string | number      // é«˜åº¦
  sampleRate?: number          // é‡‡æ ·ç‡
  events?: ChartEvents         // äº‹ä»¶å›è°ƒ
}
```

### å·¥å…·æ åŠŸèƒ½è¯¦è§£

#### 1. åŸºç¡€æ“ä½œå·¥å…·
```vue
<template>
  <el-button-group>
    <el-button size="small" @click="resetZoom">
      <el-icon><Refresh /></el-icon>
      é‡ç½®
    </el-button>
    <el-button size="small" @click="exportChart('png')">
      <el-icon><Download /></el-icon>
      å¯¼å‡ºå›¾ç‰‡
    </el-button>
    <el-button size="small" @click="exportChart('csv')">
      <el-icon><Document /></el-icon>
      å¯¼å‡ºCSV
    </el-button>
  </el-button-group>
</template>
```

**åŠŸèƒ½è¯´æ˜**ï¼š
- **é‡ç½®ç¼©æ”¾**ï¼šæ¢å¤å›¾è¡¨åˆ°åˆå§‹æ˜¾ç¤ºèŒƒå›´
- **å¯¼å‡ºå›¾ç‰‡**ï¼šå°†å›¾è¡¨å¯¼å‡ºä¸ºPNGæ ¼å¼
- **å¯¼å‡ºCSV**ï¼šå°†æ•°æ®å¯¼å‡ºä¸ºCSVæ–‡ä»¶

#### 2. FFTåˆ†æå·¥å…·
```vue
<template>
  <el-button-group>
    <el-button 
      size="small" 
      :type="showFFT ? 'primary' : 'default'"
      @click="toggleFFT"
    >
      <el-icon><TrendCharts /></el-icon>
      FFTåˆ†æ
    </el-button>
    <el-button 
      size="small" 
      :disabled="!showFFT"
      @click="showFFTSettings = true"
    >
      <el-icon><Setting /></el-icon>
      FFTè®¾ç½®
    </el-button>
  </el-button-group>
</template>
```

**FFTé…ç½®é€‰é¡¹**ï¼š
```typescript
interface FFTConfig {
  size: number                 // FFTå¤§å° (512, 1024, 2048, 4096, 8192)
  window: 'rectangular' | 'hanning' | 'hamming' | 'blackman' | 'kaiser' // çª—å‡½æ•°
  overlap: number             // é‡å ç‡ (0-75%)
  displayMode: 'magnitude' | 'power' | 'phase' // æ˜¾ç¤ºæ¨¡å¼
  frequencyUnit: 'Hz' | 'kHz' | 'MHz' // é¢‘ç‡å•ä½
}
```

#### 3. æµ‹é‡å·¥å…·
```vue
<template>
  <el-button-group>
    <el-button 
      size="small" 
      :type="measurementMode === 'cursor' ? 'primary' : 'default'"
      @click="toggleMeasurement('cursor')"
    >
      <el-icon><Aim /></el-icon>
      æ¸¸æ ‡
    </el-button>
    <el-button 
      size="small" 
      :type="measurementMode === 'peak' ? 'primary' : 'default'"
      @click="toggleMeasurement('peak')"
    >
      <el-icon><Top /></el-icon>
      å³°å€¼
    </el-button>
  </el-button-group>
</template>
```

**æµ‹é‡åŠŸèƒ½**ï¼š
- **æ¸¸æ ‡æµ‹é‡**ï¼šäº¤äº’å¼åå­—æ¸¸æ ‡ï¼Œæ˜¾ç¤ºç²¾ç¡®åæ ‡
- **å³°å€¼æ£€æµ‹**ï¼šè‡ªåŠ¨æ£€æµ‹ä¿¡å·å³°å€¼ç‚¹
- **ç»Ÿè®¡åˆ†æ**ï¼šè®¡ç®—å‡å€¼ã€RMSã€æ ‡å‡†å·®ç­‰

### FFTåˆ†æç³»ç»Ÿè¯¦è§£

#### FFTè®¡ç®—å¼•æ“
```typescript
const computeFFT = (data: number[]): { frequencies: number[]; magnitudes: number[] } => {
  const size = Math.min(fftConfig.value.size, data.length)
  const windowedData = applyWindow(data.slice(0, size), fftConfig.value.window)
  
  const frequencies: number[] = []
  const magnitudes: number[] = []
  
  const sampleRate = props.sampleRate
  const frequencyResolution = sampleRate / size
  
  // FFTè®¡ç®—æ ¸å¿ƒç®—æ³•
  for (let k = 0; k < size / 2; k++) {
    let realSum = 0
    let imagSum = 0
    
    for (let n = 0; n < size; n++) {
      const angle = -2 * Math.PI * k * n / size
      realSum += windowedData[n] * Math.cos(angle)
      imagSum += windowedData[n] * Math.sin(angle)
    }
    
    const magnitude = Math.sqrt(realSum * realSum + imagSum * imagSum)
    const frequency = k * frequencyResolution
    
    frequencies.push(frequency)
    
    // æ ¹æ®æ˜¾ç¤ºæ¨¡å¼è®¡ç®—å¹…åº¦
    switch (fftConfig.value.displayMode) {
      case 'magnitude':
        magnitudes.push(magnitude)
        break
      case 'power':
        magnitudes.push(magnitude * magnitude)
        break
      case 'phase':
        magnitudes.push(Math.atan2(imagSum, realSum) * 180 / Math.PI)
        break
    }
  }
  
  return { frequencies, magnitudes }
}
```

#### çª—å‡½æ•°å®ç°
```typescript
const applyWindow = (data: number[], windowType: string): number[] => {
  const size = data.length
  const windowed = [...data]
  
  switch (windowType) {
    case 'hanning':
      for (let i = 0; i < size; i++) {
        const window = 0.5 * (1 - Math.cos(2 * Math.PI * i / (size - 1)))
        windowed[i] *= window
      }
      break
      
    case 'hamming':
      for (let i = 0; i < size; i++) {
        const window = 0.54 - 0.46 * Math.cos(2 * Math.PI * i / (size - 1))
        windowed[i] *= window
      }
      break
      
    case 'blackman':
      for (let i = 0; i < size; i++) {
        const window = 0.42 - 0.5 * Math.cos(2 * Math.PI * i / (size - 1)) + 
                      0.08 * Math.cos(4 * Math.PI * i / (size - 1))
        windowed[i] *= window
      }
      break
      
    case 'rectangular':
    default:
      // ä¸åº”ç”¨çª—å‡½æ•°
      break
  }
  
  return windowed
}
```

**çª—å‡½æ•°ç‰¹æ€§å¯¹æ¯”**ï¼š
- **çŸ©å½¢çª—**ï¼šæœ€ç®€å•ï¼Œé¢‘ç‡åˆ†è¾¨ç‡æœ€é«˜ï¼Œä½†é¢‘è°±æ³„æ¼ä¸¥é‡
- **æ±‰å®çª—**ï¼šè‰¯å¥½çš„é¢‘è°±æ³„æ¼æŠ‘åˆ¶ï¼Œé€‚ç”¨äºå¤§å¤šæ•°åº”ç”¨
- **æ±‰æ˜çª—**ï¼šæ¯”æ±‰å®çª—æ›´å¥½çš„ä¸»ç“£ç‰¹æ€§
- **å¸ƒè±å…‹æ›¼çª—**ï¼šæœ€ä½³çš„é¢‘è°±æ³„æ¼æŠ‘åˆ¶ï¼Œä½†ä¸»ç“£è¾ƒå®½
- **å‡¯æ³½çª—**ï¼šå¯è°ƒå‚æ•°ï¼Œå¹³è¡¡åˆ†è¾¨ç‡å’Œæ³„æ¼

### æµ‹é‡ç³»ç»Ÿè¯¦è§£

#### æ¸¸æ ‡æµ‹é‡å®ç°
```typescript
// æ¸¸æ ‡ä½ç½®è·Ÿè¸ª
const cursorPosition = ref<{ x: number; y: number }>()

// é¼ æ ‡ç§»åŠ¨äº‹ä»¶å¤„ç†
chart.value.on('mousemove', (params: any) => {
  if (params.componentType === 'series') {
    const position = { x: params.value[0], y: params.value[1] }
    cursorPosition.value = position
    emit('cursorMove', position)
    
    // æ›´æ–°æ¸¸æ ‡æµ‹é‡ç»“æœ
    if (measurementMode.value === 'cursor') {
      updateCursorMeasurement(position)
    }
  }
})

// æ›´æ–°æ¸¸æ ‡æµ‹é‡
const updateCursorMeasurement = (position: { x: number; y: number }) => {
  // æ·»åŠ åˆ°æµ‹é‡ç‚¹åˆ—è¡¨
  if (cursorMeasurements.value.length >= 2) {
    cursorMeasurements.value.shift() // ä¿æŒæœ€å¤š2ä¸ªæ¸¸æ ‡
  }
  cursorMeasurements.value.push(position)
  
  // è®¡ç®—æ¸¸æ ‡é—´å·®å€¼
  if (cursorMeasurements.value.length === 2) {
    const [cursor1, cursor2] = cursorMeasurements.value
    const deltaX = Math.abs(cursor2.x - cursor1.x)
    const deltaY = Math.abs(cursor2.y - cursor1.y)
    
    // å‘å°„æµ‹é‡æ›´æ–°äº‹ä»¶
    emit('measurementUpdate', {
      type: 'cursor',
      deltaX,
      deltaY,
      cursors: cursorMeasurements.value
    })
  }
}
```

#### å³°å€¼æ£€æµ‹ç®—æ³•
```typescript
const detectPeaks = (data: number[], threshold = 0.1): MeasurementPoint[] => {
  const peaks: MeasurementPoint[] = []
  const xData = generateXAxisData()
  
  // ç®€å•å³°å€¼æ£€æµ‹ç®—æ³•
  for (let i = 1; i < data.length - 1; i++) {
    if (data[i] > data[i - 1] && 
        data[i] > data[i + 1] && 
        data[i] > threshold) {
      peaks.push({
        x: parseFloat(xData[i]),
        y: data[i],
        index: i
      })
    }
  }
  
  // æŒ‰å¹…åº¦æ’åºï¼Œå–å‰10ä¸ªå³°å€¼
  return peaks
    .sort((a, b) => b.y - a.y)
    .slice(0, 10)
    .map((peak, index) => ({
      ...peak,
      rank: index + 1
    }))
}

// é«˜çº§å³°å€¼æ£€æµ‹ï¼ˆä½¿ç”¨æ»‘åŠ¨çª—å£ï¼‰
const detectPeaksAdvanced = (data: number[], options: {
  minHeight?: number      // æœ€å°é«˜åº¦
  minDistance?: number    // æœ€å°è·ç¦»
  prominence?: number     // çªå‡ºåº¦
  width?: number         // å³°å®½
}) => {
  const { minHeight = 0, minDistance = 1, prominence = 0 } = options
  const peaks: MeasurementPoint[] = []
  
  for (let i = minDistance; i < data.length - minDistance; i++) {
    let isPeak = true
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºå±€éƒ¨æœ€å¤§å€¼
    for (let j = i - minDistance; j <= i + minDistance; j++) {
      if (j !== i && data[j] >= data[i]) {
        isPeak = false
        break
      }
    }
    
    if (isPeak && data[i] >= minHeight) {
      // è®¡ç®—çªå‡ºåº¦
      const leftMin = Math.min(...data.slice(Math.max(0, i - 10), i))
      const rightMin = Math.min(...data.slice(i + 1, Math.min(data.length, i + 11)))
      const peakProminence = data[i] - Math.max(leftMin, rightMin)
      
      if (peakProminence >= prominence) {
        peaks.push({
          x: i,
          y: data[i],
          prominence: peakProminence
        })
      }
    }
  }
  
  return peaks
}
```

#### ç»Ÿè®¡åˆ†æè®¡ç®—
```typescript
const statistics = computed<Statistics>(() => {
  if (!props.data?.series) {
    return { mean: 0, rms: 0, std: 0, max: 0, min: 0, pp: 0, crest: 0 }
  }

  let data: number[] = []
  if (Array.isArray(props.data.series[0])) {
    data = (props.data.series as number[][])[0] || []
  } else {
    data = props.data.series as number[]
  }

  if (data.length === 0) {
    return { mean: 0, rms: 0, std: 0, max: 0, min: 0, pp: 0, crest: 0 }
  }

  // åŸºç¡€ç»Ÿè®¡é‡
  const mean = data.reduce((sum, val) => sum + val, 0) / data.length
  const rms = Math.sqrt(data.reduce((sum, val) => sum + val * val, 0) / data.length)
  const variance = data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length
  const std = Math.sqrt(variance)
  const max = Math.max(...data)
  const min = Math.min(...data)
  const pp = max - min  // å³°å³°å€¼
  const crest = max / rms  // å³°å€¼å› å­

  return { mean, rms, std, max, min, pp, crest }
})

// é«˜çº§ç»Ÿè®¡åˆ†æ
const advancedStatistics = computed(() => {
  const data = getCurrentSeriesData()
  if (data.length === 0) return null
  
  return {
    // åŸºç¡€ç»Ÿè®¡
    ...statistics.value,
    
    // åˆ†å¸ƒç‰¹å¾
    skewness: calculateSkewness(data),      // ååº¦
    kurtosis: calculateKurtosis(data),      // å³°åº¦
    
    // é¢‘åŸŸç‰¹å¾
    spectralCentroid: calculateSpectralCentroid(data),  // é¢‘è°±é‡å¿ƒ
    spectralRolloff: calculateSpectralRolloff(data),    // é¢‘è°±æ»šé™
    
    // æ—¶åŸŸç‰¹å¾
    zeroCrossings: calculateZeroCrossings(data),        // è¿‡é›¶ç‡
    energy: calculateEnergy(data),                      // èƒ½é‡
    
    // ä¿¡å·è´¨é‡
    snr: calculateSNR(data),               // ä¿¡å™ªæ¯”
    thd: calculateTHD(data)                // æ€»è°æ³¢å¤±çœŸ
  }
})
```

### åŒè½´å›¾è¡¨ç³»ç»Ÿ

#### åŒYè½´é…ç½®
```typescript
const generateDualAxisOption = () => {
  return {
    yAxis: [
      {
        type: localOptions.value.logarithmic ? 'log' : 'value',
        scale: !localOptions.value.autoScale,
        position: 'left',
        name: 'ä¸»è½´',
        nameLocation: 'middle',
        nameGap: 50,
        axisLine: { 
          show: true,
          lineStyle: { color: '#409eff' }
        },
        axisTick: { show: true },
        axisLabel: { 
          show: true,
          color: '#409eff'
        },
        splitLine: { 
          show: localOptions.value.gridEnabled,
          lineStyle: { type: 'solid', color: '#e0e6ed' }
        }
      },
      {
        type: localOptions.value.logarithmic ? 'log' : 'value',
        scale: !localOptions.value.autoScale,
        position: 'right',
        name: 'å‰¯è½´',
        nameLocation: 'middle',
        nameGap: 50,
        axisLine: { 
          show: true,
          lineStyle: { color: '#67c23a' }
        },
        axisTick: { show: true },
        axisLabel: { 
          show: true,
          color: '#67c23a'
        },
        splitLine: { show: false }
      }
    ]
  }
}

// ç³»åˆ—æ•°æ®åˆ†é…åˆ°ä¸åŒYè½´
const assignSeriesToAxis = (seriesData: any[]) => {
  return seriesData.map((series, index) => ({
    ...series,
    yAxisIndex: index % 2, // å¥‡å¶åˆ†é…åˆ°ä¸åŒè½´
    lineStyle: {
      ...series.lineStyle,
      color: index % 2 === 0 ? '#409eff' : '#67c23a'
    }
  }))
}
```

#### è½´åŒæ­¥ç¼©æ”¾
```typescript
const syncAxisZoom = () => {
  if (!chart.value || !dualYAxis.value) return
  
  chart.value.on('dataZoom', (params: any) => {
    // åŒæ­¥ä¸¤ä¸ªYè½´çš„ç¼©æ”¾
    if (params.batch) {
      params.batch.forEach((zoom: any) => {
        if (zoom.yAxisIndex !== undefined) {
          const otherAxisIndex = zoom.yAxisIndex === 0 ? 1 : 0
          chart.value?.dispatchAction({
            type: 'dataZoom',
            yAxisIndex: otherAxisIndex,
            start: zoom.start,
            end: zoom.end
          })
        }
      })
    }
  })
}
```

### æ•°æ®å¤„ç†ç³»ç»Ÿ

#### å®æ—¶æ•°æ®æµå¤„ç†
```typescript
class RealTimeDataProcessor {
  private buffer: CircularBuffer<number>
  private updateInterval: number
  private isProcessing: boolean = false
  
  constructor(bufferSize: number = 10000, updateRate: number = 60) {
    this.buffer = new CircularBuffer(bufferSize)
    this.updateInterval = 1000 / updateRate // 60 FPS
  }
  
  // æ·»åŠ æ•°æ®ç‚¹
  addDataPoint(value: number) {
    this.buffer.push(value)
    
    if (!this.isProcessing) {
      this.scheduleUpdate()
    }
  }
  
  // æ‰¹é‡æ·»åŠ æ•°æ®
  addDataBatch(values: number[]) {
    values.forEach(value => this.buffer.push(value))
    
    if (!this.isProcessing) {
      this.scheduleUpdate()
    }
  }
  
  // è°ƒåº¦æ›´æ–°
  private scheduleUpdate() {
    this.isProcessing = true
    
    setTimeout(() => {
      this.processUpdate()
      this.isProcessing = false
    }, this.updateInterval)
  }
  
  // å¤„ç†æ›´æ–°
  private processUpdate() {
    const data = this.buffer.getLatestData(1000) // è·å–æœ€æ–°1000ä¸ªç‚¹
    
    // æ•°æ®æŠ½å–ï¼ˆå¦‚æœæ•°æ®é‡è¿‡å¤§ï¼‰
    const decimatedData = this.decimateData(data, 500)
    
    // è§¦å‘å›¾è¡¨æ›´æ–°
    this.emit('dataUpdate', {
      series: decimatedData,
      timestamp: Date.now()
    })
  }
  
  // æ•°æ®æŠ½å–
  private decimateData(data: number[], targetSize: number): number[] {
    if (data.length <= targetSize) return data
    
    const step = data.length / targetSize
    const result: number[] = []
    
    for (let i = 0; i < targetSize; i++) {
      const index = Math.floor(i * step)
      result.push(data[index])
    }
    
    return result
  }
}
```

#### æ•°æ®å‹ç¼©ç®—æ³•
```typescript
// é“æ ¼æ‹‰æ–¯-æ™®å…‹ç®—æ³•ï¼ˆDouglas-Peuckerï¼‰
const douglasPeucker = (points: Point[], epsilon: number): Point[] => {
  if (points.length <= 2) return points
  
  // æ‰¾åˆ°è·ç¦»ç›´çº¿æœ€è¿œçš„ç‚¹
  let maxDistance = 0
  let maxIndex = 0
  
  const start = points[0]
  const end = points[points.length - 1]
  
  for (let i = 1; i < points.length - 1; i++) {
    const distance = perpendicularDistance(points[i], start, end)
    if (distance > maxDistance) {
      maxDistance = distance
      maxIndex = i
    }
  }
  
  // å¦‚æœæœ€å¤§è·ç¦»å¤§äºé˜ˆå€¼ï¼Œé€’å½’å¤„ç†
  if (maxDistance > epsilon) {
    const left = douglasPeucker(points.slice(0, maxIndex + 1), epsilon)
    const right = douglasPeucker(points.slice(maxIndex), epsilon)
    
    return [...left.slice(0, -1), ...right]
  } else {
    return [start, end]
  }
}

// è®¡ç®—ç‚¹åˆ°ç›´çº¿çš„å‚ç›´è·ç¦»
const perpendicularDistance = (point: Point, lineStart: Point, lineEnd: Point): number => {
  const A = lineEnd.y - lineStart.y
  const B = lineStart.x - lineEnd.x
  const C = lineEnd.x * lineStart.y - lineStart.x * lineEnd.y
  
  return Math.abs(A * point.x + B * point.y + C) / Math.sqrt(A * A + B * B)
}

// LTTBç®—æ³•ï¼ˆLargest Triangle Three Bucketsï¼‰
const lttbDownsample = (data: Point[], targetSize: number): Point[] => {
  if (data.length <= targetSize) return data
  
  const bucketSize = (data.length - 2) / (targetSize - 2)
  const result: Point[] = [data[0]] // ä¿ç•™ç¬¬ä¸€ä¸ªç‚¹
  
  for (let i = 1; i < targetSize - 1; i++) {
    const bucketStart = Math.floor(i * bucketSize) + 1
    const bucketEnd = Math.floor((i + 1) * bucketSize) + 1
    
    // è®¡ç®—ä¸‹ä¸€ä¸ªæ¡¶çš„å¹³å‡ç‚¹
    const nextBucketStart = Math.floor((i + 1) * bucketSize) + 1
    const nextBucketEnd = Math.min(Math.floor((i + 2) * bucketSize) + 1, data.length)
    
    let avgX = 0, avgY = 0
    for (let j = nextBucketStart; j < nextBucketEnd; j++) {
      avgX += data[j].x
      avgY += data[j].y
    }
    avgX /= (nextBucketEnd - nextBucketStart)
    avgY /= (nextBucketEnd - nextBucketStart)
    
    // åœ¨å½“å‰æ¡¶ä¸­æ‰¾åˆ°å½¢æˆæœ€å¤§ä¸‰è§’å½¢çš„ç‚¹
    let maxArea = 0
    let maxIndex = bucketStart
    
    for (let j = bucketStart; j < bucketEnd; j++) {
      const area = triangleArea(
        result[result.length - 1],
        data[j],
        { x: avgX, y: avgY }
      )
      
      if (area > maxArea) {
        maxArea = area
        maxIndex = j
      }
    }
    
    result.push(data[maxIndex])
  }
  
  result.push(data[data.length - 1]) // ä¿ç•™æœ€åä¸€ä¸ªç‚¹
  return result
}

// è®¡ç®—ä¸‰è§’å½¢é¢ç§¯
const triangleArea = (a: Point, b: Point, c: Point): number => {
  return Math.abs((a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y)) / 2)
}
```

### å¯¼å‡ºåŠŸèƒ½ç³»ç»Ÿ

#### å›¾ç‰‡å¯¼å‡º
```typescript
const exportChart = (format: 'png' | 'jpg' | 'svg' | 'pdf') => {
  if (!chart.value) return

  const exportOptions = {
    type: format,
    pixelRatio: 2,
    backgroundColor: '#fff',
    excludeComponents: ['toolbox']
  }

  switch (format) {
    case 'png':
    case 'jpg':
      const url = chart.value.getDataURL(exportOptions)
      downloadFile(url, `chart_${Date.now()}.${format}`)
      break
      
    case 'svg':
      const svgString = chart.value.renderToSVGString()
      const blob = new Blob([svgString], { type: 'image/svg+xml' })
      const svgUrl = URL.createObjectURL(blob)
      downloadFile(svgUrl, `chart_${Date.now()}.svg`)
      URL.revokeObjectURL(svgUrl)
      break
      
    case 'pdf':
      exportToPDF()
      break
  }
}

// PDFå¯¼å‡º
const exportToPDF = async () => {
  const { jsPDF } = await import('jspdf')
  const pdf = new jsPDF('landscape', 'mm', 'a4')
  
  // è·å–å›¾è¡¨å›¾ç‰‡
  const imgData = chart.value?.getDataURL({
    type: 'png',
    pixelRatio: 2,
    backgroundColor: '#fff'
  })
  
  if (imgData) {
    // æ·»åŠ æ ‡é¢˜
    pdf.setFontSize(16)
    pdf.text('å›¾è¡¨åˆ†ææŠ¥å‘Š', 20, 20)
    
    // æ·»åŠ å›¾è¡¨
    pdf.addImage(imgData, 'PNG', 20, 30, 250, 150)
    
    // æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
    pdf.setFontSize(12)
    let yPos = 190
    pdf.text('ç»Ÿè®¡ä¿¡æ¯:', 20, yPos)
    
    const stats = statistics.value
    pdf.text(`å¹³å‡å€¼: ${stats.mean.toFixed(3)}`, 20, yPos + 10)
    pdf.text(`RMS: ${stats.rms.toFixed(3)}`, 20, yPos + 20)
    pdf.text(`æ ‡å‡†å·®: ${stats.std.toFixed(3)}`, 20, yPos + 30)
    pdf.text(`æœ€å¤§å€¼: ${stats.max.toFixed(3)}`, 80, yPos + 10)
    pdf.text(`æœ€å°å€¼: ${stats.min.toFixed(3)}`, 80, yPos + 20)
    pdf.text(`å³°å³°å€¼: ${stats.pp.toFixed(3)}`, 80, yPos + 30)
    
    // ä¿å­˜PDF
    pdf.save(`chart_report_${Date.now()}.pdf`)
  }
}
```

#### æ•°æ®å¯¼å‡º
```typescript
const exportToCSV = () => {
  if (!props.data) return

  let csvContent = 'X,Y\n'
  const xData = generateXAxisData()
  
  if (Array.isArray(props.data.series[0])) {
    // å¤šç³»åˆ—æ•°æ®
    const headers = ['X', ...(props.data.series as number[][]).map((_, i) => `Series${i + 1}`)]
    csvContent = headers.join(',') + '\n'
    
    const maxLength = Math.max(...(props.data.series as number[][]).map(s => s.length))
    for (let i = 0; i < maxLength; i++) {
      const row = [xData[i]]
      ;(props.data.series as number[][]).forEach(series => {
        row.push(series[i]?.toString() || '')
      })
      csvContent += row.join(',') + '\n'
    }
  } else {
    // å•ç³»åˆ—æ•°æ®
    ;(props.data.series as number[]).forEach((value, index) => {
      csvContent += `${xData[index]},${value}\n`
    })
  }

  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' })
  const url = URL.createObjectURL(blob)
  downloadFile(url, `chart_data_${Date.now()}.csv`)
  URL.revokeObjectURL(url)
}

// Excelå¯¼å‡º
const exportToExcel = async () => {
  const { utils, writeFile } = await import('xlsx')
  
  if (!props.data) return
  
  const workbook = utils.book_new()
  const xData = generateXAxisData()
  
  // å‡†å¤‡æ•°æ®
  const worksheetData: any[][] = []
  
  if (Array.isArray(props.data.series[0])) {
    // å¤šç³»åˆ—æ•°æ®
    const headers = ['X', ...(props.data.series as number[][]).map((_, i) => `Series${i + 1}`)]
    worksheetData.push(headers)
    
    const maxLength = Math.max(...(props.data.series as number[][]).map(s => s.length))
    for (let i = 0; i < maxLength; i++) {
      const row = [xData[i]]
      ;(props.data.series as number[][]).forEach(series => {
        row.push(series[i] || '')
      })
      worksheetData.push(row)
    }
  } else {
    // å•ç³»åˆ—æ•°æ®
    worksheetData.push(['X', 'Y'])
    ;(props.data.series as number[]).forEach((value, index) => {
      worksheetData.push([xData[index], value])
    })
  }
  
  // åˆ›å»ºå·¥ä½œè¡¨
  const worksheet = utils.aoa_to_sheet(worksheetData)
  utils.book_append_sheet(workbook, worksheet, 'å›¾è¡¨æ•°æ®')
  
  // æ·»åŠ ç»Ÿè®¡ä¿¡æ¯å·¥ä½œè¡¨
  const statsData = [
    ['ç»Ÿè®¡é¡¹', 'æ•°å€¼'],
    ['å¹³å‡å€¼', statistics.value.mean],
    ['RMS', statistics.value.rms],
    ['æ ‡å‡†å·®', statistics.value.std],
    ['æœ€å¤§å€¼', statistics.value.max],
    ['æœ€å°å€¼', statistics.value.min],
    ['å³°å³°å€¼', statistics.value.pp],
    ['å³°å€¼å› å­', statistics.value.crest]
  ]
  
  const statsWorksheet = utils.aoa_to_sheet(statsData)
  utils.book_append_sheet(workbook, statsWorksheet, 'ç»Ÿè®¡åˆ†æ')
  
  // ä¿å­˜æ–‡ä»¶
  writeFile(workbook, `chart_analysis_${Date.now()}.xlsx`)
}
```

## ğŸ“Š StripChart æ¡å¸¦å›¾è¯¦è§£

### æ§ä»¶ç‰¹æ€§

StripChartæ˜¯ä¸“ä¸ºå®æ—¶æ•°æ®æ˜¾ç¤ºè®¾è®¡çš„æ¡å¸¦å›¾æ§ä»¶ï¼Œç‰¹åˆ«é€‚ç”¨äºè¿ç»­ç›‘æ§å’Œè¶‹åŠ¿åˆ†æã€‚

#### æ ¸å¿ƒåŠŸèƒ½
```typescript
interface StripChartProps {
  data: number[]              // å®æ—¶æ•°æ®æµ
  maxPoints?: number          // æœ€å¤§æ˜¾ç¤ºç‚¹æ•°
  timeWindow?: number         // æ—¶é—´çª—å£(ç§’)
  autoScroll?: boolean        // è‡ªåŠ¨æ»šåŠ¨
  showGrid?: boolean          // æ˜¾ç¤ºç½‘æ ¼
  showCursor?: boolean        // æ˜¾ç¤ºæ¸¸æ ‡
  colors?: StripChartColors   // é¢œè‰²é…ç½®
  thresholds?: ThresholdLine[] // é˜ˆå€¼çº¿
}

interface ThresholdLine {
  value: number
  color: string
  label?: string
  style?: 'solid' | 'dashed' | 'dotted'
}
```

#### å®æ—¶æ•°æ®å¤„ç†
```typescript
class StripChartDataManager {
  private dataBuffer: CircularBuffer<DataPoint>
  private updateTimer: number | null = null
  
  constructor(maxPoints: number = 1000) {
    this.dataBuffer = new CircularBuffer(maxPoints)
  }
  
  // æ·»åŠ æ•°æ®ç‚¹
  addPoint(value: number, timestamp?: number) {
    const point: DataPoint = {
      value,
      timestamp: timestamp || Date.now()
    }
    
    this.dataBuffer.push(point)
    this.scheduleUpdate()
  }
  
  // æ‰¹é‡æ·»åŠ æ•°æ®
  addBatch(values: number[], startTime?: number) {
    const now = startTime || Date.now()
    const interval = 1000 / values.length // å‡è®¾1ç§’å†…çš„æ•°æ®
    
    values.forEach((value, index) => {
      this.addPoint(value, now + index * interval)
    })
  }
  
  // è·å–æ˜¾ç¤ºæ•°æ®
  getDisplayData(timeWindow: number): DataPoint[] {
    const now = Date.now()
    const startTime = now - timeWindow * 1000
    
    return this.dataBuffer.getAll()
      .filter(point => point.timestamp >= startTime)
      .sort((a, b) => a.timestamp - b.timestamp)
  }
  
  // è°ƒåº¦æ›´æ–°
  private scheduleUpdate() {
    if (this.updateTimer) return
    
    this.updateTimer = requestAnimationFrame(() => {
      this.emit('dataUpdate', this.getDisplayData(this.timeWindow))
      this.updateTimer = null
    })
  }
}
```

### è‡ªåŠ¨æ»šåŠ¨æœºåˆ¶
```typescript
const autoScrollManager = {
  isEnabled: ref(true),
  scrollSpeed: ref(1), // åƒç´ /æ¯«ç§’
  
  // è®¡ç®—æ»šåŠ¨ä½ç½®
  calculateScrollPosition(dataLength: number, maxPoints: number): number {
    if (!this.isEnabled.value || dataLength <= maxPoints) {
      return 0
    }
    
    const overflow = dataLength - maxPoints
    return overflow * this.scrollSpeed.value
  },
  
  // å¹³æ»‘æ»šåŠ¨åŠ¨ç”»
  smoothScroll(chart: echarts.ECharts, targetPosition: number) {
    const currentPosition = chart.getOption().dataZoom[0].start || 0
    const distance = targetPosition - currentPosition
    const duration = 200 // 200msåŠ¨ç”»
    
    let startTime: number
    
    const animate = (timestamp: number) => {
      if (!startTime) startTime = timestamp
      
      const elapsed = timestamp - startTime
      const progress = Math.min(elapsed / duration, 1)
      
      // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
      const easeProgress = 1 - Math.pow(1 - progress, 3)
      const currentPos = currentPosition + distance * easeProgress
      
      chart.setOption({
        dataZoom: [{
          start: currentPos,
          end: currentPos + (100 * maxPoints / dataLength)
        }]
      })
      
      if (progress < 1) {
        requestAnimationFrame(animate)
      }
    }
    
    requestAnimationFrame(animate)
  }
}
```

## ğŸ“ˆ SpectrumChart é¢‘è°±å›¾è¯¦è§£

### é¢‘è°±åˆ†æå¼•æ“

#### é«˜çº§FFTå®ç°
```typescript
class AdvancedFFTAnalyzer {
  private fftSize: number
  private windowFunction: WindowFunction
  private overlapRatio: number
  
  constructor(config: FFTConfig) {
    this.fftSize = config.size
    this.windowFunction = this.createWindowFunction(config.window)
    this.overlapRatio = config.overlap / 100
  }
  
  // åˆ›å»ºçª—å‡½æ•°
  private createWindowFunction(type: WindowType): WindowFunction {
    switch (type) {
      case 'kaiser':
        return this.createKaiserWindow(8.6) // Î² = 8.6
      case 'tukey':
        return this.createTukeyWindow(0.5)  // Î± = 0.5
      case 'gaussian':
        return this.createGaussianWindow(0.4) // Ïƒ = 0.4
      default:
        return this.createHanningWindow()
    }
  }
  
  // å‡¯æ³½çª—
  private createKaiserWindow(beta: number): WindowFunction {
    return (n: number, N: number) => {
      const arg = beta * Math.sqrt(1 - Math.pow(2 * n / (N - 1) - 1, 2))
      return this.modifiedBesselI0(arg) / this.modifiedBesselI0(beta)
    }
  }
  
  // ä¿®æ­£è´å¡å°”å‡½æ•°I0
  private modifiedBesselI0(x: number): number {
    let sum = 1
    let term = 1
    
    for (let k = 1; k < 50; k++) {
      term *= (x / (2 * k)) ** 2
      sum += term
      
      if (term < 1e-12) break
    }
    
    return sum
  }
  
  // é‡å å¤„ç†FFT
  public analyzeWithOverlap(signal: number[]): SpectrumResult {
    const hopSize = Math.floor(this.fftSize * (1 - this.overlapRatio))
    const numFrames = Math.floor((signal.length - this.fftSize) / hopSize) + 1
    
    const spectrogram: number[][] = []
    const avgSpectrum = new Array(this.fftSize / 2).fill(0)
    
    for (let frame = 0; frame < numFrames; frame++) {
      const start = frame * hopSize
      const frameData = signal.slice(start, start + this.fftSize)
      
      // åº”ç”¨çª—å‡½æ•°
      const windowedData = frameData.map((value, index) => 
        value * this.windowFunction(index, this.fftSize)
      )
      
      // æ‰§è¡ŒFFT
      const spectrum = this.computeFFT(windowedData)
      spectrogram.push(spectrum.magnitudes)
      
      // ç´¯åŠ åˆ°å¹³å‡é¢‘è°±
      spectrum.magnitudes.forEach((mag, index) => {
        avgSpectrum[index] += mag
      })
    }
    
    // è®¡ç®—å¹³å‡é¢‘è°±
    avgSpectrum.forEach((_, index) => {
      avgSpectrum[index] /= numFrames
    })
    
    return {
      frequencies: this.generateFrequencies(),
      averageSpectrum: avgSpectrum,
      spectrogram: spectrogram,
      timeAxis: this.generateTimeAxis(numFrames, hopSize)
    }
  }
  
  // é¢‘è°±å³°å€¼æ£€æµ‹
  public detectSpectralPeaks(spectrum: number[], options: PeakDetectionOptions): SpectralPeak[] {
    const peaks: SpectralPeak[] = []
    const frequencies = this.generateFrequencies()
    
    for (let i = 1; i < spectrum.length - 1; i++) {
      if (spectrum[i] > spectrum[i - 1] && 
          spectrum[i] > spectrum[i + 1] && 
          spectrum[i] > options.minHeight) {
        
        // ä½¿ç”¨æŠ›ç‰©çº¿æ’å€¼æé«˜é¢‘ç‡ç²¾åº¦
        const y1 = spectrum[i - 1]
        const y2 = spectrum[i]
        const y3 = spectrum[i + 1]
        
        const a = (y1 - 2 * y2 + y3) / 2
        const b = (y3 - y1) / 2
        
        const peakOffset = -b / (2 * a)
        const peakFreq = frequencies[i] + peakOffset * (frequencies[1] - frequencies[0])
        const peakMag = y2 - a * peakOffset * peakOffset
        
        peaks.push({
          frequency: peakFreq,
          magnitude: peakMag,
          index: i,
          quality: this.calculatePeakQuality(spectrum, i)
        })
      }
    }
    
    return peaks.sort((a, b) => b.magnitude - a.magnitude)
  }
  
  // è®¡ç®—å³°å€¼è´¨é‡å› å­
  private calculatePeakQuality(spectrum: number[], peakIndex: number): number {
    const peakValue = spectrum[peakIndex]
    
    // è®¡ç®—3dBå¸¦å®½
    const halfPower = peakValue / Math.sqrt(2)
    let leftIndex = peakIndex
    let rightIndex = peakIndex
    
    // å‘å·¦æœç´¢3dBç‚¹
    while (leftIndex > 0 && spectrum[leftIndex] > halfPower) {
      leftIndex--
    }
    
    // å‘å³æœç´¢3dBç‚¹
    while (rightIndex < spectrum.length - 1 && spectrum[rightIndex] > halfPower) {
      rightIndex++
    }
    
    const bandwidth = rightIndex - leftIndex
    return bandwidth > 0 ? peakValue / bandwidth : 0
  }
}
```

### é¢‘è°±æ˜¾ç¤ºä¼˜åŒ–

#### å¯¹æ•°é¢‘ç‡è½´
```typescript
const generateLogFrequencyAxis = (minFreq: number, maxFreq: number, points: number): number[] => {
  const logMin = Math.log10(minFreq)
  const logMax = Math.log10(maxFreq)
  const logStep = (logMax - logMin) / (points - 1)
  
  return Array.from({ length: points }, (_, i) => 
    Math.pow(10, logMin + i * logStep)
  )
}

// é¢‘ç‡è½´æ ‡ç­¾æ ¼å¼åŒ–
const formatFrequencyLabel = (freq: number): string => {
  if (freq >= 1e9) return `${(freq / 1e9).toFixed(1)}G`
  if (freq >= 1e6) return `${(freq / 1e6).toFixed(1)}M`
  if (freq >= 1e3) return `${(freq / 1e3).toFixed(1)}k`
  return freq.toFixed(0)
}
```

#### ç€‘å¸ƒå›¾æ˜¾ç¤º
```typescript
const generateWaterfallChart = (spectrogram: number[][], options: WaterfallOptions) => {
  const { colormap = 'viridis', dynamicRange = 60 } = options
  
  // è®¡ç®—é¢œè‰²æ˜ å°„
  const maxValue = Math.max(...spectrogram.flat())
  const minValue = maxValue - dynamicRange
  
  const waterfallData = spectrogram.map((spectrum, timeIndex) => 
    spectrum.map((magnitude, freqIndex) => {
      const normalizedMag = (magnitude - minValue) / (maxValue - minValue)
      const clampedMag = Math.max(0, Math.min(1, normalizedMag))
      
      return {
        x: freqIndex,
        y: timeIndex,
        value: clampedMag,
        magnitude: magnitude
      }
    })
  ).flat()
  
  return {
    type: 'heatmap',
    data: waterfallData,
    emphasis: {
      itemStyle: {
        borderColor: '#333',
        borderWidth: 1
      }
    },
    visualMap: {
      min: 0,
      max: 1,
      calculable: true,
      orient: 'horizontal',
      left: 'center',
      bottom: '15%',
      inRange: {
        color: getColormapColors(colormap)
      }
    }
  }
}

// é¢œè‰²æ˜ å°„
const getColormapColors = (colormap: string): string[] => {
  const colormaps = {
    viridis: ['#440154', '#482777', '#3f4a8a', '#31678e', '#26838f', '#1f9d8a', '#6cce5a', '#b6de2b', '#fee825'],
    plasma: ['#0c0786', '#40039c', '#6a00a7', '#8f0da4', '#b12a90', '#cc4778', '#e16462', '#f1834c', '#fca636', '#fcce25'],
    jet: ['#000080', '#0000ff', '#0080ff', '#00ffff', '#80ff00', '#ffff00', '#ff8000', '#ff0000', '#800000']
  }
  
  return colormaps[colormap] || colormaps.viridis
}
```

## ğŸ”§ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### å¤§æ•°æ®é‡å¤„ç†

#### æ•°æ®åˆ†å±‚æ¸²æŸ“
```typescript
class LayeredDataRenderer {
  private layers: Map<string, DataLayer> = new Map()
  
  // æ·»åŠ æ•°æ®å±‚
  addLayer(name: string, data: number[], config: LayerConfig) {
    const layer: DataLayer = {
      name,
      data: this.processDataForLayer(data, config),
      config,
      visible: true,
      zIndex: config.zIndex || 0
    }
    
    this.layers.set(name, layer)
    this.updateRenderOrder()
  }
  
  // å¤„ç†å±‚æ•°æ®
  private processDataForLayer(data: number[], config: LayerConfig): ProcessedData {
    const { maxPoints, compressionMethod } = config
    
    if (data.length <= maxPoints) {
      return { original: data, compressed: data }
    }
    
    let compressed: number[]
    
    switch (compressionMethod) {
      case 'lttb':
        compressed = this.lttbCompress(data, maxPoints)
        break
      case 'douglas-peucker':
        compressed = this.douglasPeuckerCompress(data, config.tolerance || 0.1)
        break
      case 'uniform':
      default:
        compressed = this.uniformSample(data, maxPoints)
        break
    }
    
    return { original: data, compressed }
  }
  
  // è‡ªé€‚åº”æ¸²æŸ“
  render(chart: echarts.ECharts, viewport: Viewport) {
    const visibleLayers = Array.from(this.layers.values())
      .filter(layer => layer.visible)
      .sort((a, b) => a.zIndex - b.zIndex)
    
    const series = visibleLayers.map(layer => {
      const useCompressed = this.shouldUseCompression(layer, viewport)
      const data = useCompressed ? layer.data.compressed : layer.data.original
      
      return {
        name: layer.name,
        type: 'line',
        data: data,
        ...layer.config.style
      }
    })
    
    chart.setOption({ series }, false)
  }
  
  // åˆ¤æ–­æ˜¯å¦ä½¿ç”¨å‹ç¼©æ•°æ®
  private shouldUseCompression(layer: DataLayer, viewport: Viewport): boolean {
    const pixelRatio = window.devicePixelRatio || 1
    const viewportWidth = viewport.width * pixelRatio
    const dataPointsPerPixel = layer.data.original.length / viewportWidth
    
    return dataPointsPerPixel > 2 // æ¯åƒç´ è¶…è¿‡2ä¸ªæ•°æ®ç‚¹æ—¶ä½¿ç”¨å‹ç¼©
  }
}
```

#### WebGLåŠ é€Ÿæ¸²æŸ“
```typescript
class WebGLChartRenderer {
  private gl: WebGLRenderingContext
  private shaderProgram: WebGLProgram
  private buffers: Map<string, WebGLBuffer> = new Map()
  
  constructor(canvas: HTMLCanvasElement) {
    this.gl = canvas.getContext('webgl')!
    this.initShaders()
    this.initBuffers()
  }
  
  // åˆå§‹åŒ–ç€è‰²å™¨
  private initShaders() {
    const vertexShaderSource = `
      attribute vec2 a_position;
      attribute vec3 a_color;
      uniform vec2 u_resolution;
      uniform mat3 u_transform;
      varying vec3 v_color;
      
      void main() {
        vec3 position = u_transform * vec3(a_position, 1.0);
        vec2 clipSpace = ((position.xy / u_resolution) * 2.0) - 1.0;
        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        v_color = a_color;
      }
    `
    
    const fragmentShaderSource = `
      precision mediump float;
      varying vec3 v_color;
      
      void main() {
        gl_FragColor = vec4(v_color, 1.0);
      }
    `
    
    this.shaderProgram = this.createShaderProgram(vertexShaderSource, fragmentShaderSource)
  }
  
  // æ¸²æŸ“çº¿æ¡
  renderLines(data: Point[], color: [number, number, number]) {
    const positions = new Float32Array(data.length * 2)
    const colors = new Float32Array(data.length * 3)
    
    data.forEach((point, index) => {
      positions[index * 2] = point.x
      positions[index * 2 + 1] = point.y
      colors[index * 3] = color[0]
      colors[index * 3 + 1] = color[1]
      colors[index * 3 + 2] = color[2]
    })
    
    // æ›´æ–°ç¼“å†²åŒº
    this.updateBuffer('position', positions)
    this.updateBuffer('color', colors)
    
    // ç»˜åˆ¶
    this.gl.useProgram(this.shaderProgram)
    this.gl.drawArrays(this.gl.LINE_STRIP, 0, data.length)
  }
  
  // æ‰¹é‡æ¸²æŸ“å¤šæ¡çº¿
  renderMultipleLines(datasets: LineDataset[]) {
    datasets.forEach(dataset => {
      this.renderLines(dataset.data, dataset.color)
    })
  }
}
```

### å†…å­˜ç®¡ç†ä¼˜åŒ–

#### å¯¹è±¡æ± æ¨¡å¼
```typescript
class DataPointPool {
  private pool: DataPoint[] = []
  private maxSize: number
  
  constructor(maxSize: number = 1000) {
    this.maxSize = maxSize
    this.preallocate()
  }
  
  // é¢„åˆ†é…å¯¹è±¡
  private preallocate() {
    for (let i = 0; i < this.maxSize; i++) {
      this.pool.push({ x: 0, y: 0, timestamp: 0 })
    }
  }
  
  // è·å–å¯¹è±¡
  acquire(): DataPoint {
    return this.pool.pop() || { x: 0, y: 0, timestamp: 0 }
  }
  
  // é‡Šæ”¾å¯¹è±¡
  release(point: DataPoint) {
    if (this.pool.length < this.maxSize) {
      // é‡ç½®å¯¹è±¡çŠ¶æ€
      point.x = 0
      point.y = 0
      point.timestamp = 0
      this.pool.push(point)
    }
  }
  
  // æ‰¹é‡é‡Šæ”¾
  releaseBatch(points: DataPoint[]) {
    points.forEach(point => this.release(point))
  }
}
```

## ğŸ› å¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

### æ€§èƒ½é—®é¢˜

**é—®é¢˜1ï¼šå¤§æ•°æ®é‡å¯¼è‡´æ¸²æŸ“å¡é¡¿**
- **åŸå› **ï¼šæ•°æ®ç‚¹è¿‡å¤šï¼Œè¶…å‡ºæµè§ˆå™¨æ¸²æŸ“èƒ½åŠ›
- **è§£å†³æ–¹æ¡ˆ**ï¼š
  ```typescript
  // å®ç°è‡ªé€‚åº”æ•°æ®æŠ½å–
  const adaptiveDataSampling = (data: number[], maxPoints: number = 1000) => {
    if (data.length <= maxPoints) return data
    
    const step = data.length / maxPoints
    const sampled: number[] = []
    
    for (let i = 0; i < maxPoints; i++) {
      const index = Math.floor(i * step)
      sampled.push(data[index])
    }
    
    return sampled
  }
  ```

**é—®é¢˜2ï¼šFFTè®¡ç®—è€—æ—¶è¿‡é•¿**
- **åŸå› **ï¼šFFTç®—æ³•å¤æ‚åº¦é«˜ï¼Œæ•°æ®é‡å¤§
- **è§£å†³æ–¹æ¡ˆ**ï¼š
  ```typescript
  // ä½¿ç”¨Web Workerè¿›è¡ŒFFTè®¡ç®—
  class FFTWorkerManager {
    private worker: Worker
    
    constructor() {
      this.worker = new Worker('/workers/fft-worker.js')
    }
    
    async computeFFT(data: number[], config: FFTConfig): Promise<FFTResult> {
      return new Promise((resolve) => {
        this.worker.postMessage({ data, config })
        this.worker.onmessage = (e) => resolve(e.data)
      })
    }
  }
  ```

**é—®é¢˜3ï¼šå†…å­˜æ³„æ¼**
- **åŸå› **ï¼šäº‹ä»¶ç›‘å¬å™¨å’Œå®šæ—¶å™¨æœªæ­£ç¡®æ¸…ç†
- **è§£å†³æ–¹æ¡ˆ**ï¼š
  ```typescript
  // å®Œå–„çš„æ¸…ç†æœºåˆ¶
  onUnmounted(() => {
    // æ¸…ç†å›¾è¡¨å®ä¾‹
    chart.value?.dispose()
    fftChart.value?.dispose()
    
    // æ¸…ç†å®šæ—¶å™¨
    clearInterval(updateTimer)
    clearTimeout(debounceTimer)
    
    // æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
    window.removeEventListener('resize', handleResize)
    document.removeEventListener('visibilitychange', handleVisibilityChange)
    
    // æ¸…ç†Worker
    fftWorker?.terminate()
    
    // æ¸…ç†ç¼“å­˜
    dataCache.clear()
    pathCache.clear()
  })
  ```

### æ•°æ®é—®é¢˜

**é—®é¢˜4ï¼šå®æ—¶æ•°æ®æ›´æ–°ä¸å¹³æ»‘**
- **åŸå› **ï¼šæ•°æ®æ›´æ–°é¢‘ç‡ä¸ç¨³å®š
- **è§£å†³æ–¹æ¡ˆ**ï¼š
  ```typescript
  // å®ç°æ•°æ®ç¼“å†²å’Œå¹³æ»‘æ›´æ–°
  class SmoothDataUpdater {
    private buffer: number[] = []
    private updateRate: number = 60 // 60 FPS
    private lastUpdate: number = 0
    
    addData(value: number) {
      this.buffer.push(value)
      
      const now = performance.now()
      if (now - this.lastUpdate >= 1000 / this.updateRate) {
        this.flushBuffer()
        this.lastUpdate = now
      }
    }
    
    private flushBuffer() {
      if (this.buffer.length > 0) {
        emit('dataUpdate', [...this.buffer])
        this.buffer.length = 0
      }
    }
  }
  ```

## ğŸ“š æœ€ä½³å®è·µ

### è®¾è®¡åŸåˆ™

1. **æ€§èƒ½ä¼˜å…ˆ**ï¼šä¼˜åŒ–æ¸²æŸ“æ€§èƒ½ï¼Œæ”¯æŒå¤§æ•°æ®é‡æ˜¾ç¤º
2. **ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›æµç•…çš„äº¤äº’å’Œç›´è§‚çš„æ“ä½œ
3. **åŠŸèƒ½å®Œæ•´**ï¼šé›†æˆä¸“ä¸šçš„åˆ†æå·¥å…·å’Œæµ‹é‡åŠŸèƒ½
4. **æ‰©å±•æ€§å¼º**ï¼šæ”¯æŒè‡ªå®šä¹‰é…ç½®å’ŒåŠŸèƒ½æ‰©å±•

### ä½¿ç”¨å»ºè®®

1. **åˆç†é€‰æ‹©å›¾è¡¨ç±»å‹**ï¼šæ ¹æ®æ•°æ®ç‰¹æ€§é€‰æ‹©æœ€é€‚åˆçš„å›¾è¡¨
2. **ä¼˜åŒ–æ•°æ®æ›´æ–°é¢‘ç‡**ï¼šå¹³è¡¡å®æ—¶æ€§å’Œæ€§èƒ½
3. **ä½¿ç”¨æ•°æ®å‹ç¼©**ï¼šå¯¹å¤§æ•°æ®é‡è¿›è¡Œæ™ºèƒ½å‹ç¼©
4. **å¯ç”¨ç¡¬ä»¶åŠ é€Ÿ**ï¼šåˆ©ç”¨WebGLæå‡æ¸²æŸ“æ€§èƒ½

### æ‰©å±•å¼€å‘

1. **è‡ªå®šä¹‰åˆ†æç®—æ³•**ï¼šé›†æˆæ›´å¤šä¿¡å·å¤„ç†ç®—æ³•
2. **å¤šå›¾è¡¨è”åŠ¨**ï¼šå®ç°å›¾è¡¨é—´çš„æ•°æ®åŒæ­¥
3. **äº‘ç«¯åˆ†æ**ï¼šå°†å¤æ‚è®¡ç®—è¿ç§»åˆ°æœåŠ¡ç«¯
4. **AIè¾…åŠ©åˆ†æ**ï¼šé›†æˆæœºå™¨å­¦ä¹ ç®—æ³•è¿›è¡Œæ™ºèƒ½åˆ†æ

---

*å›¾è¡¨æ§ä»¶æ˜¯æ•°æ®å¯è§†åŒ–çš„æ ¸å¿ƒï¼ŒæŒæ¡å…¶é«˜çº§åŠŸèƒ½å’Œä¼˜åŒ–æŠ€å·§å¯¹äºæ„å»ºä¸“ä¸šçš„æµ‹æ§ç³»ç»Ÿè‡³å…³é‡è¦ã€‚*
